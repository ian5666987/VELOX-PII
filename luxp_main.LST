C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE LUXP_MAIN
NO OBJECT MODULE REQUESTED
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE luxp_main.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

*** WARNING C500 IN LINE 1 OF LUXP_MAIN.C: LICENSE ERROR (R20D: CONTENT ERROR IN FLF FILE)

   1          //------------------------------------------------------------------------------------
   2          // Luxp_main.c
   3          //------------------------------------------------------------------------------------
   4          // Copyright (C) 2013 Nanyang Technological University.
   5          //
   6          // AUTH: IAN
   7          // DATE: 03 APR 2013
   8          //
   9          // The program Luxp_main.c will be downloaded to the Pumpkin Motherboard with 
  10          // C8051F120 uC as the main program of VELOX-P Pico-Satellite Flight Software. 
  11          //
  12          // Starts from version 0.3, LUX-P software uses code banking. LUX-P software version
  13          // 0.3b is identical with version 0.3 except that it does not use code banking. 
  14          //
  15          // Starts from version 0.7l, running multiple commands in one loop is implemented.
  16          // Version 0.7k is the last version in which we can give commands longer than
  17          // 16 bytes and are still executed. Starts from version 0.7l, no command longer
  18          // than 16 bytes can be executed. But, every single command in the command queue 
  19          // will now be first executed before SCM is run again.
  20          //
  21          // Version 0.7x is the optimized and organized version of 0.7w. Some potentially
  22          // unused codes and data are removed here. Besides, some data are collected together.
  23          // There is no main functional change between two versions. Code banking is not
  24          // supported in the version. The organization and optimization is half-way done.
  25          // Thus in the later version, more optimization and organization will be needed.
  26          //
  27          // Additional minor functional changes in version 0.7x and above:
  28          //      1) Maximum time to send a data down now is limited to 15 minutes.
  29          //      2) Checking transmitter current is more than one time
  30          //              before we decide if it is ok to start new transmission.
  31          //      3) No of bytes transmitted in single transmission is limited down to 235 instead 
  32          //              of 237.
  33          //      4) Receiver checking is done more than one time to determine if there is really
  34          //              anything in the receiver buffer.
  35          //      5) Recovery attempt for overly long single transmission is added in the beacon
  36          //              handler
  37          //
  38          // Changes in version 0.8e and above:
  39          //      1) idleModeHandler now does not handle ACS to ON/OFF. It only turn OFF ADS.
  40          //      2) When bodyRateHandler finish its stabilization, it turn OFF ADS but not ACS.
  41          //
  42          // This is LUX-P Software version 1.1
  43          //
  44          // Changes from version 1.0
  45          //  1) Optimization of the SD card timing, allowing faster satellite's response
  46          //     in the event of SD card failure.
  47          //
  48          // Target: C8051F120
  49          //
  50          //------------------------------------------------------------------------------------
  51          
  52          //------------------------------------------------------------------------------------
  53          // Includes
  54          //------------------------------------------------------------------------------------
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 2   

  55          #include <luxp_main.h>
  56          
  57          //-----------------------------------------------------------------------------
  58          // 16-bit SFR declarations
  59          //-----------------------------------------------------------------------------
  60          sbit SDA = P0^6;                       // SMBus on P0.6 (SDA)
  61          sbit SCL = P0^7;                       // and P0.7 (SCL)
  62          
  63          //-----------------------------------------------------------------------------
  64          // Structures for OBDH
  65          //-----------------------------------------------------------------------------
  66          struct OBDHHKStruct                                     str_obdh_hk;
  67          struct OBDHParStruct                            str_obdh_par;
  68          struct OBDHDataStruct                           str_obdh_data;
  69          struct SchedulerStruct                          str_scheduler;
  70          struct ScriptlineTimerStruct            str_scriptline_timer[SCRIPTLINE_TIMER_SIZE];
  71          struct TaskStruct                                       str_task[TASK_SIZE];
  72          struct ScriptlineRetryCounterStruct     str_scriptline_retry_counter[SCRIPTLINE_RETRY_COUNTER_SIZE];
  73          struct ScriptspaceStruct                        str_scriptspace[SCRIPTSPACE_SIZE];
  74          
  75          //-----------------------------------------------------------------------------
  76          // Structures for data storing
  77          //-----------------------------------------------------------------------------
  78          struct IMCHKStruct              str_imc_hk;
  79          struct ITCHKStruct              str_itc_hk;
  80          struct AntennaHKStruct  str_antenna_hk;
  81          struct RTCDataStruct    str_rtc_data;
  82          struct PWRSHKStruct             str_pwrs_hk;
  83          struct PWRSParStruct    str_pwrs_par;
  84          struct PWRSDataStruct   str_pwrs_data;
  85          struct ADCSHKStruct             str_adcs_hk;
  86          struct ADCSParStruct    str_adcs_par;
  87          struct BPStruct                 str_bp;
  88          
  89          //------------------------------------------------------------------------------------
  90          // Structures for date and time
  91          //------------------------------------------------------------------------------------
  92          struct SatTimeStruct                    str_sat_time;
  93          struct SatDateStruct                    str_sat_date;
  94          struct DateUpdateFromRefStruct  str_date_update;
  95          
  96          //-----------------------------------------------------------------------------
  97          // Oscillator variables (parameters)
  98          //-----------------------------------------------------------------------------
  99          #if (SYSCLK_USED == LEVEL_3_SYSCLK)
              unsigned long OSC_FREQUENCY = EXT_OSC_FREQUENCY;
              unsigned long SYSCLK            = EXT_SYSCLK;
              #elif (SYSCLK_USED == LEVEL_2_SYSCLK)
 103          unsigned long OSC_FREQUENCY = EXT_OSC_FREQUENCY;
 104          unsigned long SYSCLK            = EXT_SYSCLK;
 105          #elif (SYSCLK_USED == LEVEL_1_SYSCLK)
              unsigned long OSC_FREQUENCY = INT_OSC_FREQUENCY;
              unsigned long SYSCLK            = INT_SYSCLK;
              #endif
 109          
 110          #if (SYSCLK_USED == LEVEL_3_SYSCLK)
              unsigned char PLL_MUL           = EXT_PLL_MUL;
              unsigned char PLL_DIV           = EXT_PLL_DIV;
              unsigned long PLL_DIV_CLK       = EXT_PLL_DIV_CLK;
              unsigned long PLL_OUT_CLK       = EXT_PLL_OUT_CLK;
              unsigned char FLSCL_FLRT        = EXT_FLSCL_FLRT;
              unsigned char PLLFLT_ICO        = EXT_PLLFLT_ICO;
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 3   

              unsigned char PLLFLT_LOOP       = EXT_PLLFLT_LOOP;
              #endif
 119          
 120          //-----------------------------------------------------------------------------
 121          // Global variables for main loop
 122          //-----------------------------------------------------------------------------
 123          unsigned char   g_uc_obdh_firmware_version[OBDH_FIRMWARE_VERSION_LENGTH] = "LUX-P Version 1.1 ";
 124          unsigned char   g_uc_call_task_buffer[CALL_TASK_BUFFER_SIZE];
 125          unsigned short  g_us_error_code = EC_INIT;
 126          unsigned short  g_us_res_length = 0x0001; //This will be produced by task flags, default is 1
 127          unsigned short  g_us_checksum_register = 0x0000;
 128          unsigned short  g_us_function_module_error_code;
 129          unsigned short  g_us_data_counter = 0;  //This variable act as global data counter
 130          
 131          #if (CQUEUE_ENABLE == 1)
              //-----------------------------------------------------------------------------
              // Command queue variables
              //-----------------------------------------------------------------------------
              unsigned char   g_uc_command_queue[COMMAND_QUEUE_SIZE][COMMAND_LENGTH];
              unsigned char   g_uc_command_queue_size = 0;    //At first, there is nothing in the queue
              unsigned char   g_uc_command_queue_pointer = 0; //At first, the pointer points the first command in queue
              unsigned char   g_uc_command_entry[COMMAND_LENGTH] = 0; //At first, nothing is here
              #endif
 140          
 141          //-----------------------------------------------------------------------------
 142          // CRC variables
 143          //-----------------------------------------------------------------------------
 144          unsigned short g_us_crc16_table[CRC_TABLE_SIZE];
 145          
 146          //-----------------------------------------------------------------------------
 147          // A2D conversion software flags, counters, and variables
 148          //-----------------------------------------------------------------------------
 149          unsigned char   g_uc_ad0int_counter = 0x00;
 150          
 151          //-----------------------------------------------------------------------------
 152          // Global variables for ISR
 153          //-----------------------------------------------------------------------------
 154          unsigned char g_uc_i2c_data_out[I2C_BUFFER_SIZE];       //To write data out on SMBus
 155          unsigned char g_uc_i2c_data_in[I2C_BUFFER_SIZE];        //To read data in from SMBus
 156          unsigned char g_uc_i2c_transferred_byte_out = 1;        //Initiates g_uc_i2c_transferred_byte_out variable
 157          unsigned char g_uc_i2c_transferred_byte_in = 1;         //Initiates transferred_Byte_in variable
 158          unsigned char g_uc_i2c_target;                                          //To specify g_uc_i2c_target slave's address
 159          unsigned char g_uc_uart_buffer[UART_BUFFER_SIZE];       //Provides UART interface buffer
 160          unsigned short g_us_i2c_isr_error_code = EC_INIT;
 161          unsigned char g_uc_i2c_msg_out = EMPTY_MSG;                     //Initiates type of inter-subsystem's message
 162          unsigned short g_us_uart_buffer_filled = 0;
 163          unsigned short g_us_uart_input_first = 0;
 164          unsigned short g_us_uart_output_first = 0;
 165          
 166          //-----------------------------------------------------------------------------
 167          // Global variables for ISIS
 168          //-----------------------------------------------------------------------------
 169          //Some global variables are noticed to be unnecessary, as they cannot be
 170          //extracted by PC debugging software and they only be used in one-two functions.
 171          //Some variables are earlier assigned as global in the testing phase.
 172          //More favorable approach, though not a must, would be to put them as 
 173          //static local variable in the respective functions to avoid misrepresentation.
 174          unsigned char g_uc_cw_message[CW_BUFFER_SIZE]                   = "VELOXP\0\0\0\0\0\0\0\0\0\0\0\0\0";
 175          unsigned char g_uc_cw_message_length                                    = CW_BEACON_LENGTH_M3;
 176          unsigned char g_uc_beacon_interval                                              = CW_BEACON_INTERVAL_M3;
 177          unsigned char g_uc_from_to_callsign[AX25_CALLSIGN_SIZE] = "VELOXP\09V1SGS\0";
 178          unsigned char g_uc_ax25_message[AX25_BUFFER_SIZE]               = "This is AX.25 default message";
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 4   

 179          unsigned char g_uc_itc_snd_ax_fr_dflt_wr                                = 0;
 180          unsigned char g_uc_itc_snd_ax_fr_ovrd_wr                                = 0;
 181          unsigned char g_uc_itc_snd_cw_msg_wr                                    = 0;
 182          unsigned char g_uc_itc_set_ax_bcn_dflt_wr                               = 0;
 183          unsigned char g_uc_itc_set_ax_bcn_ovrd_wr                               = 0;
 184          unsigned char g_uc_itc_set_cw_bcn_wr                                    = 0;
 185          
 186          //-----------------------------------------------------------------------------
 187          // Global variable for timeout counters
 188          //-----------------------------------------------------------------------------
 189          //Some global variables are noticed to be unnecessary, as they cannot be
 190          //extracted by PC debugging software and they only be used in one-two functions.
 191          //Some variables are earlier assigned as global in the testing phase.
 192          //More favorable approach, though not a must, would be to put them as 
 193          //static local variable in the respective functions to avoid misrepresentation.
 194          unsigned char g_uc_uart_busy_timeout_counter                                            = 0;
 195          unsigned char g_uc_i2c_transmission_timeout_counter                             = 0;
 196          unsigned char g_uc_i2c_busy_timeout_counter                                                     = 0;
 197          unsigned char g_uc_i2c_receiving_timeout_counter                                        = 0;
 198          unsigned char g_uc_i2c_bus_sda_held_low_recovery_timeout_counter        = 0;
 199          unsigned char g_uc_i2c_bus_scl_held_high_recovery_timeout_counter       = 0;
 200          unsigned char g_uc_spi_busy_timeout_counter                                                     = 0;
 201          unsigned char g_uc_spi_transmission_timeout_counter                                     = 0;
 202          unsigned char g_uc_timer0_stuck_counter                                                         = 0;
 203          
 204          //-----------------------------------------------------------------------------
 205          // Global variables for SD Card
 206          //-----------------------------------------------------------------------------
 207          // The variables which earlier declared to write/read multiple blocks from SD
 208          // card are removed, for in the latest software, the SD card is write/read
 209          // block by block, not in multiple blocks.
 210          unsigned char   g_uc_sd_data_buffer[SD_CARD_BUFFER_SIZE];
 211          
 212          //-----------------------------------------------------------------------------
 213          // Global variables for SD Card header
 214          //-----------------------------------------------------------------------------
 215          // When SaveDataProtected is called, the g_uc_sd_header_subsystem and 
 216          // g_uc_sd_header_data_type variables are "initialized" - or rather "captured"
 217          // There is no need to intialize the g_uc_sd_header_subsystem and
 218          // g_uc_sd_header_data_type here considering the whole program. 
 219          // Yet, for "safety standard reason" these two would be initialized as 
 220          // "OBDH_SUBSYSTEM" and "SD_NULL"
 221          unsigned char   g_uc_sd_header_subsystem = OBDH_SUBSYSTEM;
 222          unsigned char   g_uc_sd_header_data_type = SD_NULL;
 223          unsigned short  g_us_sd_header_block_property;
 224          unsigned short  g_us_sd_header_no_of_this_block;
 225          unsigned long   g_ul_sd_header_sd_write_block;
 226          unsigned short  g_us_sd_header_this_block_data_size;
 227          
 228          //-----------------------------------------------------------------------------
 229          // Global variables for AX.25 frame package buffer
 230          //-----------------------------------------------------------------------------
 231          unsigned char   g_uc_ax25_header_subsystem;
 232          unsigned char   g_uc_ax25_header_data_type;
 233          unsigned char   g_uc_ax25_header_package_property;
 234          unsigned char   g_uc_ax25_header_no_of_this_package;
 235          unsigned char   g_uc_ax25_header_this_package_size = AX25_HEADER_SIZE;
 236          
 237          //-----------------------------------------------------------------------------
 238          // Orbital-based search (OBS) variables
 239          // Some unused global variables have been removed
 240          // First and last orbit request are noticed to be redundant for VELOX-P use as 
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 5   

 241          // there could be only one orbit requested at one time.
 242          //-----------------------------------------------------------------------------
 243          unsigned long   g_ul_obs_initial_bp; //Initial BP of the requested orbit
 244          unsigned long   g_ul_obs_end_bp; //End BP of the requested orbit
 245          unsigned short  g_us_obs_first_orbit_request; //Global variable for ground station request
 246          unsigned short  g_us_obs_last_orbit_request; //Global variable for ground station request
 247          
 248          //-----------------------------------------------------------------------------
 249          // Global variables for data storing
 250          // for *g_ul_initial_sd_card_bp_address, g_uc_no_of_copies, and  
 251          // *g_uc_no_of_overwritten_p, read the functions in luxp[version]_storing.c
 252          // initSDData() and saveDataEndHandler() for understanding their data type assignment.
 253          // Just like g_uc_sd_header_subsystem and g_uc_sd_header_data_type, they are not
 254          // necessarily initialized here.
 255          //-----------------------------------------------------------------------------
 256          unsigned char   g_uc_no_of_data_saved;
 257          unsigned char   g_uc_data_type_saved_buffer[MAX_NO_OF_DATA_TYPE_TO_BE_SAVED];
 258          unsigned long   g_ul_initial_sd_card_bp;
 259          unsigned long   *g_ul_initial_sd_card_bp_address;
 260          unsigned char   g_uc_no_of_copies;
 261          unsigned char   *g_uc_no_of_overwritten_p;
 262          unsigned char   g_uc_data_sets_property;
 263          unsigned long   g_ul_memory_address_lower_limit;
 264          unsigned long   g_ul_memory_address_upper_limit;
 265          unsigned long   g_ul_memory_address_end;
 266          unsigned long   g_ul_start_sd_card_load_bp;                
 267          unsigned long   g_ul_end_sd_card_load_bp; //for load SDCARD to tell end of block
 268          unsigned char   g_uc_sd_load_data_timeout_counter = TIME_LIMIT_LOAD_DATA_S;  
 269          unsigned short  g_us_sd_load_error_code;
 270          unsigned char   g_uc_save_data_hold_timeout_counter;
 271          
 272          //-----------------------------------------------------------------------------
 273          // Global variables for data sending
 274          //-----------------------------------------------------------------------------
 275          unsigned char   g_uc_no_of_data_sent;
 276          unsigned char   g_uc_data_type_sent_buffer[MAX_NO_OF_DATA_TYPE_TO_BE_SENT];
 277          unsigned short  g_us_sd_card_meaningful_data_size = 0;
 278          unsigned char   g_uc_current_data_sent_counter = 0;
 279          unsigned short  g_us_beacon_send_error_code = EC_SUCCESSFUL;
 280          unsigned char   g_uc_schedule_sent_counter = 0;
 281          unsigned short  g_us_expected_no_of_itn_checking_per_transmission = 0;
 282          
 283          //-----------------------------------------------------------------------------
 284          // Shared global variables for data storing and sending
 285          //-----------------------------------------------------------------------------
 286          unsigned char   g_uc_temporary_data_buffer[MAX_SD_CARD_BLOCK_CONTENT_SIZE];
 287          
 288          //------------------------------------------------------------------------------------
 289          // Global variables for time functions
 290          //------------------------------------------------------------------------------------
 291          unsigned char   g_uc_timer_value_low[RECORD_BLOCK_SIZE]                         = 0;
 292          unsigned char   g_uc_timer_value_high[RECORD_BLOCK_SIZE]                        = 0;
 293          unsigned short  g_us_timer_flag_counter_value[RECORD_BLOCK_SIZE]        = 0;
 294          unsigned short  g_us_timer_flag_counter                                                         = 0;
 295          unsigned short  g_us_timer_value[RECORD_BLOCK_SIZE]                             = 0;
 296          
 297          //------------------------------------------------------------------------------------
 298          // Global variables for scriptline
 299          //------------------------------------------------------------------------------------
 300          unsigned short  g_us_scriptline_timer_error_code = EC_SUCCESSFUL;
 301          unsigned short  g_us_scriptline_retry_counter_error_code = EC_SUCCESSFUL;
 302          
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 6   

 303          //------------------------------------------------------------------------------------
 304          // Global variables for ground station command handler
 305          //------------------------------------------------------------------------------------
 306          unsigned short  g_us_groundpass_time_register = 0;
 307          
 308          //------------------------------------------------------------------------------------
 309          // Global variables for essential error codes
 310          // Some unused global variables are removed
 311          //------------------------------------------------------------------------------------
 312          unsigned short  g_us_latest_obdh_hk_ec = EC_SUCCESSFUL; //always successful, need to be changed for future 
             -use if the condition is no longer true. This condition is true for VELOX-P software, but not necessary for other softwar
             -e.
 313          unsigned short  g_us_latest_adcs_hk_ec = EC_INIT;
 314          unsigned short  g_us_latest_pwrs_hk_ec = EC_INIT;
 315          unsigned short  g_us_latest_comm_hk_ec = EC_INIT;
 316          unsigned short  g_us_latest_rtc_time_update_ec = EC_INIT; //Noticed to be unnecessary to be global variable
             - anymore, as it cannot be read by PC. Static local variable is noticed to be more favorable
 317          unsigned short  g_us_latest_ch_stat_update_ec = EC_INIT;
 318          unsigned short  g_us_latest_saving_hk_ec = EC_INIT; //Noticed to be unnecessary to be global variable anymo
             -re, as it cannot be read by PC. Static local variable is noticed to be more favorable
 319          unsigned short  g_us_latest_gdsn_to_rtc_update_ec = EC_INIT;
 320          unsigned short  g_us_latest_obdh_sscp_ec = EC_SUCCESSFUL;       //always successful, need to be changed for futur
             -e use if the condition is no longer true. This condition is true for VELOX-P software, but not necessary for other softw
             -are.
 321          unsigned short  g_us_latest_adcs_sscp_ec = EC_INIT;
 322          unsigned short  g_us_latest_pwrs_sscp_ec = EC_INIT;
 323          
 324          //------------------------------------------------------------------------------------
 325          // Global multi-purpose registers
 326          //------------------------------------------------------------------------------------
 327          unsigned char   g_uc;
 328          unsigned short  g_us;
 329          short                   g_s;
 330          //Ian (2012-05-15): It is confirmed that g_ul is not used in the interrupts and immediately
 331          //                                      used to do any calculation before another function is called to prevent
 332          //                                      change of value in g_ul.
 333          unsigned long   g_ul;
 334          float                   g_f;
 335          
 336          //------------------------------------------------------------------------------------
 337          // Global variables for beacon handler
 338          //------------------------------------------------------------------------------------
 339          //      Beacon flag reading:
 340          //      1) Bit0 -> Init/uninit (1/0)
 341          //      2) Bit1 -> Beacon enable/disable (1/0)
 342          //      3) Bit2 -> Check/not check (1/0)
 343          //      4) Bit3 -> Timeout/not timeout (1/0)
 344          //      5) Bit4 -> Monitor/not monitor (1/0)
 345          //      6) Bit5 -> CW/AX.25 (1/0)
 346          //      7) Bit7-6 -> CW sending mode (00 - Default, 01 - Alternate 1, 10 - Alternate 2, 11 - Alternate 3)
 347          //      8) Bit8 -> Beacon error/not error (1/0)
 348          //      9) Bit9 -> GSCH claim/GSCH release (1/0)
 349          //      10) Bit10 -> GSCH send request/no request (1/0)
 350          //      12) Bit11 -> GSCH request ack/nack (1/0)
 351          //      13) Bit12 -> GSCH send request completed/incompleted (1/0)
 352          //      14) Bit13 -> GSCH send request type CW/AX.25 (1/0)
 353          //      15) Bit14 -> Beacon in recovery/normal phase (1/0)
 354          //      16) Bit15 -> Auto-beacon disabled/enabled (1/0)
 355          //------------------------------------------------------------------------------------
 356          unsigned char   g_uc_beacon_time_since_last_timeout_sending = 0;
 357          unsigned char   g_uc_beacon_timeout_value;
 358          unsigned char   g_uc_beacon_retry_counter = 0;
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 7   

 359          unsigned char   g_uc_beacon_timeout_retry_counter = 0;
 360          unsigned short  g_us_beacon_init_ax25_error_code;
 361          unsigned short  g_us_beacon_monitoring_time = 0;
 362          unsigned char   g_uc_beacon_error_counter = 0;
 363          
 364          //------------------------------------------------------------------------------------
 365          // Global variables for GSCH
 366          //------------------------------------------------------------------------------------
 367          //Variables for GSCH error codes
 368          unsigned short g_us_gsch_error_code = EC_INIT;
 369          
 370          //Variables for further GSCH monitoring
 371          unsigned short g_us_gsch_command_validation_error_code = EC_INVALID_GDSN_COMMAND; //Assume command to be i
             -nvalid first
 372          
 373          //Retry counter in each state
 374          unsigned char g_uc_gsch_comm_retry_counter = 0;
 375          unsigned char g_uc_gsch_loading_retry_counter = 0;
 376          
 377          //Counter for monitoring GSCH transitional period
 378          unsigned short g_us_gsch_monitoring_transitional_period = 0;
 379          
 380          //Monitoring time for DEAD state and RECOVERY state
 381          unsigned short g_us_gsch_monitoring_period = 0;
 382          
 383          //Variables to store generated key and answers
 384          unsigned short g_us_gsch_key = 0;
 385          unsigned short g_us_gsch_answer_1 = 0;
 386          unsigned short g_us_gsch_answer_2 = 0;
 387          
 388          //Variables for GSCH command frame
 389          unsigned char g_uc_gsch_gs_header;
 390          unsigned char g_uc_gsch_gs_cmd_header;
 391          unsigned char g_uc_gsch_gs_cmd_tail;
 392          unsigned char g_uc_gsch_gs_arg_len;
 393          unsigned char g_uc_gsch_gs_arg[MAX_GSCH_CMD_ARG_LEN];
 394          unsigned short g_us_gsch_gs_cmd_crc;
 395          
 396          //Variables to store subsystem and data type to load as commanded by GDSN
 397          unsigned char g_uc_gsch_subsystem_to_load;
 398          unsigned char g_uc_gsch_data_type_to_load;
 399          unsigned char g_uc_gsch_sd_block_property;
 400          unsigned char g_uc_gsch_no_of_loading = 0; //Always initialize this as zero
 401          unsigned char g_uc_gsch_sampling_step = 1;      
 402          
 403          //Register for scheduled command given
 404          unsigned char g_uc_gsch_sch_register[MAX_SCHEDULER_ARG+SCHEDULER_NON_ARG_SIZE+2];
 405          unsigned short g_us_gsch_total_sending_time = 0;
 406          
 407          //Register for GSCH watchdog timer
 408          unsigned long g_ul_gsch_time_elapsed_since_last_communication_with_mcc = 0;
 409          
 410          //-----------------------------------------------------------------------------
 411          // Datalog
 412          //-----------------------------------------------------------------------------
 413          unsigned char g_uc_log_data_buffer[LOG_DATA_BUFFER_SIZE] = 0;
 414          unsigned char g_uc_log_data_set[LOG_DATA_SET_SIZE] = 0;
 415          unsigned short g_us_log_data_elapsed_time_s = 0;
 416          unsigned short g_us_log_data_buffer_index = 0;
 417          unsigned short g_us_log_data_block_size = 0;
 418          
 419          //-----------------------------------------------------------------------------
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 8   

 420          // Eventlog //dec22_yc
 421          //-----------------------------------------------------------------------------
 422          unsigned char g_uc_eventlog_data_buffer[EVENTLOG_DATA_BUFFER_SIZE] = 0;
 423          unsigned short g_us_no_of_eventlog_this_orbit = 0;
 424          unsigned char g_uc_eventlog_status_flag = 0;//missing logs... full logs, time to save log to SD
 425          
 426          //-----------------------------------------------------------------------------
 427          // Idle / Mission time variables
 428          //-----------------------------------------------------------------------------
 429          unsigned short g_us_mission_time_register = 0;
 430          unsigned long g_ul_idle_time_register = 0;
 431          
 432          //-----------------------------------------------------------------------------
 433          // Body rate control variables
 434          //-----------------------------------------------------------------------------
 435          unsigned char g_uc_desired_adcs_mode = ADCS_MODE_DETUMBLE;
 436          unsigned char g_uc_brh_retry_counter = 0;
 437          unsigned char g_uc_brh_timeout_retry_counter = 0;
 438          unsigned char g_uc_brh_wait_det_time_s = 0;
 439          unsigned long g_ul_ads_uptime_s = 0;
 440          unsigned long g_ul_det_uptime_s = 0;
 441          short g_s_br_eci[3][BR_ECI_SAMPLE_NO];
 442          
 443          //-----------------------------------------------------------------------------
 444          // Idle mode variables
 445          //-----------------------------------------------------------------------------
 446          unsigned char g_uc_imh_retry_counter = 0;
 447          unsigned char g_uc_imh_acs_timeout_retry_counter = 0;
 448          unsigned char g_uc_imh_ads_timeout_retry_counter = 0;
 449          unsigned char g_uc_imh_wait_acs_time_s = 0;
 450          unsigned char g_uc_imh_wait_ads_time_s = 0;
 451          
 452          //-----------------------------------------------------------------------------
 453          // Safe mode variables
 454          //-----------------------------------------------------------------------------
 455          unsigned long g_ul_smh_time_register = 0;
 456          unsigned long g_ul_smh_saved_time = 0;
 457          unsigned char g_uc_soc_reading_when_entering_safe_mode = THRESHOLD_SOC_M3_TO_M4_DEFAULT;
 458          unsigned char g_uc_soc_after_one_orbit_in_safe_mode = THRESHOLD_SOC_M3_TO_M4_DEFAULT;
 459          
 460          //-----------------------------------------------------------------------------
 461          // Flags collection
 462          //-----------------------------------------------------------------------------
 463          //Though might be modified in more than one interrupt function as well as the normal
 464          //code, the i2c flag set/reset is carefully assigned. Based on testing, no unpredictable
 465          //outcome is observed.
 466          unsigned short g_us_i2c_flag            = 0x0000;       //I2C flags
 467          unsigned char g_uc_spit0ad0_flag        = 0x00;         //SPI, Timer0, ADC0 flags
 468          unsigned char g_uc_combn_flag           = 0x00;         //Command, user input, software timer, UART flags
 469          unsigned char g_uc_strsnd_flag          = 0x00;         //Storing and sending flags
 470          unsigned char g_uc_gsch_flag            = 0x00;         //GSCH flags
 471          unsigned char g_uc_evha_flag            = 0x00;         //Event and hold activation flags
 472          
 473          //-----------------------------------------------------------------------------
 474          // Update handler's timers
 475          //-----------------------------------------------------------------------------
 476          unsigned char g_uc_adcs_time_lapse_from_last_update_s = 0;
 477          unsigned char g_uc_pwrs_time_lapse_from_last_update_s = 0;
 478          unsigned char g_uc_rtc_time_lapse_from_last_update_s = 0;
 479          unsigned char g_uc_pwrs_time_lapse_from_last_ch_stat_update_s = 0;
 480          unsigned char g_uc_comm_time_lapse_from_last_update_s = 50;
 481          unsigned char g_uc_antenna_status_check_from_last_update_s = 0;
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 9   

 482          unsigned short g_us_obdh_time_lapse_from_last_save_state_s = 0;
 483          
 484          //-----------------------------------------------------------------------------
 485          // Thermal knife task's variables
 486          //-----------------------------------------------------------------------------
 487          unsigned char g_uc_tk_waiting_s = 0;
 488          unsigned char g_uc_tk_uptime_s = 0;
 489          
 490          //-----------------------------------------------------------------------------
 491          // Antenna deployment task's variables
 492          //-----------------------------------------------------------------------------
 493          unsigned char g_uc_deployment_channel_waiting_s = 0;
 494          unsigned char g_uc_antenna_deployment_waiting_s = 0;
 495          unsigned char g_uc_antenna_addr = ANTENNA_1_ADDR;
 496          
 497          //-----------------------------------------------------------------------------
 498          // Special block pointers
 499          //-----------------------------------------------------------------------------
 500          unsigned long g_ul_essential_bp = SD_BP_OBDH_ESS_START;                 //This is a very special block pointer, used to 
             -get satellite initialization data in the SD card, it is never been changed unless in a very special circumstance (Genesi
             -s)
 501          unsigned long g_ul_schedule_bp = SD_BP_OBDH_SCHEDULE_START;     //This is a very special block pointer, used 
             -to get satellite initialization data in the SD card, it is never been changed unless in a very special circumstance (Gen
             -esis)
 502          unsigned long g_ul_script_bp = SD_BP_OBDH_SCRIPT_START;                 //This is a very special block pointer, used to 
             -get satellite initialization data in the SD card, it is never been changed unless in a very special circumstance (Genesi
             -s)
 503          
 504          //-----------------------------------------------------------------------------
 505          // MAIN Routine
 506          //-----------------------------------------------------------------------------
 507          void main (void)
 508          {
 509   1              //All local variables
 510   1              //Ian (2012-05-15): l_uc_counter is removed.
 511   1              unsigned char *l_uc_call_task_pointer;
 512   1              unsigned char *l_uc_response_task_pointer;
 513   1              unsigned short l_us_msg_length = 0x0000;
 514   1              unsigned short l_us_counter = 0x0000;
 515   1              unsigned short l_us_error_code = EC_INIT;
 516   1              char SFRPAGE_SAVE = SFRPAGE;
 517   1      
 518   1              //In the beginning, it is necessary to initialize all hardware settings.
 519   1              //Hardware and variable initialization
 520   1              initSystem();
 521   1      
 522   1              initSD(); //Init SD card before starting the system
 523   1              waitS(2); //Give delay after initializing SD card
 524   1      
 525   1              #if (STORING_ENABLE == 1)
 526   1              //Load the latest state
 527   1              loadState();
 528   1      
 529   1              //Increases reset count
 530   1              str_obdh_hk.uc_mcu_rst_count++;
 531   1      
 532   1              //Store initialization events
 533   1              #if (EVENT_HANDLER_ENABLE == 1)
 534   1              eventHandler(EV_INIT_COMPLETED,str_obdh_hk.uc_sat_rstsrc,g_uc_evha_flag,0,0,0,0); //dec28_yc
 535   1              #endif
 536   1      
 537   1              //Save the initial state
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 10  

 538   1              saveState();
 539   1      
 540   1              //Initialize orbital search for orbit zero content
 541   1              if (str_obdh_data.us_current_rev_no == 0)
 542   1                      l_us_error_code = saveDataProtected(OBDH_SUBSYSTEM,SD_BP,g_uc_sd_data_buffer);
 543   1              #endif
 544   1      
 545   1              //Clear buffers
 546   1              clearUARTBuffer();
 547   1              clearCallTaskBuffer();
 548   1      
 549   1              //Initialize call task and response task pointer as internal call task buffer
 550   1              l_uc_call_task_pointer = g_uc_call_task_buffer;
 551   1              l_uc_response_task_pointer = g_uc_call_task_buffer;
 552   1      
 553   1              #if (TASK_ENABLE == 1)
 554   1              //Starts housekeeping task
 555   1              setTaskFlags(TASK_GET_HK,TASK_CMD_RESTART,READ_TASK_NO_READING);
 556   1              #endif
 557   1      
 558   1              //Enable Watchdog timer
 559   1              #if (WDT_ENABLE == 1)
 560   1      
 561   1              SFRPAGE_SAVE = SFRPAGE;
 562   1              SFRPAGE = CONFIG_PAGE; 
 563   1              WDTCN = 0x07;           //setting WDT interval bit7=0 bits[2:0] set to 111      
 564   1              WDTCN = 0xA5;           //Enable/Reset WDT
 565   1              SFRPAGE = SFRPAGE_SAVE;
 566   1      
 567   1              #endif
 568   1      
 569   1              //Infinite loop
 570   1              while (1) 
 571   1              {
 572   2                      #if (DEBUGGING_FEATURE == 1)
 573   2                      //See if SCM is held
 574   2                      if (!(g_uc_evha_flag & HACVTN_FLAG_SCM))
 575   2                              //Satellite control module is run when it is not held
 576   2                              satelliteControlModule();
 577   2      
 578   2                      //Reset response bit
 579   2                      g_uc_combn_flag &= ~CMD_FLAG_RESPONSE;
 580   2      
 581   2                      //If SOFTWARE_LOOPHOLD_MODE is activated, then hold the software here until there is valid input to be p
             -rocessed
 582   2                      //Ian (2012-05-15): software mode choice is disabled,
 583   2                      //if (str_obdh_data.uc_software_mode == SOFTWARE_LOOPHOLD_MODE)
 584   2                      //      while(!(g_uc_combn_flag & USIP_FLAG_READY));
 585   2      
 586   2                      //If there is an input from UART buffer which is ready to be processed, switch the current
 587   2                      //call and response buffer to UART buffers
 588   2                      if (g_uc_combn_flag & USIP_FLAG_READY){
 589   3                              l_uc_call_task_pointer = g_uc_uart_buffer;
 590   3                              l_uc_response_task_pointer = g_uc_uart_buffer;
 591   3      
 592   3                              //Reset invalid command bit
 593   3                              g_uc_combn_flag &= ~CMD_FLAG_INVALID;
 594   3              
 595   3                              //Clear user input bits
 596   3                              g_uc_combn_flag &= ~UART_FLAG_RX_BUSY_TIMEOUT;
 597   3                              g_uc_combn_flag &= ~USIP_FLAG_START;
 598   3      
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 11  

 599   3                              //Check command input here      
 600   3                              //Check first byte of the input buffer
 601   3                              if(*l_uc_call_task_pointer != 0xCC && *l_uc_call_task_pointer != 0xBB) //If neither Debugging Module no
             -r Satellite Control Module gives any task, consider invalid
 602   3                                      g_uc_combn_flag |= CMD_FLAG_INVALID; //This is to prevent any interrupt occurs from this point onwards
             - to run any function
 603   3                              else {  //If it is a valid header
 604   4                                      //claims the command by putting response byte header equal to the caller header byte
 605   4                                      *l_uc_response_task_pointer = *l_uc_call_task_pointer;
 606   4                              }
 607   3              
 608   3                              //If the command is valid so far, check for length validity
 609   3                              if (!(g_uc_combn_flag & CMD_FLAG_INVALID)){
 610   4                                      //Check message length validity
 611   4                                      l_us_msg_length = ((unsigned short)(*(l_uc_call_task_pointer+3) << 8) + *(l_uc_call_task_pointer+4)) +
             - 5;
 612   4                                      //Ian (2012-05-15): the value 598 is changed to (UART_BUFFER_SIZE-2) 
 613   4                                      if (l_us_msg_length > (UART_BUFFER_SIZE-2)) g_uc_combn_flag |= CMD_FLAG_INVALID;                
 614   4                              }
 615   3              
 616   3                              //If the command is valid, proceeds to Command Control Module, if not, continue to task module
 617   3                              if(!(g_uc_combn_flag & CMD_FLAG_INVALID)) commandControlModule(l_uc_call_task_pointer,l_uc_response_tas
             -k_pointer);
 618   3      
 619   3                              //If it is asked for response and the caller is not Satellite Control Module
 620   3                              //return response to the caller + CRC bytes, if not skip it
 621   3                              if (g_uc_combn_flag & CMD_FLAG_RESPONSE){
 622   4                                      #if (CRC_ENABLE == 1)
 623   4                                      //Insert CRC16 bytes
 624   4                                      insertCRC16(l_uc_response_task_pointer,g_us_res_length);
 625   4                                      #endif
 626   4                      
 627   4                                      //If the header shows that the caller is Debugging Module, sends the output buffer to Debugging Module
             - through defined UART line
 628   4                                      //Else, keep it in the buffer to be processed by Satellite Control Module
 629   4                                      #if (UART_LINE == 1)
 630   4                                              sendToUART1(l_uc_response_task_pointer,0,g_us_res_length+2);
 631   4                                      #elif (UART_LINE == 0)
                                                      sendToUART0(l_uc_response_task_pointer,0,g_us_res_length+2);
                                              #else
                                              #endif
 635   4                              }       
 636   3      
 637   3                              //Clear UART input buffer header
 638   3                              g_uc_uart_buffer[0]                     = 0x00;
 639   3      
 640   3                              //Clear UART buffer indicators
 641   3                              g_us_uart_buffer_filled                 = 0;
 642   3                              g_us_uart_input_first                   = 0;
 643   3                              g_uc_combn_flag                                 &= ~USIP_FLAG_READY;
 644   3                      }
 645   2                      else{ //Else, the call and response buffers are taken from internal call task buffer
 646   3                              l_uc_call_task_pointer = g_uc_call_task_buffer;
 647   3                              l_uc_response_task_pointer = g_uc_call_task_buffer;
 648   3      
 649   3                              #if (CQUEUE_ENABLE == 1)
                                      //So long as there is command in the queue, execute it
                                      //If a command is invalid, however, it will still be put
                                      //in the buffer but will not be executed
                                      while (g_uc_command_queue_size){
                                              //Reset invalid command bit
                                              g_uc_combn_flag &= ~CMD_FLAG_INVALID;
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 12  

                              
                                              //To handle commands generated by SCM
                                              commandQueueHandler();
                              
                                              //Check command input here      
                                              //Check first byte of the input buffer
                                              if(*l_uc_call_task_pointer != 0xCC && *l_uc_call_task_pointer != 0xBB) //If neither Debugging Module n
             -or Satellite Control Module gives any task, consider invalid
                                                      g_uc_combn_flag |= CMD_FLAG_INVALID; //This is to prevent any interrupt occurs from this point onward
             -s to run any function
                                              else {  //If it is a valid header
                                                      //claims the command by putting response byte header equal to the caller header byte
                                                      *l_uc_response_task_pointer = *l_uc_call_task_pointer;
                                              }
                              
                                              //If the command is valid so far, check for length validity
                                              if (!(g_uc_combn_flag & CMD_FLAG_INVALID)){
                                                      //Check message length validity
                                                      l_us_msg_length = ((unsigned short)(*(l_uc_call_task_pointer+3) << 8) + *(l_uc_call_task_pointer+4)) 
             -+ 5;
                                                      //Ian (2012-05-15): the value 598 is changed to (UART_BUFFER_SIZE-2) 
                                                      if (l_us_msg_length > (UART_BUFFER_SIZE-2)) g_uc_combn_flag |= CMD_FLAG_INVALID;                
                                              }
                              
                                              //If the command is valid, proceeds to Command Control Module, if not, continue to task module
                                              if(!(g_uc_combn_flag & CMD_FLAG_INVALID)) commandControlModule(l_uc_call_task_pointer,l_uc_response_ta
             -sk_pointer);
              
                                              //Clear call task buffer header
                                              g_uc_call_task_buffer[0] = 0x00;
                                      }
                                      #else
 684   3                              #if (SATELLITE_SCHEDULE_HANDLER_ENABLE == 1)
 685   3                              //Execute all scheduled commands
 686   3                              satelliteScheduleHandler();
 687   3                              #endif
 688   3                              #endif
 689   3                      }
 690   2      
 691   2                      #elif (DEBUGGING_FEATURE == 0)
              
                              //Satellite control module is always running
                              satelliteControlModule();
              
                              //Reset response bit
                              g_uc_combn_flag &= ~CMD_FLAG_RESPONSE;
              
                              #if (CQUEUE_ENABLE == 1)
                              //So long as there is command in the queue, execute it
                              //If a command is invalid, however, it will still be put
                              //in the buffer but will not be executed
                              while (g_uc_command_queue_size){
                                      //Reset invalid command bit
                                      g_uc_combn_flag &= ~CMD_FLAG_INVALID;
                      
                                      //To handle commands generated by SCM
                                      commandQueueHandler();
                      
                                      //Check command input here      
                                      //Check first byte of the input buffer
                                      if(*l_uc_call_task_pointer != 0xCC && *l_uc_call_task_pointer != 0xBB) //If neither Debugging Module no
             -r Satellite Control Module gives any task, consider invalid
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 13  

                                              g_uc_combn_flag |= CMD_FLAG_INVALID; //This is to prevent any interrupt occurs from this point onwards
             - to run any function
                                      else {  //If it is a valid header
                                              //claims the command by putting response byte header equal to the caller header byte
                                              *l_uc_response_task_pointer = *l_uc_call_task_pointer;
                                      }
                      
                                      //If the command is valid so far, check for length validity
                                      if (!(g_uc_combn_flag & CMD_FLAG_INVALID)){
                                              //Check message length validity
                                              l_us_msg_length = ((unsigned short)(*(l_uc_call_task_pointer+3) << 8) + *(l_uc_call_task_pointer+4)) +
             - 5;
                                              //Ian (2012-05-15): the value 598 is changed to (UART_BUFFER_SIZE-2) 
                                              if (l_us_msg_length > (UART_BUFFER_SIZE-2)) g_uc_combn_flag |= CMD_FLAG_INVALID;                        
                                      }
                      
                                      //If the command is valid, proceeds to Command Control Module, if not, continue to task module
                                      if(!(g_uc_combn_flag & CMD_FLAG_INVALID)) commandControlModule(l_uc_call_task_pointer,l_uc_response_tas
             -k_pointer);
              
                                      //Clear call task buffer header
                                      g_uc_call_task_buffer[0] = 0x00;
                              }
                              #else
                              #if (SATELLITE_SCHEDULE_HANDLER_ENABLE == 1)
                              //Execute all scheduled commands
                              satelliteScheduleHandler();
                              #endif
                              #endif
              
                              #else
                              #endif
 742   2                      
 743   2                      #if (TASK_ENABLE == 1)
 744   2                      //Only run the task module if reset is not being initiated
 745   2                      if (!(g_uc_evha_flag & EVENT_FLAG_RESET_SAT_INITIALIZED)){
 746   3                              #if (DEBUGGING_FEATURE == 1)
 747   3                              //Run task's module according to the maximum number of task.
 748   3                              //Task module will check whether certain task is under valid condition to run or not
 749   3                              for (l_us_counter = 0; l_us_counter < TASK_SIZE; l_us_counter++){
 750   4                                      //If TM is NOT to be held and task status is NOT held, runs the TM
 751   4                                      if (!(g_uc_evha_flag & HACVTN_FLAG_TM) && !(g_uc_evha_flag & HACVTN_FLAG_TS))
 752   4                                              taskModule(l_us_counter,l_uc_response_task_pointer);
 753   4                                      //If TM is to be held but task status is NOT held, holds the task status
 754   4                                      else if ((g_uc_evha_flag & HACVTN_FLAG_TM) && !(g_uc_evha_flag & HACVTN_FLAG_TS)){
 755   5                                              str_task[l_us_counter].uc_status_held = str_task[l_us_counter].uc_status;
 756   5                                              scriptspaceStopAllTimer(l_us_counter);
 757   5                                              str_task[l_us_counter].uc_status &= ~TASK_RUNNING_FLAG;
 758   5                                              if (l_us_counter == TASK_SIZE-1) g_uc_evha_flag |= HACVTN_FLAG_TS; //In the last loop, update the hol
             -d task status
 759   5                                      }
 760   4                                      //If TM is NOT to be held but task status is held, release the task status, runs that task
 761   4                                      else if (!(g_uc_evha_flag & HACVTN_FLAG_TM) && (g_uc_evha_flag & HACVTN_FLAG_TS)){
 762   5                                              str_task[l_us_counter].uc_status = str_task[l_us_counter].uc_status_held;
 763   5                                              scriptspaceStartAllTimer(l_us_counter);
 764   5                                              //Ian (2012-05-15): the sequence of the next two lines are deemed to be correct. As soon as the flag
 765   5                                              //                                      is no more held, the tasks are run immediately.
 766   5                                              if (l_us_counter == TASK_SIZE-1) g_uc_evha_flag &= ~HACVTN_FLAG_TS; //In the last loop, update the ho
             -ld task status
 767   5                                              taskModule(l_us_counter,l_uc_response_task_pointer);
 768   5                                      }
 769   4                                      //If TM is to be held, so does the task status, then do nothing, just count.
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 14  

 770   4                              }
 771   3                              #else
                                      //Run task's module according to the maximum number of task.
                                      //Task module will check whether certain task is under valid condition to run or not
                                      for (l_us_counter = 0; l_us_counter < TASK_SIZE; l_us_counter++)
                                              taskModule(l_us_counter,l_uc_response_task_pointer);
                                      #endif
 777   3                      }
 778   2                      #endif
 779   2              }
 780   1      }
 781          
 782          //------------------------------------------------------------------------------------
 783          // Satellite Control Module (SCM)
 784          //------------------------------------------------------------------------------------
 785          //      Satellite control module has four main routines:
 786          //       1) To check satellite's power status
 787          //       2) To check satellite's time and schedule
 788          //       3) To check satellite's state
 789          //       4) To check ground station commands
 790          //
 791          //      Based on the combination of the checking results, the satellite would be executing
 792          //      certain commands.
 793          //
 794          //------------------------------------------------------------------------------------
 795          void satelliteControlModule (void)
 796          {
 797   1              //If reset satellite is initialized, do not do the following
 798   1              if (!(g_uc_evha_flag & EVENT_FLAG_RESET_SAT_INITIALIZED)){      
 799   2                      #if (SATELLITE_MODE_HANDLER_ENABLE == 1)
 800   2                      //To handle various satellite modes
 801   2                      satelliteModeHandler();
 802   2                      #endif
 803   2              
 804   2                      //Peripheral error handler for OBDH     (whenever any recovery attempt is possible)
 805   2                      peripheralErrorHandler();
 806   2              
 807   2                      //To handle all updates and changes in the satellite and in the OBDH states
 808   2                      systemUpdateAndMonitor();
 809   2              }
 810   1      
 811   1              #if (GROUND_STATION_COMMAND_HANDLER_ENABLE == 1)
 812   1              //To handle ground station command inputs
 813   1              groundStationCommandHandler();
 814   1              #endif
 815   1      
 816   1              #if (SENDING_ENABLE == 1)
 817   1              #if (ISIS_CMD_ENABLE == 1)
 818   1              #if (BEACON_HANDLER_ENABLE == 1)
 819   1              //To handle beacon modes (auto-beacon could be disabled forever, if wanted)     
 820   1              beaconHandler();
 821   1              #endif
 822   1              #endif
 823   1              #endif
 824   1      
 825   1              #if (CQUEUE_ENABLE == 1)
                      #if (SATELLITE_SCHEDULE_HANDLER_ENABLE == 1)
                      //To handle satellite schedule
                      satelliteScheduleHandler();
                      #endif
                      #endif
 831   1      }
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 15  

 832          
 833          //------------------------------------------------------------------------------------
 834          // Command Control Module (CCM)
 835          //------------------------------------------------------------------------------------
 836          // Task commands:
 837          //      Either Satellite Control Module (SCM) or other interface module may send task
 838          //      command the Command Control Module (CCM). There are several task commands which are 
 839          //      supported by this CCM. They are listed as follow:
 840          //       a) TASK_CMD_TERMINATE
 841          //       b) TASK_CMD_RUN
 842          //       c) TASK_CMD_STOP
 843          //       d) TASK_CMD_RESTART
 844          //       e) TASK_CMD_DO_NOTHING
 845          //
 846          //      Besides command, there is a task's argument which is used to determine what kind
 847          //      of reading will be used for certain task. The task's argument is as listed:
 848          //       a) READ_TASK_FORMAT_1
 849          //       b) READ_TASK_FORMAT_2
 850          //
 851          //------------------------------------------------------------------------------------
 852          void commandControlModule (unsigned char *l_uc_call_task_buffer_pointer, unsigned char *l_uc_response_task
             -_buffer_pointer)
 853          {
 854   1              unsigned char l_uc_header;
 855   1              
 856   1              #if (TASK_ENABLE == 1)
 857   1              //Ian (2012-05-15): The size of l_uc_task_chosen, l_uc_task_cmd, and l_uc_task_arg arrays are reduced to 
             -1.
 858   1              unsigned char l_uc_task_chosen;
 859   1              unsigned char l_uc_task_cmd;
 860   1              unsigned char l_uc_task_arg;
 861   1              unsigned char l_uc_no_of_task;
 862   1              #endif
 863   1      
 864   1              unsigned char *l_uc_arg_p;
 865   1              unsigned short l_us_command;
 866   1              unsigned short l_us_arg_length;
 867   1              unsigned short l_us_crc16_not_match = EC_SUCCESSFUL;
 868   1      
 869   1              //Initiates response length
 870   1              g_us_res_length = 1;    //If there is no task read, return one-byte header only
 871   1      
 872   1              l_uc_header     = *l_uc_call_task_buffer_pointer;
 873   1              l_us_command    = (unsigned short)(*(l_uc_call_task_buffer_pointer+1) << 8) + *(l_uc_call_task_buffer_point
             -er+2);
 874   1              l_us_arg_length = (unsigned short)(*(l_uc_call_task_buffer_pointer+3) << 8) + *(l_uc_call_task_buffer_poi
             -nter+4);
 875   1              l_uc_arg_p              = l_uc_call_task_buffer_pointer+5;
 876   1      
 877   1              #if (CRC_ENABLE == 1)
 878   1              //Check the header of the call task buffer
 879   1              if (l_uc_header != 0xBB) //If the sender is not Satellite Control Module, do CRC-checking
 880   1                      l_us_crc16_not_match = checkCRC16Match(l_uc_call_task_buffer_pointer,l_us_arg_length+5);                
 881   1              #endif
 882   1      
 883   1              //If CRC bytes do not match, do not proceed, if they match, proceeds
 884   1              if (!l_us_crc16_not_match){             
 885   2                      //If this is a function, call that function
 886   2                      //The magic constant is assigned based on 'minimum' I2C address (GOMSpace)
 887   2                      //and its 'maximum' complement (RTC).
 888   2                      if (l_us_command >= 0x0400 && l_us_command <= 0xD0FF){ 
 889   3                              g_us_res_length = functionModule(l_uc_call_task_buffer_pointer,l_uc_response_task_buffer_pointer);
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 16  

 890   3                      }
 891   2                      #if (TASK_ENABLE == 1)
 892   2                      //If this is a single task call, read its task command to determine its action
 893   2                      else if (l_us_command >= ((unsigned short)(TASK_ADDR << 8)) && l_us_command <= ((unsigned short)(TASK_AD
             -DR << 8)+(TASK_SIZE-1))){     
 894   3                              l_uc_no_of_task         = 1;
 895   3                              l_uc_task_chosen        = l_us_command-(unsigned short)(TASK_ADDR << 8); 
 896   3                              l_uc_task_cmd           = *l_uc_arg_p;
 897   3                              l_uc_task_arg           = *(l_uc_arg_p+1);
 898   3      
 899   3                              setTaskFlags(l_uc_task_chosen,l_uc_task_cmd,l_uc_task_arg);
 900   3      
 901   3                              *(l_uc_response_task_buffer_pointer + g_us_res_length++) = l_uc_no_of_task;
 902   3                      }
 903   2                      #endif
 904   2                      g_uc_combn_flag |= CMD_FLAG_RESPONSE;
 905   2              }
 906   1      }
 907          
 908          #if (SATELLITE_MODE_HANDLER_ENABLE == 1)
 909          //------------------------------------------------------------------------------------
 910          // To handle satellite modes
 911          //------------------------------------------------------------------------------------
 912          // Function's test result: untested
 913          //------------------------------------------------------------------------------------
 914          void satelliteModeHandler (void)
 915          {
 916   1              unsigned short l_us_error_code = EC_INIT;
 917   1      
 918   1              //Check satellite operation mode
 919   1              switch (str_obdh_hk.uc_sat_mode){
 920   2                      //If currently satellite is in the Early Operation Mode
 921   2                      case SATELLITE_MODE_M2:
 922   2                              //During M2, auto-beacon is disabled
 923   2                              //Ian (2012-05-15): This line is to ensure that whatever happens, so that the auto beacon must be disab
             -led
 924   2                              //                                      during M2.
 925   2                              if (!(str_obdh_hk.us_beacon_flag & BEACON_FLAG_AUTO_BEACON_DISABLE))
 926   2                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_AUTO_BEACON_DISABLE;
 927   2      
 928   2                              #if (BODY_RATE_HANDLER_ENABLE == 1)
 929   2                              #if (ADCS_CMD_ENABLE == 1)
 930   2                              #if (PWRS_CMD_ENABLE == 1)
 931   2                              //Check satellite time, if the time has already passed the limit, do necessary things
 932   2                              //Before 15 mins, don't enable bodyRateHandler, but after 15 mins, enable it.
 933   2                              if ((str_obdh_data.ul_obc_time_s > TIME_LIMIT_ENABLE_BRH_IN_M2) && (!(str_obdh_hk.us_brh_flag & BRH_FLA
             -G_ENABLE))){
 934   3                                      #if (SATELLITE_SCHEDULE_HANDLER_ENABLE == 1)
 935   3                                      //If BRH is disabled, enable it
 936   3                                      //Turn on ADCS once
 937   3                                      //Turn ON ADS channel in 50 ms in str_obdh_data.ul_obc_time_s + 2 seconds
 938   3                                      scheduleTurnOnADCS(str_obdh_data.ul_obc_time_s+2);
 939   3                                      #endif
 940   3      
 941   3                                      //Reset body rate value first, assuming it is high
 942   3                                      resetBodyRateValue();
 943   3      
 944   3                                      //Set BRH enable flag
 945   3                                      str_obdh_hk.us_brh_flag |= BRH_FLAG_ENABLE;
 946   3                              }
 947   2      
 948   2                              //After 15 mins + 20 seconds
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 17  

 949   2                              //By this time, ADCS would have been turn ON by the scheduler too. Give buffer of 20 sec
 950   2                              if (str_obdh_data.ul_obc_time_s > TIME_LIMIT_ENABLE_BRH_IN_M2+20)
 951   2                                      //Runs bodyRateHandler
 952   2                                      bodyRateHandler();
 953   2                              #endif
 954   2                              #endif
 955   2                              #endif
 956   2      
 957   2                              #if (TASK_ENABLE == 1)
 958   2                              //After 45 mins, antenna should be deployed, deployment mechanism will be started immediately
 959   2                              if ((str_obdh_data.ul_obc_time_s > TIME_LIMIT_DEPLOY_ANTENNA_START_S) && (!(str_task[TASK_DEPLOY_ANTENN
             -A].uc_status & TASK_REC_FLAGS)))
 960   2                                      //Starts deploy antenna's task
 961   2                                      setTaskFlags(TASK_DEPLOY_ANTENNA,TASK_CMD_RESTART,READ_TASK_NO_READING);
 962   2                              #endif
 963   2                                      
 964   2                              //If the time has come to escape M2 mode, escape from it
 965   2                              if (str_obdh_data.ul_obc_time_s > TIME_LIMIT_TO_STAY_IN_M2){
 966   3                                      //Enable auto-beacon
 967   3                                      //Ian (2012-05-15): This flag modification cannot be put into enterM3, because once the auto beacon is
             - disabled
 968   3                                      //                                      by the ground station, entering M3 should not cause the auto-beacon to be enabled.
 969   3                                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_AUTO_BEACON_DISABLE;
 970   3      
 971   3                                      //Change satellite mode into M3
 972   3                                      enterM3();
 973   3                              }                               
 974   2                              break;
 975   2      
 976   2                      //If currently satellite is in the LEOP idle mode
 977   2                      case SATELLITE_MODE_M3:
 978   2                              //If there is no timeout and no complete stabilization flag from bodyRateHandler
 979   2                              if (!(str_obdh_hk.us_brh_flag & BRH_FLAG_ST_COMPLETED) && !(str_obdh_hk.us_brh_flag & BRH_FLAG_BR_ST_TO
             -)){
 980   3                                      #if (BODY_RATE_HANDLER_ENABLE == 1)
 981   3                                      #if (ADCS_CMD_ENABLE == 1)
 982   3                                      #if (PWRS_CMD_ENABLE == 1)
 983   3                                      //If BRH is disabled, enable it
 984   3                                      if (!(str_obdh_hk.us_brh_flag & BRH_FLAG_ENABLE)) {
 985   4                                              //Reset body rate value first, assuming it is high
 986   4                                              resetBodyRateValue();
 987   4      
 988   4                                              //Set BRH enable flag
 989   4                                              str_obdh_hk.us_brh_flag |= BRH_FLAG_ENABLE;
 990   4                                      }
 991   3              
 992   3                                      //Do body rate control whenever we are in this mode
 993   3                                      bodyRateHandler();
 994   3                                      #endif
 995   3                                      #endif
 996   3                                      #endif
 997   3                              }
 998   2                              //Else
 999   2                              else {
1000   3                                      #if (BODY_RATE_HANDLER_ENABLE == 1)
1001   3                                      #if (ADCS_CMD_ENABLE == 1)
1002   3                                      #if (PWRS_CMD_ENABLE == 1)
1003   3                                      //If BRH is enabled, disable it
1004   3                                      if (str_obdh_hk.us_brh_flag & BRH_FLAG_ENABLE) str_obdh_hk.us_brh_flag &= ~BRH_FLAG_ENABLE;
1005   3                                      #endif
1006   3                                      #endif
1007   3                                      #endif
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 18  

1008   3      
1009   3                                      #if (IDLE_MODE_HANDLER_ENABLE == 1)
1010   3                                      #if (PWRS_CMD_ENABLE == 1)
1011   3                                      //If IMH is disabled, enable it
1012   3                                      if (!(str_obdh_hk.us_imh_flag & IMH_FLAG_ENABLE)) str_obdh_hk.us_imh_flag |= IMH_FLAG_ENABLE;
1013   3      
1014   3                                      //Do idle mode control
1015   3                                      idleModeHandler();
1016   3                                      #endif
1017   3                                      #endif
1018   3                              }
1019   2      
1020   2                              //Check satellite power, see if it is time to enter safe-mode
1021   2                              if (str_obdh_data.uc_batt_soc < str_obdh_par.uc_soc_threshold[0]) enterM4();
1022   2      
1023   2                              //Check if the idle time register is exceeding TIME_LIMIT_BODY_RATE_UNCHECKED_S s
1024   2                              else if (g_ul_idle_time_register > TIME_LIMIT_BODY_RATE_UNCHECKED_S)
1025   2                                      //Re-enter M3
1026   2                                      enterM3();
1027   2                              break;
1028   2      
1029   2                      //If currently satellite is in the LEOP safehold mode
1030   2                      case SATELLITE_MODE_M4:
1031   2                              #if (IDLE_MODE_HANDLER_ENABLE == 1)
1032   2                              #if (PWRS_CMD_ENABLE == 1)
1033   2                              //Make sure that ADCS is OFF at this stage, unless time to enable bodyRateHandler has come
1034   2                              idleModeHandler();
1035   2                              #endif
1036   2                              #endif
1037   2      
1038   2                              //Check satellite power, if it goes above the limit to escape safe-mode, escape from it
1039   2                              if (str_obdh_data.uc_batt_soc >= str_obdh_par.uc_soc_threshold[1]) enterM3();
1040   2      
1041   2                              #if (SAFE_MODE_HANDLER_ENABLE == 1)
1042   2                              #if (ADCS_CMD_ENABLE == 1)
1043   2                              #if (PWRS_CMD_ENABLE == 1)
1044   2                              //Run safe-mode handler
1045   2                              else safeModeHandler();
1046   2                              #endif
1047   2                              #endif
1048   2                              #endif
1049   2                              break;
1050   2      
1051   2                      //If currently satellite is in the Idle mode
1052   2                      case SATELLITE_MODE_M5:
1053   2                              #if (IDLE_MODE_HANDLER_ENABLE == 1)
1054   2                              #if (PWRS_CMD_ENABLE == 1)
1055   2                              //Always run IMH here, but since there is no auto-enabling, it can be disabled by user input
1056   2                              idleModeHandler();
1057   2                              #endif
1058   2                              #endif
1059   2      
1060   2                              #if (BODY_RATE_HANDLER_ENABLE == 1)
1061   2                              #if (ADCS_CMD_ENABLE == 1)
1062   2                              #if (PWRS_CMD_ENABLE == 1)
1063   2                              //Do not control BRH here, but if someone want to enable BRH, he must know the procedure...
1064   2                              if (str_obdh_hk.us_brh_flag & BRH_FLAG_ENABLE) {
1065   3                                      //Runs bodyRateHandler
1066   3                                      bodyRateHandler();
1067   3      
1068   3                                      //Check if the idle time register is exceeding TIME_LIMIT_BODY_RATE_UNCHECKED_S s
1069   3                                      if (g_ul_idle_time_register > TIME_LIMIT_BODY_RATE_UNCHECKED_S){
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 19  

1070   4                                              #if (SATELLITE_MODE_HANDLER_ENABLE == 1)
1071   4                                              //Re-enter M5
1072   4                                              enterM5();
1073   4                                              #endif
1074   4      
1075   4                                              //Enable body rate handler
1076   4                                              reenableBRH();
1077   4                                      }
1078   3                              }
1079   2                              #endif
1080   2                              #endif
1081   2                              #endif
1082   2      
1083   2                              //Check satellite power, see if it is time to enter safe-mode
1084   2                              if (str_obdh_data.uc_batt_soc < str_obdh_par.uc_soc_threshold[0]) enterM8();
1085   2                              break;
1086   2      
1087   2                      //If currently satellite is in the Groundpass mode
1088   2                      case SATELLITE_MODE_M6:
1089   2                              #if (SATELLITE_MODE_HANDLER_ENABLE == 1)
1090   2                              //Do nothing, this state will always be over, anyway.
1091   2                              //Just a fail-case here, if groundpass is not started, but we are in this state, 
1092   2                              //Go back to state SATELLITE_MODE_M5
1093   2                              if (!(g_uc_gsch_flag & GSCH_FLAG_GROUNDPASS_STARTED)) enterM5();
1094   2                              #endif
1095   2                              break;
1096   2      
1097   2                      //If currently satellite is in the Mission mode
1098   2                      case SATELLITE_MODE_M7:
1099   2                              #if (SATELLITE_MODE_HANDLER_ENABLE == 1)
1100   2                              //Run neither BRH nor IMH here
1101   2                              //So long as mission time register is still there, keep in this state, else, go to M5                   
1102   2                              if (!(g_us_mission_time_register)) enterM5();
1103   2                              #endif
1104   2                                      
1105   2                              //Check satellite power, see if it is time to enter safe-mode
1106   2                              else if (str_obdh_data.uc_batt_soc < str_obdh_par.uc_soc_threshold[2]){
1107   3                                      #if (SATELLITE_MODE_HANDLER_ENABLE == 1)
1108   3                                      //Change satellite mode into M8
1109   3                                      enterM8();
1110   3                                      #endif
1111   3      
1112   3                                      //Reset mission time register (terminates whatever missions we currently have)
1113   3                                      g_us_mission_time_register = 0;
1114   3                              }
1115   2                              break;
1116   2      
1117   2                      //If currently satellite is in the Power safehold mode
1118   2                      case SATELLITE_MODE_M8:
1119   2                              #if (IDLE_MODE_HANDLER_ENABLE == 1)
1120   2                              #if (PWRS_CMD_ENABLE == 1)
1121   2                              //Make sure that ADCS is OFF at this stage, unless time to enable bodyRateHandler has come
1122   2                              idleModeHandler();
1123   2                              #endif
1124   2                              #endif
1125   2      
1126   2                              //Check satellite power, if it goes above the limit to escape safe-mode, escape from it
1127   2                              if (str_obdh_data.uc_batt_soc >= str_obdh_par.uc_soc_threshold[1]) enterM5();
1128   2      
1129   2                              #if (SAFE_MODE_HANDLER_ENABLE == 1)
1130   2                              #if (ADCS_CMD_ENABLE == 1)
1131   2                              #if (PWRS_CMD_ENABLE == 1)
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 20  

1132   2                              //Run safe-mode handler
1133   2                              else safeModeHandler();
1134   2                              #endif
1135   2                              #endif
1136   2                              #endif
1137   2      
1138   2                              break;
1139   2                      
1140   2                      //If the satellite is not within the known modes, satellite is in errorneous condition
1141   2                      default:
1142   2                              //Attempt to enter stable mode (M5)
1143   2                              enterM5();
1144   2                              break;
1145   2              }
1146   1      }
1147          #endif
1148          
1149          //------------------------------------------------------------------------------------
1150          // To handle some peripheral errors (in the beginning of each loop, if any)
1151          //------------------------------------------------------------------------------------
1152          // Function's test result: untested
1153          //------------------------------------------------------------------------------------
1154          void peripheralErrorHandler (void)
1155          {
1156   1              #if (PERIPHERAL_ERROR_HANDLER_ENABLE == 1)
1157   1      
1158   1              char SFRPAGE_SAVE = SFRPAGE;
1159   1      
1160   1              //Only in the config page, we can control XBR1
1161   1              SFRPAGE = CONFIG_PAGE;
1162   1      
1163   1              //To detect I2C bus error and prevent I2C bus stuck when OBDH becomes master device
1164   1              if(!SDA && !(g_us_i2c_flag & I2C_FLAG_OBDH_IN_SLAVE_MODE)){
1165   2                      //Set I2C bus recovery attempt flag
1166   2                      g_us_i2c_flag |= I2C_FLAG_BUS_RECOVERY_ATTEMPT;
1167   2      
1168   2                      //If slave is holding SDA low because of an improper SMBus reset or error
1169   2                      while(!SDA && !(g_us_i2c_flag & I2C_FLAG_BUS_SDA_HELD_LOW_RECOVERY_TIMEOUT))
1170   2                      {
1171   3                              //Provide clock pulses to allow the slave to advance out
1172   3                              //of its current state. This will allow it to release SDA.
1173   3                              //Enable Crossbar
1174   3                              XBR1 |= 0x40;                     
1175   3                              
1176   3                              //Forcefully drive the clock low
1177   3                              SCL = 0;                         
1178   3                              waitMs(TIME_LIMIT_SCL_FORCED_LOW_MS);                                   
1179   3                                                                                              
1180   3                              //Release the clock
1181   3                              SCL = 1;                       
1182   3                      
1183   3                              //Set I2C bus recovery attempt flag for SCL held high
1184   3                              g_us_i2c_flag |= I2C_FLAG_BUS_SCL_HELD_HIGH_RECOVERY_ATTEMPT;
1185   3              
1186   3                              //Wait for open-drain clock output to rise
1187   3                              while(!SCL && !(g_us_i2c_flag & I2C_FLAG_BUS_SCL_HELD_HIGH_RECOVERY_TIMEOUT));                                  
             -                                                           
1188   3      
1189   3                              //Reset I2C bus recovery attempt flag for SCL held high
1190   3                              g_us_i2c_flag &= ~I2C_FLAG_BUS_SCL_HELD_HIGH_RECOVERY_ATTEMPT;
1191   3                      
1192   3                              //Hold the clock high
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 21  

1193   3                              waitTenthMs(TIME_LIMIT_SCL_FORCED_HIGH_TENTH_MS);
1194   3                      
1195   3                              //Disable Crossbar
1196   3                              XBR1 &= ~0x40;                     
1197   3                      }
1198   2      
1199   2                      //Reset I2C bus recovery attempt flag
1200   2                      g_us_i2c_flag &= ~I2C_FLAG_BUS_RECOVERY_ATTEMPT;
1201   2      
1202   2                      //Reset both timeout flags SDA low and SCl high timeout flags to zero again
1203   2                      //Retry to recover I2C lines in the next loop, if the problem still persists
1204   2                      g_us_i2c_flag &= ~I2C_FLAG_BUS_SDA_HELD_LOW_RECOVERY_TIMEOUT;
1205   2                      g_us_i2c_flag &= ~I2C_FLAG_BUS_SCL_HELD_HIGH_RECOVERY_TIMEOUT;
1206   2              }
1207   1      
1208   1              //Check the status of the I2C bus again here
1209   1              if(!SDA && !(g_us_i2c_flag & I2C_FLAG_OBDH_IN_SLAVE_MODE)){
1210   2                      if(!(g_us_i2c_flag & I2C_FLAG_STATUS_NON_FUNCTIONAL) ){ //dec28_yc, only updates on transitional from !I
             -2C_FLAG_STATUS_NON_FUNCTIONAL to I2C_FLAG_STATUS_NON_FUNCTIONAL
1211   3                              //I2C lines fail
1212   3                              g_us_i2c_flag |= I2C_FLAG_STATUS_NON_FUNCTIONAL;
1213   3                              
1214   3                              //I2C lines still fail, attempt reset, clear software flag
1215   3                              resetI2CCommunication();                
1216   3                              #if (EVENT_HANDLER_ENABLE == 1)
1217   3                              #if (STORING_ENABLE == 1)
1218   3                              //dec22_yc event log    
1219   3                              eventHandler(EV_PERIPHERAL_HANDLER+g_us_i2c_flag,0,0,0,0,0,0);
1220   3                              #endif
1221   3                              #endif
1222   3                      }
1223   2              }
1224   1              else{
1225   2                      if(g_us_i2c_flag & I2C_FLAG_STATUS_NON_FUNCTIONAL){ //dec28_yc, only updates on transitional from I2C_FL
             -AG_STATUS_NON_FUNCTIONAL to !I2C_FLAG_STATUS_NON_FUNCTIONAL
1226   3                              //I2C lines are okay
1227   3                              g_us_i2c_flag &= ~I2C_FLAG_STATUS_NON_FUNCTIONAL;
1228   3      
1229   3                              //I2C lines are just recovered, reset, clear software flag
1230   3                              resetI2CCommunication();                
1231   3                              #if (EVENT_HANDLER_ENABLE == 1)
1232   3                              #if (STORING_ENABLE == 1)
1233   3                              //dec22_yc event log    
1234   3                              eventHandler(EV_PERIPHERAL_HANDLER+g_us_i2c_flag,0,0,0,0,0,0);
1235   3                              #endif
1236   3                              #endif
1237   3                      }
1238   2              }
1239   1      
1240   1              SFRPAGE = SFRPAGE_SAVE;
1241   1      
1242   1              #endif
1243   1      }
1244          
1245          //------------------------------------------------------------------------------------
1246          // To handle updates in the beginning of each loop
1247          //------------------------------------------------------------------------------------
1248          // Function's test result: untested
1249          //------------------------------------------------------------------------------------
1250          void systemUpdateAndMonitor (void)
1251          {
1252   1              #if (UPDATE_HANDLER_ENABLE == 1)
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 22  

1253   1      
1254   1              unsigned short l_us_adcs_error_code = EC_INIT;
1255   1              unsigned short l_us_pwrs_error_code = EC_INIT;
1256   1              unsigned short l_us_comm_error_code = EC_INIT;
1257   1              unsigned short l_us_save_bp_error_code = EC_INIT;
1258   1              unsigned char l_uc_error_counter = 0;
1259   1              #if (RTC_CMD_ENABLE == 1)
1260   1              #if (TIME_ENABLE == 1)
1261   1              unsigned long l_ul_lower_limit; 
1262   1              unsigned long l_ul_upper_limit;
1263   1              #endif
1264   1              #endif
1265   1      
1266   1              //Update satellite time (estimated update: every second)
1267   1              //In the interrupt, time to be updated is raised every second 
1268   1              if (g_uc_evha_flag & EVENT_FLAG_SAT_INFO_TO_UPDATE){
1269   2                      //Reset the satellite info to update flag
1270   2                      g_uc_evha_flag &= ~EVENT_FLAG_SAT_INFO_TO_UPDATE;
1271   2      
1272   2                      #if (EXTRA_ENABLE == 1)
1273   2                      //Update OBDH info
1274   2                      readMCUTemperature();
1275   2                      #endif
1276   2      
1277   2                      #if (TIME_ENABLE == 1)
1278   2                      #if (RTC_CMD_ENABLE == 1)
1279   2                      //Get satellite time from RTC
1280   2                      if (g_uc_rtc_time_lapse_from_last_update_s >= GET_RTC_TIME_UPDATE_PERIOD){
1281   3                              g_uc_rtc_time_lapse_from_last_update_s = 0;                     
1282   3                              g_us_latest_rtc_time_update_ec = getSatTimeFromRTCInSec();
1283   3                              #if (EVENT_HANDLER_ENABLE == 1)
1284   3                              #if (STORING_ENABLE == 1)
1285   3                              //dec22_yc tested
1286   3                              eventHandler(EV_RTC_TIME_UPDATE_HANDLER+g_us_latest_rtc_time_update_ec,
1287   3                                      str_obdh_data.ul_rtc_ref_time_s>>24,
1288   3                                      str_obdh_data.ul_rtc_ref_time_s>>16,
1289   3                                      str_obdh_data.ul_rtc_ref_time_s>>8,
1290   3                                      str_obdh_data.ul_rtc_ref_time_s,0,0);
1291   3                              #endif
1292   3                              #endif
1293   3      
1294   3                              //If there is no error code, take RTC updated satellite time
1295   3                              //Else, keep our current time
1296   3                              if (!g_us_latest_rtc_time_update_ec){
1297   4                                      //Lock OBC time before being used
1298   4                                      g_ul = str_obdh_data.ul_obc_time_s;
1299   4                              
1300   4                                      //RTC time cannot drift more than 25% since last time updated. If it is, there must be something wrong
             -.
1301   4                                      l_ul_lower_limit = (g_ul >= (GET_RTC_TIME_UPDATE_PERIOD/4)) ? g_ul-(GET_RTC_TIME_UPDATE_PERIOD/4) : 0;
1302   4                                      l_ul_upper_limit = g_ul + (GET_RTC_TIME_UPDATE_PERIOD/4);
1303   4                                      if ((str_obdh_data.ul_rtc_ref_time_s <= l_ul_upper_limit) && (str_obdh_data.ul_rtc_ref_time_s > l_ul_l
             -ower_limit))
1304   4                                              str_obdh_data.ul_obc_time_s = str_obdh_data.ul_rtc_ref_time_s;
1305   4                                      else{
1306   5                                              #if (RTC_CMD_ENABLE == 1)
1307   5                                              sec2DateUpdateFromRef(g_ul);
1308   5                                              #if (DEBUGGING_FEATURE == 1)
1309   5                                              g_us_latest_gdsn_to_rtc_update_ec = rtcUpdateDate(0,str_date_update.uc_day,str_date_update.uc_month,s
             -tr_date_update.uc_year,str_date_update.uc_hour,str_date_update.uc_min,str_date_update.uc_s,DEBUGGING_FEATURE);
1310   5                                              #else
                                                      g_us_latest_gdsn_to_rtc_update_ec = rtcUpdateDate(0,str_date_update.uc_day,str_date_update.uc_month,s
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 23  

             -tr_date_update.uc_year,str_date_update.uc_hour,str_date_update.uc_min,str_date_update.uc_s);
                                                      #endif
1313   5                                              #else
                                                      g_us_latest_gdsn_to_rtc_update_ec = EC_RTC_CMD_DISABLED;
                                                      #endif
1316   5                                      }
1317   4                              }
1318   3                      }
1319   2                      #endif
1320   2                      #endif
1321   2      
1322   2                      #if (PWRS_CMD_ENABLE == 1)
1323   2                      //Get latest channel status from PWRS
1324   2                      if (g_uc_pwrs_time_lapse_from_last_ch_stat_update_s >= PWRS_CH_STAT_UPDATE_PERIOD){
1325   3                              g_uc_pwrs_time_lapse_from_last_ch_stat_update_s = 0;
1326   3                              #if (DEBUGGING_FEATURE == 1)
1327   3                              g_us_latest_ch_stat_update_ec = pwrsGetData((unsigned char)DATA_PWRS_UC_CHANNEL_STATUS,0);
1328   3                              #else
                                      g_us_latest_ch_stat_update_ec = pwrsGetData((unsigned char)DATA_PWRS_UC_CHANNEL_STATUS);
                                      #endif
1331   3      
1332   3                              //Only if there is no error code in PWRS, 
1333   3                              if (!g_us_latest_ch_stat_update_ec){
1334   4                                      #if (IDLE_MODE_HANDLER_ENABLE == 1)
1335   4                                      #if (PWRS_CMD_ENABLE == 1)
1336   4                                      //IMH can be considered ready
1337   4                                      str_obdh_hk.us_imh_flag |= IMH_FLAG_READY;
1338   4                                      #endif
1339   4                                      #endif
1340   4      
1341   4                                      //COMM channel can be checked, if it is not ON, while satellite mode is not M4 or M8, turn it ON
1342   4                                      if ((str_obdh_hk.uc_sat_mode != SATELLITE_MODE_M4) && (str_obdh_hk.uc_sat_mode != SATELLITE_MODE_M8)){
1343   5                                              //Check COMM channel
1344   5                                              if (!(str_pwrs_data.uc_channel_status & COMM_CHANNEL_BIT)){
1345   6                                                      #if (DEBUGGING_FEATURE == 1)
1346   6                                                      l_us_pwrs_error_code = pwrsSetSingleOutput(COMM_CHANNEL,CHANNEL_ON,TIME_LIMIT_SET_RESET_CHANNEL_MS,0
             -);        
1347   6                                                      #else
                                                              l_us_pwrs_error_code = pwrsSetSingleOutput(COMM_CHANNEL,CHANNEL_ON,TIME_LIMIT_SET_RESET_CHANNEL_MS);
                                                              #endif
1350   6                                              }
1351   5      
1352   5                                              //Check ACS channel
1353   5                                              if (!(str_pwrs_data.uc_channel_status & ACS_CHANNEL_BIT)){
1354   6                                                      #if (DEBUGGING_FEATURE == 1)
1355   6                                                      l_us_pwrs_error_code = pwrsSetSingleOutput(ACS_CHANNEL,CHANNEL_ON,TIME_LIMIT_SET_RESET_CHANNEL_MS,0)
             -;        
1356   6                                                      #else
                                                              l_us_pwrs_error_code = pwrsSetSingleOutput(ACS_CHANNEL,CHANNEL_ON,TIME_LIMIT_SET_RESET_CHANNEL_MS);
                                                              #endif
1359   6                                              }
1360   5                                      }
1361   4                              }
1362   3                  #if (IDLE_MODE_HANDLER_ENABLE == 1)
1363   3                  #if (PWRS_CMD_ENABLE == 1)
1364   3                              else str_obdh_hk.us_imh_flag &= ~IMH_FLAG_READY;
1365   3                              #endif
1366   3                              #endif
1367   3      
1368   3                              //Only if there is no error code and the PWRS channel status shows that ADS is ON
1369   3                              //(both ADS desired and actual), flag for READY in the body rate handler will be set.
1370   3                              //Currently, only actual check is concerened. Also, only if latest ADCS HK is valid
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 24  

1371   3                              //Then BRH can be truly considered as ready.
1372   3                              if (!g_us_latest_ch_stat_update_ec && (str_pwrs_data.uc_channel_status & ADS_CHANNEL_BIT) && !g_us_late
             -st_adcs_hk_ec){
1373   4                                      #if (BODY_RATE_HANDLER_ENABLE == 1)
1374   4                                      #if (ADCS_CMD_ENABLE == 1)
1375   4                                      #if (PWRS_CMD_ENABLE == 1)                              
1376   4                                      str_obdh_hk.us_brh_flag |= BRH_FLAG_READY;
1377   4                                      #endif
1378   4                                      #endif
1379   4                                      #endif
1380   4      
1381   4                          #if (IDLE_MODE_HANDLER_ENABLE == 1)
1382   4                          #if (PWRS_CMD_ENABLE == 1)
1383   4                                      str_obdh_hk.us_imh_flag |= IMH_FLAG_ADS_ON;
1384   4                                      #endif
1385   4                                      #endif
1386   4                              }
1387   3                              else {
1388   4                                      #if (BODY_RATE_HANDLER_ENABLE == 1)
1389   4                                      #if (ADCS_CMD_ENABLE == 1)
1390   4                                      #if (PWRS_CMD_ENABLE == 1)                              
1391   4                                      str_obdh_hk.us_brh_flag &= ~BRH_FLAG_READY; 
1392   4                                      str_obdh_hk.us_brh_flag &= ~BRH_FLAG_DET_ON; //If ADS is OFF, ADCS cannot detumble.
1393   4                                      #endif
1394   4                                      #endif
1395   4                                      #endif
1396   4      
1397   4                          #if (IDLE_MODE_HANDLER_ENABLE == 1)
1398   4                          #if (PWRS_CMD_ENABLE == 1)
1399   4                                      str_obdh_hk.us_imh_flag &= ~IMH_FLAG_ADS_ON;
1400   4                                      #endif
1401   4                                      #endif
1402   4                              }                               
1403   3                      }
1404   2                      #endif
1405   2      
1406   2                      #if (ADCS_CMD_ENABLE == 1)
1407   2                      //If it is time to update ADCS info, update ADCS info
1408   2                      if (g_uc_adcs_time_lapse_from_last_update_s >= ADCS_INFO_UPDATE_PERIOD){
1409   3                              g_uc_adcs_time_lapse_from_last_update_s = 0;
1410   3                              
1411   3                              //Only update time if ADS has been turned ON for more than TIME_DELAY_ACS_TO_ON_AFTER_ADS_ON_S
1412   3                              //This is to prevent I2C lines hanging
1413   3                              if (g_ul_ads_uptime_s >= TIME_DELAY_ACS_TO_ON_AFTER_ADS_ON_S){
1414   4                                      #if (DEBUGGING_FEATURE == 1)
1415   4                                      l_us_adcs_error_code = adcsSetTime (str_obdh_data.ul_obc_time_s+SECONDS_FROM_TAI_TO_KILL_SWITCH_DEACTI
             -VATION,0);
1416   4                                      #else
                                              l_us_adcs_error_code = adcsSetTime (str_obdh_data.ul_obc_time_s+SECONDS_FROM_TAI_TO_KILL_SWITCH_DEACTI
             -VATION);
                                              #endif
1419   4                                      #if (EVENT_HANDLER_ENABLE == 1)
1420   4                                      #if (STORING_ENABLE == 1)
1421   4                                      if(l_us_adcs_error_code) eventHandler(EV_E_ADCS_INFO_UPDATE_HANDLER+l_us_adcs_error_code,0,0,0,0,0,0);
             -//dec22_yc track error only  dec21_yc changed and tested i/p
1422   4                                      #endif
1423   4                                      #endif
1424   4                              }
1425   3                      }
1426   2                      #endif
1427   2      
1428   2                      #if (PWRS_CMD_ENABLE == 1)
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 25  

1429   2                      //If it is time to update PWRS info, update PWRS info
1430   2                      if (g_uc_pwrs_time_lapse_from_last_update_s >= PWRS_INFO_UPDATE_PERIOD){
1431   3                              g_uc_pwrs_time_lapse_from_last_update_s = 0;
1432   3                      }
1433   2                      #endif
1434   2      
1435   2                      #if (ISIS_CMD_ENABLE == 1)
1436   2                      //If it is time to update COMM rate, update it (if necessary, implement it)
1437   2                      if ((g_uc_comm_time_lapse_from_last_update_s > COMM_INFO_UPDATE_PERIOD) && (str_pwrs_data.uc_channel_sta
             -tus & COMM_CHANNEL_BIT)){
1438   3                              g_uc_comm_time_lapse_from_last_update_s = 0;
1439   3                              
1440   3                              //This is to prevent unwanted beacon sending.
1441   3                              l_us_comm_error_code = isisI2C(ITC_ADDR, ITC_I2C_TRN_STATE, 0);
1442   3      
1443   3                              //If the beacon is found to be active
1444   3                              if (!l_us_comm_error_code && (g_uc_i2c_data_in[0] & 0x20))
1445   3                                      //Turn off the beacon
1446   3                                      l_us_comm_error_code = isisI2C(ITC_ADDR, ITC_I2C_CLR_BCN, 0);
1447   3      
1448   3                              //If the transmitter is found to be not idle when not used
1449   3                              if (!l_us_comm_error_code && (g_uc_i2c_data_in[0] & 0x40))
1450   3                                      //Turn off the beacon
1451   3                                      l_us_comm_error_code = isisI2CPar(ITC_I2C_SET_TRN_IDLE, IDLE_OFF, 0);
1452   3      
1453   3                              //If the transmitter is found to be not in NOMINAL TELEMETRY mode
1454   3                              if (!l_us_comm_error_code && ((g_uc_i2c_data_in[0] & 0x03) != 0x01))
1455   3                                      //Set transmitter to nominal telemetry mode
1456   3                                      l_us_comm_error_code = isisI2CPar(ITC_I2C_SET_TRN_OUTM, NOMINAL_TELEMETRY, 0);
1457   3      
1458   3                              #if (EVENT_HANDLER_ENABLE == 1)
1459   3                              #if (STORING_ENABLE == 1)
1460   3                              if(l_us_comm_error_code)        eventHandler(EV_E_COMM_INFO_UPDATE_HANDLER+l_us_comm_error_code,0,0,0,0,0,0);/
             -/dec22_yc track error only    dec21_yc changed and tested i/p
1461   3                              #endif
1462   3                              #endif
1463   3      
1464   3                      }
1465   2                      #endif
1466   2      
1467   2                      #if (TASK_ENABLE == 1)
1468   2                      #if (ANTENNA_CMD_ENABLE == 1)
1469   2                      #if (PWRS_CMD_ENABLE == 1)
1470   2                      //Antenna deployment handler here. To make sure to do any possible attempt to deploy antenna
1471   2                      //Only applicable when satellite is in the M3 mode
1472   2                      if (str_obdh_hk.uc_sat_mode == SATELLITE_MODE_M3 && g_uc_antenna_status_check_from_last_update_s >= ANTE
             -NNA_STATUS_CHECK_PERIOD){
1473   3                              g_uc_antenna_status_check_from_last_update_s = 0;
1474   3      
1475   3                              //Check if any antenna is not deployed and antenna deployment task is currently not running
1476   3                              if ((str_antenna_hk.us_deployment_status & INITIAL_ANTENNA_STATUS) && (!(str_task[TASK_DEPLOY_ANTENNA].
             -uc_status & TASK_RUNNING_FLAG))){
1477   4                                      //Toggle antenna microcontroller used
1478   4                                      g_uc_antenna_addr = (g_uc_antenna_addr == ANTENNA_1_ADDR) ? ANTENNA_2_ADDR : ANTENNA_1_ADDR;
1479   4      
1480   4                                      //Restart deployment mechanism
1481   4                                      setTaskFlags(TASK_DEPLOY_ANTENNA,TASK_CMD_RESTART,READ_TASK_NO_READING);
1482   4                              }
1483   3                      }
1484   2                      #endif
1485   2                      #endif
1486   2                      #endif
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 26  

1487   2              
1488   2                      //If there is any change in the reference orbit as compared to the current orbit
1489   2                  if (str_obdh_data.us_auto_reference_rev_no != str_obdh_data.us_current_rev_no){        
1490   3                              //Case 1: reference orbit is higher than the current orbit
1491   3                              //Block pointer must be kept saved until both orbits show same results
1492   3                              if (str_obdh_data.us_auto_reference_rev_no > str_obdh_data.us_current_rev_no)
1493   3                                      str_obdh_data.uc_orbit_no_changed_counter = str_obdh_data.us_auto_reference_rev_no-str_obdh_data.us_cu
             -rrent_rev_no;
1494   3              
1495   3                              //Case 2: reference orbit is lower than or equal to the current orbit
1496   3                              //Only save the block pointer once
1497   3                              else str_obdh_data.uc_orbit_no_changed_counter = 1;
1498   3      
1499   3                              #if (EVENT_HANDLER_ENABLE == 1)
1500   3                              #if (STORING_ENABLE == 1)
1501   3                              //dec22_yc moved to top a bit (tested)
1502   3                              eventHandler(EV_ORBIT_UPDATE_HANDLER,
1503   3                                      str_obdh_data.us_auto_reference_rev_no>>8,str_obdh_data.us_auto_reference_rev_no,
1504   3                                      str_obdh_data.us_current_rev_no>>8,str_obdh_data.us_current_rev_no,0,0);//dec_yc track orbit change
1505   3                              #endif
1506   3                              #endif
1507   3              
1508   3                              //Adjust current orbit to be the same with the reference orbit
1509   3                      str_obdh_data.us_current_rev_no = str_obdh_data.us_auto_reference_rev_no;
1510   3              
1511   3                  }
1512   2              
1513   2                      #if (STORING_ENABLE == 1)
1514   2                      //Save the block pointer's SD write pointer value in the respective SD card block (based-on its current 
             -orbit number)
1515   2                      //Only consider the saving is done if there is no error code in the saving process
1516   2                      //Ian (2012-05-15): l_uc_error_counter++ and l_uc_error_counter < 1 are put as a way to let retry if con
             -stant 1 is increased.
1517   2                      while(str_obdh_data.uc_orbit_no_changed_counter && l_uc_error_counter < 1){
1518   3                              l_us_save_bp_error_code = saveDataProtected(OBDH_SUBSYSTEM,SD_BP,g_uc_sd_data_buffer);
1519   3                              if (!l_us_save_bp_error_code) str_obdh_data.uc_orbit_no_changed_counter--;
1520   3                              else l_uc_error_counter++;
1521   3                      }
1522   2                      
1523   2                      //If this is the time to save the satellite's latest state, save it
1524   2                      if ((g_us_obdh_time_lapse_from_last_save_state_s > OBDH_SAVE_STATE_PERIOD) && (!(g_uc_evha_flag & EVENT_
             -FLAG_RESET_SAT_INITIALIZED))){
1525   3                              //Reset OBDH time lapse from last saving state attempt
1526   3                              g_us_obdh_time_lapse_from_last_save_state_s = 0;
1527   3      
1528   3                              //Latest satellite state
1529   3                              saveState();
1530   3                      }
1531   2                      #endif
1532   2          }   
1533   1      
1534   1              #endif
1535   1      }
1536          
1537          #if (SENDING_ENABLE == 1)
1538          #if (ISIS_CMD_ENABLE == 1)
1539          #if (BEACON_HANDLER_ENABLE == 1)
1540          //------------------------------------------------------------------------------------
1541          // To handle beacon modes
1542          //------------------------------------------------------------------------------------
1543          // Function's test result: untested
1544          //------------------------------------------------------------------------------------
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 27  

1545          void beaconHandler (void)
1546          {
1547   1              unsigned short l_us_error_code[4] = 0;
1548   1              unsigned short l_us_msg_length = 0;
1549   1              static unsigned char l_uc_itn_low_monitoring_counter = 0;
1550   1      
1551   1              //If there is no error in the beacon or the time of error has exceeded TIME_LIMIT_BEACON_ERROR_S
1552   1              if (!(str_obdh_hk.us_beacon_flag & BEACON_FLAG_ERROR) || g_uc_beacon_error_counter > TIME_LIMIT_BEACON_ER
             -ROR_S){
1553   2                      //Reset beacon error counter
1554   2                      g_uc_beacon_error_counter = 0;
1555   2      
1556   2                      //If beacon is uninitialized
1557   2                      if (!(str_obdh_hk.us_beacon_flag & BEACON_FLAG_INIT)){                                                          
1558   3                              //Initialize CW beacon content, rate, interval and length
1559   3                              groundInitCWBeacon(BEACON_FLAG_CW_MODE_M3);
1560   3                      
1561   3                              //Initialize CW beacon rate to default
1562   3                              l_us_error_code[0] = isisI2CPar(ITC_I2C_SET_CW_CHAR_RT,str_obdh_hk.us_cw_char_rate_par,0);
1563   3                      
1564   3                              //Clear CW beacon
1565   3                              l_us_error_code[1] = isisI2C(ITC_ADDR,ITC_I2C_CLR_BCN,0);
1566   3      
1567   3                              //Set the beacon's TO callsigns
1568   3                              l_us_error_code[2] = isisI2CMsg(ITC_I2C_SET_DFLT_AX_TO,0,0,0);
1569   3                      
1570   3                              //Set the beacon's FROM callsigns
1571   3                              l_us_error_code[3] = isisI2CMsg(ITC_I2C_SET_DFLT_AX_FROM,0,0,0);
1572   3                      
1573   3                              //If there is no error code, then considers initialization finished
1574   3                              if (!l_us_error_code[0] && !l_us_error_code[1] && !l_us_error_code[2] && !l_us_error_code[3]){
1575   4                                      //Reset all flags except auto-beacon disabling flag
1576   4                                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_ERROR_SET_FILTER;
1577   4      
1578   4                                      //Set initialized flags
1579   4                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_INITIALIZED;
1580   4                      
1581   4                                      //Reset beacon retry counter
1582   4                                      g_uc_beacon_retry_counter = 0;                          
1583   4      
1584   4                                      //Reset the current monitoring value
1585   4                                      l_uc_itn_low_monitoring_counter = 0;
1586   4      
1587   4                                      #if (EVENT_HANDLER_ENABLE == 1)
1588   4                                      #if (STORING_ENABLE == 1)
1589   4                                      //dec22_yc tested
1590   4                                      eventHandler(EV_BEACON_HANDLER+EC_BEACON_FLAG_ERROR,str_obdh_hk.us_beacon_flag>>8,str_obdh_hk.us_beaco
             -n_flag,
1591   4                                                                                      g_us_beacon_monitoring_time>>8,g_us_beacon_monitoring_time,g_uc_beacon_retry_counter,0);//dec22_
             -yc track prior to error only as trsistion too fast                            
1592   4                                      #endif
1593   4                                      #endif
1594   4                              }
1595   3                              //Else, increase retry counter
1596   3                              else g_uc_beacon_retry_counter++;       
1597   3                      }
1598   2              }
1599   1      
1600   1              //If the beacon is enabled and its checking flag is raised
1601   1              if ((str_obdh_hk.us_beacon_flag & BEACON_FLAG_CHECKING_FILTER) == BEACON_FLAG_CHECKING_CONDITION){
1602   2                      //Reset check flag
1603   2                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_CHECK;
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 28  

1604   2      
1605   2                      //Update beacon's automatic type here, based on some considerations
1606   2                      if (str_obdh_hk.uc_gsch_state == GSCH_STATE_GROUND_PASS || str_obdh_hk.uc_gsch_state == GSCH_STATE_SEND_
             -REAL_TIME_DATA || str_obdh_hk.uc_gsch_state == GSCH_STATE_SEND_STORED_DATA){
1607   3                              str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_TYPE;
1608   3                              //Change the beacon interval when entering Groundpass state
1609   3                              //Change beacon interval to 10 sec
1610   3                              g_uc_beacon_interval = AX25_BEACON_INTERVAL_DEFAULT;
1611   3                      }
1612   2                      //Else if the current GSCH state is waiting for the groundpass key
1613   2                      else if (str_obdh_hk.uc_gsch_state == GSCH_STATE_WAITING_FOR_KEY_REPLY){
1614   3                              //Set the beacon type to CW
1615   3                              str_obdh_hk.us_beacon_flag |= BEACON_FLAG_TYPE;
1616   3              
1617   3                              //Change CW beacon mode flag to COMM_ZONE flag
1618   3                              //Change the beacon interval accordingly
1619   3                              str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_CW_MODE;
1620   3                              str_obdh_hk.us_beacon_flag |= BEACON_FLAG_CW_MODE_COMM_ZONE;
1621   3                              g_uc_beacon_interval = str_obdh_par.uc_beacon_interval[3];
1622   3                      }
1623   2                      //Other than that, assigning each individual beacon 
1624   2                      else {
1625   3                              //Set the beacon type to CW
1626   3                              str_obdh_hk.us_beacon_flag |= BEACON_FLAG_TYPE;
1627   3              
1628   3                              //Set the beacon type and interval based on satellite mode
1629   3                              //If Satellite is in M3 -> long, 1 min
1630   3                              if (str_obdh_hk.uc_sat_mode == SATELLITE_MODE_M3){
1631   4                                      //Set auto-beacon for M3 mode
1632   4                                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_CW_MODE;
1633   4                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_CW_MODE_M3;
1634   4                                      g_uc_beacon_interval = str_obdh_par.uc_beacon_interval[0];
1635   4                              }
1636   3                              //If the satellite is in M4, M5, or M7 -> long, 2 mins
1637   3                              else if (str_obdh_hk.uc_sat_mode == SATELLITE_MODE_M4 || str_obdh_hk.uc_sat_mode == SATELLITE_MODE_M5 |
             -| str_obdh_hk.uc_sat_mode == SATELLITE_MODE_M7){
1638   4                                      //Set auto-beacon for M4, M5, and M7 mode
1639   4                                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_CW_MODE;
1640   4                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_CW_MODE_M4_M5_M7;
1641   4                                      g_uc_beacon_interval = str_obdh_par.uc_beacon_interval[1];
1642   4                              }
1643   3                              //If the satellite is in M8 -> short, 2 mins
1644   3                              else if (str_obdh_hk.uc_sat_mode == SATELLITE_MODE_M8){
1645   4                                      //Set auto-beacon for M8 mode
1646   4                                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_CW_MODE;
1647   4                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_CW_MODE_M8;
1648   4                                      g_uc_beacon_interval = str_obdh_par.uc_beacon_interval[2];
1649   4                              }
1650   3                      }
1651   2              
1652   2                      //Check its monitor flag
1653   2                      if (str_obdh_hk.us_beacon_flag & BEACON_FLAG_MONITOR){
1654   3                              //If currently the beacon is in the monitoring state
1655   3                              //Check ISIS' transmitter current
1656   3                              l_us_error_code[0] = isisI2C(IMC_ADDR,IMC_I2C_TRN_ICON,0);
1657   3      
1658   3                              //If the communication with ISIS is successful, read I2C data in
1659   3                              if (!l_us_error_code[0]){
1660   4                                      //Reset retry counter value
1661   4                                      g_uc_beacon_retry_counter = 0;
1662   4      
1663   4                                      //Increase monitoring time
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 29  

1664   4                                      g_us_beacon_monitoring_time++;
1665   4              
1666   4                                      //If very little current reading for ISIS transmitter, considers the transmitter off
1667   4                                      if (g_uc_i2c_data_in[0] <= ISIS_TRN_ICON_LIMIT_WHEN_OFF && g_uc_i2c_data_in[1] == 0){
1668   5                                              //If we never do current monitoring before
1669   5                                              if (l_uc_itn_low_monitoring_counter < (ITN_CHECK-1))
1670   5                                                      //Increase the current monitoring value
1671   5                                                      l_uc_itn_low_monitoring_counter++;         
1672   5      
1673   5                                              //If we have done current monitoring sufficiently before
1674   5                                              else if (l_uc_itn_low_monitoring_counter >= (ITN_CHECK-1)){
1675   6                                                      //Reset the current monitoring value
1676   6                                                      l_uc_itn_low_monitoring_counter = 0;
1677   6      
1678   6                                                      //Reset the monitoring flag
1679   6                                                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_MONITOR;
1680   6              
1681   6                                                      //Reset recovery flag
1682   6                                                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_RECOVERY;
1683   6      
1684   6                                                      //Reset monitoring time
1685   6                                                      g_us_beacon_monitoring_time = 0;
1686   6              
1687   6                                                      //If there is a request from GSCH
1688   6                                                      if (str_obdh_hk.us_beacon_flag & BEACON_FLAG_GSCH_SEND_ACK){
1689   7                                                              //Reset ACK flag
1690   7                                                              str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_GSCH_SEND_ACK;
1691   7              
1692   7                                                              //Set GSCH complete flag
1693   7                                                              str_obdh_hk.us_beacon_flag |= BEACON_FLAG_GSCH_SEND_COMPLETED;
1694   7                                                      }
1695   6                                              }
1696   5                                      }
1697   4                                      //If not completed, maybe needs to see if there is a need for a timeout
1698   4                                      //If there is a transmission which is too long, try to do the recovery attempt first
1699   4                                      //If recovery attempt is not successful, terminates the monitoring, marks it as erroneous
1700   4                                      else if (g_us_beacon_monitoring_time > (2*g_us_expected_no_of_itn_checking_per_transmission)){                                  
1701   5                                              //If recovery attempt has never been done
1702   5                                              if (!(str_obdh_hk.us_beacon_flag & BEACON_FLAG_RECOVERY)){
1703   6                                                      //Set recovery flag
1704   6                                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_RECOVERY;
1705   6      
1706   6                                                      //Recovery attempt
1707   6                                                      l_us_error_code[0] = overlyLongTransmissionRecovery();
1708   6      
1709   6                                                      //If recovery attempt is unsuccessful, set the beacon as erroneous
1710   6                                                      if (l_us_error_code[0]){
1711   7      
1712   7                                                              #if (EVENT_HANDLER_ENABLE == 1)
1713   7                                                              #if (STORING_ENABLE == 1)
1714   7                                                              eventHandler(EV_BEACON_HANDLER+EC_BEACON_FLAG_ERROR,str_obdh_hk.us_beacon_flag>>8,str_obdh_hk.us_be
             -acon_flag,
1715   7                                                                      g_us_beacon_monitoring_time>>8,g_us_beacon_monitoring_time,g_uc_beacon_retry_counter,(unsigned cha
             -r)l_us_error_code[0]);//dec22_yc track prior to error only as trsistion too fast
1716   7                                                              #endif
1717   7                                                              #endif
1718   7                                              
1719   7                                                              //Reset the current monitoring value
1720   7                                                              l_uc_itn_low_monitoring_counter = 0;
1721   7                      
1722   7                                                              //Reset retry counter
1723   7                                                              g_uc_beacon_retry_counter = 0;
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 30  

1724   7                      
1725   7                                                              //Reset monitoring time
1726   7                                                              g_us_beacon_monitoring_time = 0;
1727   7                      
1728   7                                                              //Set beacon to ERROR
1729   7                                                              str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_ERROR_SET_FILTER;
1730   7                                                              str_obdh_hk.us_beacon_flag |= BEACON_FLAG_ERROR;
1731   7                                                      }
1732   6                                                      //Else, if recovery attempt is successful, delay the checking for at most 6 seconds
1733   6                                                      if (g_us_beacon_monitoring_time > (6*NO_OF_BEACON_CHECK_PER_S))
1734   6                                                              g_us_beacon_monitoring_time -= 6*NO_OF_BEACON_CHECK_PER_S;
1735   6                                                      else g_us_beacon_monitoring_time = 0;
1736   6                                              }
1737   5                                              //If the recovery attempt has been done and it is still unsuccessful,
1738   5                                              //set the beacon as erroneous
1739   5                                              else {
1740   6      
1741   6                                                      #if (EVENT_HANDLER_ENABLE == 1)
1742   6                                                      #if (STORING_ENABLE == 1)
1743   6                                                      eventHandler(EV_BEACON_HANDLER+EC_BEACON_FLAG_ERROR,str_obdh_hk.us_beacon_flag>>8,str_obdh_hk.us_bea
             -con_flag,
1744   6                                                              g_us_beacon_monitoring_time>>8,g_us_beacon_monitoring_time,g_uc_beacon_retry_counter,0);//dec24_yc 
             -track prior to error only as trsistion too fast                                                                                                               
1745   6                                                      #endif
1746   6                                                      #endif
1747   6      
1748   6                                                      //Reset the current monitoring value
1749   6                                                      l_uc_itn_low_monitoring_counter = 0;
1750   6              
1751   6                                                      //Reset retry counter
1752   6                                                      g_uc_beacon_retry_counter = 0;
1753   6              
1754   6                                                      //Reset monitoring time
1755   6                                                      g_us_beacon_monitoring_time = 0;
1756   6              
1757   6                                                      //Set beacon to ERROR
1758   6                                                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_ERROR_SET_FILTER;
1759   6                                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_ERROR;
1760   6                                              }
1761   5                                      }
1762   4                                      //If the current level is high and it is not a timeout
1763   4                                      else 
1764   4                                              //Reset current monitor counter
1765   4                                              l_uc_itn_low_monitoring_counter = 0;
1766   4                              }
1767   3              
1768   3                              //Else, increase retry counter
1769   3                              else g_uc_beacon_retry_counter++;
1770   3                      }
1771   2      
1772   2                      //If currently it is not monitoring a sending or previous monitoring has just been completed
1773   2                      //and there is something to send due to GSCH
1774   2                      if ((str_obdh_hk.us_beacon_flag & BEACON_FLAG_REQUEST_FILTER) == BEACON_FLAG_REQUEST_CONDITION){
1775   3      
1776   3                              #if (GROUND_STATION_COMMAND_HANDLER_ENABLE == 1)
1777   3      
1778   3                              //Check its GSCH sending type, whether it is CW sending
1779   3                              if (str_obdh_hk.us_beacon_flag & BEACON_FLAG_GSCH_TYPE){
1780   4                                      //Send CW beacon
1781   4                                      g_us_beacon_send_error_code = isisI2CMsg(ITC_I2C_SND_CW_MSG,0,g_uc_cw_message_length,0);
1782   4                              }
1783   3      
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 31  

1784   3                              //Or it is AX.25 frame sending
1785   3                              else
1786   3                                      //Send whatever data that has been initialized
1787   3                                      g_us_beacon_send_error_code = sendData();
1788   3                      
1789   3                              //Check error code
1790   3                              if (!g_us_beacon_send_error_code){
1791   4                                      //If there is no error code, considers the sending as successful
1792   4                                      //Reset retry counter
1793   4                                      g_uc_beacon_retry_counter = 0;
1794   4      
1795   4                                      //Reset GSCH send request flag
1796   4                                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_GSCH_SEND_REQUEST;
1797   4      
1798   4                                      //Set monitoring flag
1799   4                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_MONITOR;
1800   4      
1801   4                                      //Reset monitoring time
1802   4                                      g_us_beacon_monitoring_time = 0;
1803   4      
1804   4                                      //Set ACK flag
1805   4                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_GSCH_SEND_ACK;
1806   4      
1807   4                              }
1808   3                              //Else, increase retry counter
1809   3                              else g_uc_beacon_retry_counter++;
1810   3                      
1811   3                              #endif                                  
1812   3                      }
1813   2      
1814   2                      //If the beacon is currently not in use by GSCH and the timeout flag is raised and auto-beacon is enable
             -d, send beacon
1815   2                      else if ((str_obdh_hk.us_beacon_flag & BEACON_FLAG_AUTO_BEACON_FILTER) == BEACON_FLAG_AUTO_BEACON_CONDIT
             -ION){
1816   3      
1817   3                              //Check beacon type
1818   3                              //If it is CW
1819   3                              if (str_obdh_hk.us_beacon_flag & BEACON_FLAG_TYPE){
1820   4                                      //If it is CW beacon sending, check its mode to initialize certain things
1821   4                                      groundInitCWBeacon(str_obdh_hk.us_beacon_flag & BEACON_FLAG_CW_MODE);
1822   4      
1823   4                                      //Send CW beacon
1824   4                                      g_us_beacon_send_error_code = isisI2CMsg(ITC_I2C_SND_CW_MSG,0,g_uc_cw_message_length,0);
1825   4      
1826   4                              }
1827   3      
1828   3                              //Else, if it is AX25
1829   3                              else{
1830   4                                      //Init AX25 beacon sending
1831   4                                      groundInitAX25Beacon();
1832   4                              
1833   4                                      //Sending data as requested
1834   4                                      g_us_beacon_send_error_code = sendData();                                       
1835   4                              }
1836   3      
1837   3                              //Check error code
1838   3                              if (!g_us_beacon_send_error_code){
1839   4                                      //If there is no error code, considers the sending as successful
1840   4                                      //Reset retry counter
1841   4                                      g_uc_beacon_retry_counter = 0;
1842   4      
1843   4                                      //Reset time since last sending value
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 32  

1844   4                                      g_uc_beacon_time_since_last_timeout_sending     = 0;
1845   4      
1846   4                                      //Reset timeout flag
1847   4                                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_TIMEOUT;
1848   4      
1849   4                                      //Set monitoring flag
1850   4                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_MONITOR;
1851   4      
1852   4                                      //Reset monitoring time
1853   4                                      g_us_beacon_monitoring_time = 0;
1854   4                              }
1855   3                              //Else, increase retry counter
1856   3                              else g_uc_beacon_retry_counter++;
1857   3                      }
1858   2              }
1859   1      
1860   1              //If for whatever reason, beacon retry counter is exceeding the limit,
1861   1              if (g_uc_beacon_retry_counter > BEACON_COMM_FAIL_LIMIT){
1862   2                      
1863   2                      #if (EVENT_HANDLER_ENABLE == 1)
1864   2                      #if (STORING_ENABLE == 1)
1865   2                      //dec22_yc tested
1866   2                      eventHandler(EV_BEACON_HANDLER+EC_BEACON_FLAG_ERROR,str_obdh_hk.us_beacon_flag>>8,str_obdh_hk.us_beacon_
             -flag,
1867   2                                                                      g_us_beacon_monitoring_time>>8,g_us_beacon_monitoring_time,g_uc_beacon_retry_counter,0);//dec22_yc
             - track prior to error only as trsistion too fast                              
1868   2                      #endif
1869   2                      #endif
1870   2      
1871   2                      //Reset retry counter
1872   2                      g_uc_beacon_retry_counter = 0;
1873   2      
1874   2                      //Reset monitoring time
1875   2                      g_us_beacon_monitoring_time = 0;
1876   2      
1877   2                      //Reset the current monitoring value
1878   2                      l_uc_itn_low_monitoring_counter = 0;
1879   2      
1880   2                      //Set beacon to ERROR
1881   2                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_ERROR_SET_FILTER;
1882   2                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_ERROR;
1883   2              }       
1884   1      }
1885          #endif
1886          #endif
1887          #endif
1888          
1889          #if (GROUND_STATION_COMMAND_HANDLER_ENABLE == 1)
1890          //------------------------------------------------------------------------------------
1891          // To handle ground station command event
1892          //------------------------------------------------------------------------------------
1893          // Function's test result: untested
1894          //------------------------------------------------------------------------------------
1895          //This funciton is noticed to have over 1600 lines, probably the most amusing function on VELOX-P code.
1896          void groundStationCommandHandler (void)
1897          {
1898   1              #if (ISIS_CMD_ENABLE == 1)
1899   1      
1900   1              unsigned short l_us_beacon_status;
1901   1              unsigned short l_us_reply_1;
1902   1              unsigned short l_us_reply_2;
1903   1              unsigned short l_us_data_id;
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 33  

1904   1              unsigned short l_us_init_send_error_code = EC_INIT;
1905   1              unsigned short l_us_i;
1906   1              unsigned short l_us_comm_error_code = EC_INIT;
1907   1      
1908   1              #if (ADCS_CMD_ENABLE == 1)
1909   1              unsigned short l_us_dummy;
1910   1              #endif
1911   1      
1912   1              //Check current GSCH state
1913   1              switch (str_obdh_hk.uc_gsch_state){
1914   2                      //When GSCH is idle
1915   2                      case GSCH_STATE_IDLE:
1916   2                              //Listen to GDSN command
1917   2                              groundCommandListener();
1918   2      
1919   2                              //If it has passed initial GSCH checking and the initial checking request for further checking
1920   2                              //Then do whatever necessary
1921   2                              if (g_uc_gsch_flag & GSCH_FLAG_VALID_COMMAND){
1922   3                                      //Reset GSCH checking flag
1923   3                                      g_uc_gsch_flag &= ~GSCH_FLAG_CHECK_RESET;
1924   3      
1925   3                                      //Starts to claim the beacon here to be used by GSCH (don't send anything automatically anymore)
1926   3                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_GSCH_CLAIM;
1927   3      
1928   3                                      //Go to the GSCH_STATE_GENERATING_KEY state
1929   3                                      str_obdh_hk.uc_gsch_state = GSCH_STATE_GENERATING_KEY;
1930   3                              }
1931   2      
1932   2                              break;
1933   2      
1934   2                      //When GSCH is generating key
1935   2                      case GSCH_STATE_GENERATING_KEY:
1936   2                              //Call groundPassRequestKeyGenerator
1937   2                              groundPassRequestKeyGenerator();
1938   2              
1939   2                              //Go to the GSCH_STATE_SEND_GENERATED_KEY state
1940   2                              str_obdh_hk.uc_gsch_state = GSCH_STATE_SEND_GENERATED_KEY;
1941   2      
1942   2                              //Set transitional period flag
1943   2                              g_uc_gsch_flag |= GSCH_FLAG_MONITOR_TRANSITIONAL;
1944   2      
1945   2                              #if (EVENT_HANDLER_ENABLE == 1)
1946   2                              #if (STORING_ENABLE == 1)
1947   2                              //dec22_yc .... track valid ground station cmd and processing status.  tested dec22_yc
1948   2                              eventHandler(EV_GSCH_MONITORING_TRANSITIONAL_FLAG_HANDLER,str_obdh_hk.uc_gsch_state,g_uc_gsch_gs_cmd_ta
             -il,
1949   2                                                                      g_uc_gsch_gs_arg[0],g_uc_gsch_gs_arg[1],g_us_gsch_gs_cmd_crc>>16,g_us_gsch_gs_cmd_crc);
1950   2                              #endif
1951   2                              #endif
1952   2      
1953   2                              break;
1954   2      
1955   2                      //When GSCH is sending generated key
1956   2                      case GSCH_STATE_SEND_GENERATED_KEY:
1957   2                              //For all transition state case, it is important to get latest beacon status
1958   2                              //Only proceeds when beacon is functional
1959   2                              if ((str_obdh_hk.us_beacon_flag & BEACON_FLAG_FILTER_PRIMARY) == BEACON_FUNCTIONAL){
1960   3                                      //If it is functional, check its case
1961   3                                      l_us_beacon_status = str_obdh_hk.us_beacon_flag & BEACON_FLAG_FILTER_SECONDARY;
1962   3      
1963   3                                      //Switch the case for beacon status
1964   3                                      switch (l_us_beacon_status){
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 34  

1965   4                                              //There are only four valid cases
1966   4                                              //First, beacon is free, initiates transmission here
1967   4                                              case BEACON_FREE:
1968   4                                                      #if (SENDING_ENABLE == 1)
1969   4                                                      #if (ISIS_CMD_ENABLE == 1)
1970   4                                                      sendKeyRequest();
1971   4                                                      #endif
1972   4                                                      #endif
1973   4                                                      break;
1974   4              
1975   4                                              //Second, beacon is busy of other sending task, do nothing
1976   4                                              //Third, beacon is currently sending your request, do nothing too
1977   4                                              //If the sending has gone too long, however, terminates the requets
1978   4                                              //Go back to idle state
1979   4                                              case BEACON_BUSY_1:
1980   4                                              case BEACON_BUSY_2:
1981   4                                              case BEACON_SENDING:
1982   4                                              case BEACON_WAITING:
1983   4                                                      break;
1984   4              
1985   4                                              //Fourth, beacon sending is completed                                   
1986   4                                              case BEACON_SEND_COMPLETED:
1987   4                                                      #if (SENDING_ENABLE == 1)
1988   4                                                      //Release beacon's claim
1989   4                                                      groundReleaseClaimBeacon();
1990   4                                                      #endif
1991   4      
1992   4                                                      //Go to the next state, waiting for key reply
1993   4                                                      str_obdh_hk.uc_gsch_state = GSCH_STATE_WAITING_FOR_KEY_REPLY;
1994   4                                                      break;
1995   4              
1996   4                                              //Besides the above cases, something wrong with the beacon, terminates the sending
1997   4                                              default:
1998   4                                                      //Terminates transitional states
1999   4                                                      groundTerminateTransitionalState();
2000   4                      
2001   4                                                      //Go back to idle state
2002   4                                                      str_obdh_hk.uc_gsch_state = GSCH_STATE_IDLE;
2003   4                                                      break;
2004   4                                      }
2005   3                              }
2006   2                              //If beacon is not found to be functional at this stage, return to idle
2007   2                              else {
2008   3                                      //Terminates transitional states
2009   3                                      groundTerminateTransitionalState();
2010   3      
2011   3                                      //Go back to idle state
2012   3                                      str_obdh_hk.uc_gsch_state = GSCH_STATE_IDLE;
2013   3                              }
2014   2      
2015   2                              //If at any point timeout for monitoring occurs
2016   2                              if (g_us_gsch_monitoring_transitional_period > TIME_LIMIT_GSCH_TRANSITIONAL_STATE_S){
2017   3                                      //Terminates transitional states
2018   3                                      groundTerminateTransitionalState();
2019   3      
2020   3                                      //Go back to idle state
2021   3                                      str_obdh_hk.uc_gsch_state = GSCH_STATE_IDLE;
2022   3                              } 
2023   2                              break;
2024   2      
2025   2                      //When GSCH is waiting for key reply
2026   2                      case GSCH_STATE_WAITING_FOR_KEY_REPLY:
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 35  

2027   2                              //Listen to GDSN command
2028   2                              groundCommandListener();
2029   2      
2030   2                              //If it has passed initial GSCH checking and the initial checking request for further checking
2031   2                              //Then do whatever necessary
2032   2                              if (g_uc_gsch_flag & GSCH_FLAG_VALID_COMMAND){
2033   3                                      //Reset GSCH checking flag
2034   3                                      g_uc_gsch_flag &= ~GSCH_FLAG_CHECK_RESET;
2035   3      
2036   3                                      //Check what command is sent
2037   3                                      //Check the command content
2038   3                                      switch (g_uc_gsch_gs_cmd_tail){
2039   4                                              case GDSN_REQUEST_GDPASS:
2040   4                                                      //Reset transitional state monitoring period
2041   4                                                      g_us_gsch_monitoring_transitional_period = 0;
2042   4      
2043   4                                                      //Starts to claim the beacon here to be used by GSCH (don't send anything automatically anymore)
2044   4                                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_GSCH_CLAIM;
2045   4                      
2046   4                                                      //Go to the GSCH_STATE_GENERATING_KEY state
2047   4                                                      str_obdh_hk.uc_gsch_state = GSCH_STATE_GENERATING_KEY;
2048   4                                                      break;
2049   4      
2050   4                                              case GDSN_SEND_GDPASS_CODE:
2051   4                                                      //Reset transitional state monitoring period
2052   4                                                      g_us_gsch_monitoring_transitional_period = 0;
2053   4      
2054   4                                                      //Check the key reply
2055   4                                                      l_us_reply_1 = (unsigned short)(g_uc_gsch_gs_arg[0] << 8) + g_uc_gsch_gs_arg[1];
2056   4                                                      l_us_reply_2 = (unsigned short)(g_uc_gsch_gs_arg[2] << 8) + g_uc_gsch_gs_arg[3];
2057   4      
2058   4                                                      //If the key reply is correct, enters ground pass state
2059   4                                                      //Else, keeps waiting in this state
2060   4                                                      if ((g_us_gsch_answer_1 == l_us_reply_1) && (g_us_gsch_answer_2 == l_us_reply_2)){
2061   5                                                              //Enter Groundpass
2062   5                                                              enterGroundPass();
2063   5      
2064   5                                                              //Always successful
2065   5                                                              g_us_gsch_error_code = EC_SUCCESSFUL;
2066   5      
2067   5                                                              #if (SENDING_ENABLE == 1)
2068   5                                                              //Send ACK MSG
2069   5                                                              sendAckMsg();
2070   5                                                              #endif
2071   5                                                      }
2072   4      
2073   4                                                      break;
2074   4      
2075   4                                              //Invalid command will be ignored, but monitoring period will not be reset
2076   4                                              default:
2077   4                                                      break;
2078   4                                      }
2079   3                              }
2080   2      
2081   2                              //If at any point timeout for monitoring occurs
2082   2                              if (g_us_gsch_monitoring_transitional_period > TIME_LIMIT_GSCH_TRANSITIONAL_STATE_S){
2083   3                                      //Terminates transitional states
2084   3                                      groundTerminateTransitionalState();
2085   3      
2086   3                                      //Go back to idle state
2087   3                                      str_obdh_hk.uc_gsch_state = GSCH_STATE_IDLE;
2088   3                              } 
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 36  

2089   2                              break;
2090   2      
2091   2                      //When GSCH is in the groundpass mode
2092   2                      case GSCH_STATE_GROUND_PASS:
2093   2                              //In the ground pass state, all sending and loading can be reinitialized
2094   2                              g_uc_strsnd_flag &= ~SNDNG_FLAG_COMPLETED;
2095   2                              g_uc_strsnd_flag &= ~STRNG_FLAG_SD_LOAD_COMPLETED;
2096   2                              g_uc_strsnd_flag &= ~STRNG_FLAG_SAVE_DATA_HOLD;
2097   2                              g_uc_sd_load_data_timeout_counter = TIME_LIMIT_LOAD_DATA_S;
2098   2                              g_uc_save_data_hold_timeout_counter = 0;
2099   2                              g_uc_gsch_flag &= ~GSCH_FLAG_TOTAL_SENDING;
2100   2                              g_us_gsch_total_sending_time = 0;
2101   2      
2102   2                              //If it is within the time limit, stays in this state
2103   2                              if (g_us_groundpass_time_register < TIME_LIMIT_GROUND_PASS_S){
2104   3                                      //In this groundpass mode, commands will be received directly from the ground station.
2105   3                                      //For every command received, GSCH will first check its validity
2106   3                                      //If the command is valid, only two possible types of command will be recognized here:
2107   3                                      // 1) If this is command to be run by the command control module (0x0000-0x02FF && 0x0400-0xD0FF)
2108   3                                      // 2) If this command is special ground station command
2109   3                                      //
2110   3                                      //For the type (1) of the command, the only restriction here is if the argument length is more than 10
             - bytes
2111   3                                      // then, the command will not be executed
2112   3                                      //
2113   3                                      //For the type (2) of the command, various scenario is possible. Most difficult one will be when GDSN
2114   3                                      // wants to get some data sending down, then difficulties come...
2115   3      
2116   3                                      //If there is sufficient power, proceeds, else, terminates Ground Pass
2117   3                                      //Go to idle state
2118   3                                      if (str_obdh_data.uc_batt_soc >= str_obdh_par.uc_soc_threshold[3]){
2119   4                                              //Listen to GDSN command
2120   4                                              groundCommandListener();
2121   4                      
2122   4                                              //If it has passed initial GSCH checking and the initial checking request for further checking
2123   4                                              //Then do whatever necessary
2124   4                                              if (g_uc_gsch_flag & GSCH_FLAG_VALID_COMMAND){
2125   5                                                      //Reset GSCH checking flag
2126   5                                                      g_uc_gsch_flag &= ~GSCH_FLAG_CHECK_RESET;
2127   5      
2128   5                                                      //Reset g_us_groundpass_time_register upon receiving successful command
2129   5                                                      g_us_groundpass_time_register = TIME_RESET_GROUND_PASS_S;
2130   5                      
2131   5                                                      //Here classification of the commands occur
2132   5                                                      //First, if the command is to be run by command control module,
2133   5                                                      //It will be straight forward
2134   5                                                      //Only available when manual mode is turned ON
2135   5                                                      if (((g_uc_gsch_gs_cmd_header >= 0x00 && g_uc_gsch_gs_cmd_header <= 0x02) || (g_uc_gsch_gs_cmd_heade
             -r >= 0x04 && g_uc_gsch_gs_cmd_header <= 0xD0)) && (str_obdh_par.uc_manual_control_enabled == 0xff)){
2136   6                                                              #if (CQUEUE_ENABLE == 1)
                                                                      //Insert whatever command given (unfiltered) to the command queue
                                                                      insertGSCHCommandToQueue();
              
                                                                      #if (SENDING_ENABLE == 1)
                                                                      #if (ISIS_CMD_ENABLE == 1)
                                                                      //Always successful
                                                                      g_us_gsch_error_code = EC_SUCCESSFUL;
              
                                                                      //Send acknowledgement message
                                                                      sendAckMsg();
                                                                      #endif
                                                                      #endif
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 37  

                                                                      #else
2150   6                                                              //Insert the commands to the call task buffer
2151   6                                                              g_uc_call_task_buffer[0] = 0xBB;
2152   6                                                              g_uc_call_task_buffer[1] = g_uc_gsch_gs_cmd_header;
2153   6                                                              g_uc_call_task_buffer[2] = g_uc_gsch_gs_cmd_tail;
2154   6                                                              g_uc_call_task_buffer[3] = 0x00;
2155   6                                                              g_uc_call_task_buffer[4] = g_uc_gsch_gs_arg_len;
2156   6                                                              
2157   6                                                              //Insert command's argument (if any)
2158   6                                                              for (l_us_i = 0; l_us_i < g_uc_gsch_gs_arg_len; l_us_i++)
2159   6                                                                      g_uc_call_task_buffer[l_us_i+COMMAND_HEADER_SIZE+1] = g_uc_gsch_gs_arg[l_us_i];
2160   6      
2161   6                                                              #if (EVENT_HANDLER_ENABLE == 1)
2162   6                                                              #if (STORING_ENABLE == 1)
2163   6                                                              //dec22_yc here add even logging for command added to queue tested                      
2164   6                                                              eventHandler(EV_MCC_TO_COMMAND,g_uc_gsch_gs_cmd_header,g_uc_gsch_gs_cmd_tail,
2165   6                                                                              g_uc_call_task_buffer[COMMAND_HEADER_SIZE+1],g_uc_call_task_buffer[COMMAND_HEADER_SIZE+2],g_uc_ca
             -ll_task_buffer[COMMAND_HEADER_SIZE+3],g_uc_call_task_buffer[COMMAND_HEADER_SIZE+4]);
2166   6                                                              #endif
2167   6                                                              #endif
2168   6                                                      
2169   6                                                              //Runs the command directly by calling functionModule
2170   6                                                              functionModule (g_uc_call_task_buffer, g_uc_call_task_buffer);
2171   6      
2172   6                                                              #if (SENDING_ENABLE == 1)
2173   6                                                              #if (ISIS_CMD_ENABLE == 1)
2174   6                                                              //Get function module error code
2175   6                                                              g_us_gsch_error_code = g_us_function_module_error_code;
2176   6      
2177   6                                                              //Send acknowledgement message
2178   6                                                              sendAckMsg();
2179   6                                                              #endif
2180   6                                                              #endif
2181   6                                                              #endif
2182   6                                                      }
2183   5      
2184   5                                                      //Else, if the command is not to be run by command control module, but by GSCH
2185   5                                                      //Then more complex task there will be...
2186   5                                                      else if (g_uc_gsch_gs_cmd_header == GDSN_ADDR){
2187   6                                                              //If the command is special GDSN command, we have a switch case here...
2188   6                                                              //The special GDSN command will mainly deal with sending command
2189   6                                                              //Because, if it is not sending, there is no point to access this command
2190   6                                                              //For any valid command, there will be acknowledgement sent by the satellite (not yet)
2191   6                                                              switch (g_uc_gsch_gs_cmd_tail){
2192   7                                                                      #if (SENDING_ENABLE == 1)
2193   7                                                                      #if (ISIS_CMD_ENABLE == 1)
2194   7                                                                      //Here, all possible cases will MCC-OBC communication will be considered
2195   7                                                                      //GDSN_REQUEST_GDPASS and GDSN_SEND_GDPASS_CODE will be ignored
2196   7                                                                      //Send current HK in the temporary buffer
2197   7                                                                      case GDSN_GET_ALL_HK:
2198   7                                                                              //Send real time HK
2199   7                                                                              sendCommonData(SD_HK);
2200   7                                                                              break;
2201   7      
2202   7                                                                      //Send current SSCP in the temporary buffer
2203   7                                                                      case GDSN_GET_ALL_SSCP:
2204   7                                                                              //Send real time SSCP
2205   7                                                                              sendCommonData(SD_SSCP);
2206   7                                                                              break;
2207   7      
2208   7                                                                      //Get whatever data sets under specified category
2209   7                                                                      case GDSN_GET_DATA_SET:
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 38  

2210   7                                                                              //Always successful
2211   7                                                                              g_us_gsch_error_code = EC_SUCCESSFUL;
2212   7      
2213   7                                                                              //Indicates taking data from temporary buffer
2214   7                                                                              g_uc_ax25_header_package_property = 0x00;
2215   7      
2216   7                                                                              //Taking the data initialization from the command argument
2217   7                                                                              g_uc_ax25_header_subsystem = OBDH_SUBSYSTEM;
2218   7                                                                              g_uc_ax25_header_data_type = SD_FREE_CATEGORY;
2219   7      
2220   7                                                                              //Initialize sending data under free category
2221   7                                                                              g_uc_no_of_data_sent = (str_obdh_data.uc_no_of_data_cat_sent+1);
2222   7      
2223   7                                                                              //Just another error prevention
2224   7                                                                              if (g_uc_no_of_data_sent > MAX_DATA_CAT_TO_BE_SENT_FREELY)
2225   7                                                                                      g_uc_no_of_data_sent = MAX_DATA_CAT_TO_BE_SENT_FREELY;
2226   7      
2227   7                                                                              //The first data set sent is always ACK_MSG
2228   7                                                                              g_uc_data_type_sent_buffer[0] = DATA_CAT_ACK_MSG;
2229   7      
2230   7                                                                              //Fill whatever category requested (theoretically, maximum of nine)
2231   7                                                                              for (l_us_i = 0; l_us_i < g_uc_no_of_data_sent; l_us_i++)
2232   7                                                                                      g_uc_data_type_sent_buffer[l_us_i+1] = g_uc_gsch_gs_arg[l_us_i];
2233   7      
2234   7                                                                              //Initialized sending data (once only)
2235   7                                                                              l_us_init_send_error_code = initSendData();
2236   7      
2237   7                                                                              //If there is unaccepted initialization error, do not proceed (re-take new command)
2238   7                                                                              //Else, proceeds to GSCH_STATE_SEND_REAL_TIME_DATA state
2239   7                                                                              if(!l_us_init_send_error_code || l_us_init_send_error_code == EC_INVALID_SENDING_DATA_REQUEST)
2240   7                                                                                      //Send real-time data
2241   7                                                                                      groundEnterSendRealTime();                                                                      
2242   7                                                                              break;
2243   7      
2244   7                                                                      //Get whatever data under GDSN request
2245   7                                                                      //Here, we execute directly command to get data
2246   7                                                                      case GDSN_GET_DATA:
2247   7                                                                              //Get the data ID requested
2248   7                                                                              l_us_data_id = ((unsigned short)g_uc_gsch_gs_arg[0] << 8) + g_uc_gsch_gs_arg[1];
2249   7      
2250   7                                                                              //See whether it is PWRS or ADCS data requested
2251   7                                                                              //If it is ADCS data
2252   7                                                                              if (g_uc_gsch_gs_arg[0] == ADCS_ADDR){
2253   8                                                                                      #if (ADCS_CMD_ENABLE == 1)
2254   8                                                                                      #if (DEBUGGING_FEATURE == 1)
2255   8                                                                                      g_us_gsch_error_code = adcsGetData(g_uc_gsch_gs_arg[1],0);
2256   8                                                                                      #else
                                                                                              g_us_gsch_error_code = adcsGetData(g_uc_gsch_gs_arg[1]);
                                                                                              #endif
2259   8                                                                                      #else
                                                                                              g_us_gsch_error_code = EC_ADCS_CMD_DISABLED;
                                                                                              #endif
2262   8                                                                              }
2263   7      
2264   7                                                                              //If it is PWRS data
2265   7                                                                              else if (g_uc_gsch_gs_arg[0] == PWRS_ADDR){
2266   8                                                                                      #if (PWRS_CMD_ENABLE == 1)
2267   8                                                                                      #if (DEBUGGING_FEATURE == 1)
2268   8                                                                                      g_us_gsch_error_code = pwrsGetData(g_uc_gsch_gs_arg[1],0);
2269   8                                                                                      #else
                                                                                              g_us_gsch_error_code = pwrsGetData(g_uc_gsch_gs_arg[1]);
                                                                                              #endif
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 39  

2272   8                                                                                      #else
                                                                                              g_us_gsch_error_code = EC_PWRS_CMD_DISABLED;
                                                                                              #endif
2275   8                                                                              }
2276   7      
2277   7                                                                              //If it is neither
2278   7                                                                              else g_us_gsch_error_code = EC_INVALID_GDSN_GET_DATA_REQUEST;
2279   7      
2280   7                                                                              //Send real time single data
2281   7                                                                              sendCommonData(SD_SINGLE_SUBSYSTEM_DATA);
2282   7                                                                              break;
2283   7                                                                      #endif
2284   7                                                                      #endif
2285   7      
2286   7                                                                      //Set an SSCP data of a subsystem
2287   7                                                                      case GDSN_SET_SSCP:
2288   7                                                                              //Time window validation check
2289   7                                                                              timeWindowCheck();
2290   7      
2291   7                                                                              //Only proccess the command if it passes time window validation
2292   7                                                                              if (g_uc_gsch_flag & GSCH_FLAG_TIME_WINDOW_VALID){
2293   8                                                                                      //Get the data ID requested
2294   8                                                                                      l_us_data_id = ((unsigned short)g_uc_gsch_gs_arg[0] << 8) + g_uc_gsch_gs_arg[1];
2295   8              
2296   8                                                                                      //See whether it is OBDH, PWRS, or ADCS request
2297   8                                                                                      //If it is OBDH request
2298   8                                                                                      if (g_uc_gsch_gs_arg[0] == OBDH_ADDR)
2299   8                                                                                              //Change whatever OBDH's SSCP desired to be changed
2300   8                                                                                              changeData(l_us_data_id,g_uc_gsch_gs_arg[2],g_uc_gsch_gs_arg[3],g_uc_gsch_gs_arg[4],g_uc_gsch_g
             -s_arg[5]);
2301   8              
2302   8                                                                                      //If it is ADCS request
2303   8                                                                                      else if (g_uc_gsch_gs_arg[0] == ADCS_ADDR){
2304   9                                                                                              #if (ADCS_CMD_ENABLE == 1)
2305   9                                                                                              //Check the data ID
2306   9                                                                                              switch (l_us_data_id){
2307  10                                                                                                      //To set DATA_ADCS_PAR_S_SS_THRESHOLD
2308  10                                                                                                      case DATA_ADCS_PAR_S_SS_THRESHOLD:
2309  10                                                                                                              l_us_dummy = (unsigned short)(g_uc_gsch_gs_arg[4] << 8) + g_uc_gsch_gs_arg[5];
2310  10                                                                                                              #if (DEBUGGING_FEATURE == 1)
2311  10                                                                                                              g_us_gsch_error_code = adcsSetSSThreshold(l_us_dummy,0);
2312  10                                                                                                              #else
                                                                                                                      g_us_gsch_error_code = adcsSetSSThreshold(l_us_dummy);
                                                                                                                      #endif
2315  10                                                                                                              break;
2316  10                                                                                                      
2317  10                                                                                                      //To set DATA_ADCS_PAR_F_CGAIN_1 to DATA_ADCS_PAR_F_CGAIN_18,
2318  10                                                                                                      //DATA_ADCS_PAR_F_TLE_EPOCH, DATA_ADCS_PAR_F_TLE_INC,
2319  10                                                                                                      //DATA_ADCS_PAR_F_TLE_RAAN, DATA_ADCS_PAR_F_TLE_ARG_PER,
2320  10                                                                                                      //DATA_ADCS_PAR_F_TLE_ECC, DATA_ADCS_PAR_F_TLE_MA, DATA_ADCS_PAR_US_TLE_MM 
2321  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_1:
2322  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_2:
2323  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_3:
2324  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_4:
2325  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_5:
2326  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_6:
2327  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_7:
2328  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_8:
2329  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_9:
2330  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_10:
2331  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_11:
2332  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_12:
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 40  

2333  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_13:
2334  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_14:
2335  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_15:
2336  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_16:
2337  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_17:
2338  10                                                                                                      case DATA_ADCS_PAR_F_CGAIN_18:
2339  10                                                                                                      case DATA_ADCS_PAR_F_TLE_EPOCH:
2340  10                                                                                                      case DATA_ADCS_PAR_F_TLE_INC:
2341  10                                                                                                      case DATA_ADCS_PAR_F_TLE_RAAN:
2342  10                                                                                                      case DATA_ADCS_PAR_F_TLE_ARG_PER:
2343  10                                                                                                      case DATA_ADCS_PAR_F_TLE_ECC:
2344  10                                                                                                      case DATA_ADCS_PAR_F_TLE_MA:
2345  10                                                                                                              changeData(l_us_data_id,g_uc_gsch_gs_arg[2],g_uc_gsch_gs_arg[3],g_uc_gsch_gs_arg[4],g_uc_gsch
             -_gs_arg[5]);
2346  10                                                                                                              g_us_gsch_error_code = EC_SUCCESSFUL;
2347  10                                                                                                              break;
2348  10                                                                                                      
2349  10                                                                                                      case DATA_ADCS_PAR_US_TLE_MM:
2350  10                                                                                                              changeData(l_us_data_id,g_uc_gsch_gs_arg[2],g_uc_gsch_gs_arg[3],g_uc_gsch_gs_arg[4],g_uc_gsch
             -_gs_arg[5]);
2351  10                                                                                                              g_f = (unsigned short)(g_uc_gsch_gs_arg[4] << 8) + g_uc_gsch_gs_arg[5];
2352  10                                                                                                              g_f = (g_f/26214.0) + 13.7;
2353  10                                                                                                              str_obdh_par.us_rev_time_s = NO_OF_SECOND_PER_DAY/g_f;
2354  10                                                                                                              g_us_gsch_error_code = EC_SUCCESSFUL;
2355  10                                                                                                              break;
2356  10                                                                                                      
2357  10                                                                                                      //To set DATA_ADCS_PAR_UL_TIME
2358  10                                                                                                      case DATA_ADCS_PAR_UL_TIME:
2359  10                                                                                                              #if (DEBUGGING_FEATURE == 1)
2360  10                                                                                                              g_us_gsch_error_code = adcsSetTime(uchar2ulong(g_uc_gsch_gs_arg[2],g_uc_gsch_gs_arg[3],g_uc_g
             -sch_gs_arg[4],g_uc_gsch_gs_arg[5]),0);
2361  10                                                                                                              #else
                                                                                                                      g_us_gsch_error_code = adcsSetTime(uchar2ulong(g_uc_gsch_gs_arg[2],g_uc_gsch_gs_arg[3],g_uc_g
             -sch_gs_arg[4],g_uc_gsch_gs_arg[5]));
                                                                                                                      #endif
2364  10                                                                                                              break;
2365  10                                                                                                      
2366  10                                                                                                      //To set DATA_ADCS_PAR_S_VECTOR_2SUN_X, DATA_ADCS_PAR_S_VECTOR_2SUN_Y
2367  10                                                                                                      //DATA_ADCS_PAR_S_VECTOR_2SUN_Z
2368  10                                                                                                      case DATA_ADCS_PAR_S_VECTOR_2SUN_X:
2369  10                                                                                                      case DATA_ADCS_PAR_S_VECTOR_2SUN_Y:
2370  10                                                                                                      case DATA_ADCS_PAR_S_VECTOR_2SUN_Z:
2371  10                                                                                                              changeData(l_us_data_id,0,0,g_uc_gsch_gs_arg[4],g_uc_gsch_gs_arg[5]);
2372  10                                                                                                              #if (DEBUGGING_FEATURE == 1)
2373  10                                                                                                              g_us_gsch_error_code = adcsSetVectorAlignToSun(0);
2374  10                                                                                                              #else
                                                                                                                      g_us_gsch_error_code = adcsSetVectorAlignToSun();
                                                                                                                      #endif
2377  10                                                                                                              break;
2378  10                                                                                                      
2379  10                                                                                                      
2380  10                                                                                                      //To set DATA_ADCS_PAR_C_CTRL_BR_X, DATA_ADCS_PAR_C_CTRL_BR_Y
2381  10                                                                                                      //DATA_ADCS_PAR_C_CTRL_BR_Z
2382  10                                                                                                      case DATA_ADCS_PAR_C_CTRL_BR_X:
2383  10                                                                                                      case DATA_ADCS_PAR_C_CTRL_BR_Y:
2384  10                                                                                                      case DATA_ADCS_PAR_C_CTRL_BR_Z:
2385  10                                                                                                              changeData(l_us_data_id,0,0,0,g_uc_gsch_gs_arg[5]);
2386  10                                                                                                              #if (DEBUGGING_FEATURE == 1)
2387  10                                                                                                              g_us_gsch_error_code = adcsSetBodyRate(str_adcs_par.c_ctrl_br[0],str_adcs_par.c_ctrl_br[1],st
             -r_adcs_par.c_ctrl_br[2],0);
2388  10                                                                                                              #else
                                                                                                                      g_us_gsch_error_code = adcsSetBodyRate(str_adcs_par.c_ctrl_br[0],str_adcs_par.c_ctrl_br[1],st
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 41  

             -r_adcs_par.c_ctrl_br[2]);
                                                                                                                      #endif
2391  10                                                                                                              break;
2392  10                                                                                                      
2393  10                                                                                                      //To set DATA_ADCS_PAR_S_DGAIN
2394  10                                                                                                      case DATA_ADCS_PAR_S_DGAIN:
2395  10                                                                                                              str_adcs_par.s_dgain = (unsigned short)(g_uc_gsch_gs_arg[4] << 8) + g_uc_gsch_gs_arg[5];
2396  10                                                                                                              #if (DEBUGGING_FEATURE == 1)
2397  10                                                                                                              g_us_gsch_error_code = adcsSetDGain(str_adcs_par.s_dgain,0);
2398  10                                                                                                              #else
                                                                                                                      g_us_gsch_error_code = adcsSetDGain(str_adcs_par.s_dgain);
                                                                                                                      #endif
2401  10                                                                                                              break;
2402  10                                                                                                      
2403  10                                                                                                      //If it is not in the SSCP list, return error code
2404  10                                                                                                      default:
2405  10                                                                                                              g_us_gsch_error_code = EC_INVALID_GDSN_SET_ADCS_SSCP_REQUEST;
2406  10                                                                                                              break;                                                                                  
2407  10                                                                                              }
2408   9                                                                                              #else
                                                                                                      g_us_gsch_error_code = EC_ADCS_CMD_DISABLED;
                                                                                                      #endif
2411   9                                                                                      }
2412   8              
2413   8                                                                                      //If it is PWRS request
2414   8                                                                                      else if (g_uc_gsch_gs_arg[0] == PWRS_ADDR){
2415   9                                                                                              #if (PWRS_CMD_ENABLE == 1)
2416   9                                                                                              //Check the data ID
2417   9                                                                                              switch (l_us_data_id){
2418  10              
2419  10                                                                                                      //To set DATA_PWRS_PAR_UC_MPPT_MODE
2420  10                                                                                                      case DATA_PWRS_PAR_UC_MPPT_MODE:
2421  10                                                                                                              #if (DEBUGGING_FEATURE == 1)
2422  10                                                                                                              g_us_gsch_error_code = pwrsSetMPPTMode(g_uc_gsch_gs_arg[5],0);
2423  10                                                                                                              #else
                                                                                                                      g_us_gsch_error_code = pwrsSetMPPTMode(g_uc_gsch_gs_arg[5]);
                                                                                                                      #endif
2426  10                                                                                                              break;
2427  10                                                                                                      
2428  10                                                                                                      //To set DATA_PWRS_PAR_UC_BATT_HEATER
2429  10                                                                                                      case DATA_PWRS_PAR_UC_BATT_HEATER:
2430  10                                                                                                              #if (DEBUGGING_FEATURE == 1)
2431  10                                                                                                              g_us_gsch_error_code = pwrsUpdateBatteryHeater(g_uc_gsch_gs_arg[5],0);
2432  10                                                                                                              #else
                                                                                                                      g_us_gsch_error_code = pwrsUpdateBatteryHeater(g_uc_gsch_gs_arg[5]);
                                                                                                                      #endif
2435  10                                                                                                              break;
2436  10                                                                                                      
2437  10                                                                                                      //To set DATA_PWRS_PAR_UC_BATT_CHARGE_UPP_LIMIT and DATA_PWRS_PAR_UC_BATT_CHARGE_LOW_LIMIT
2438  10                                                                                                      case DATA_PWRS_PAR_UC_BATT_CHARGE_UPP_LIMIT:
2439  10                                                                                                      case DATA_PWRS_PAR_UC_BATT_CHARGE_LOW_LIMIT:
2440  10                                                                                                              changeData(l_us_data_id,0,0,0,g_uc_gsch_gs_arg[5]);
2441  10                                                                                                              #if (DEBUGGING_FEATURE == 1)
2442  10                                                                                                              g_us_gsch_error_code = pwrsSetSOCLimit(str_pwrs_par.uc_batt_charge_upp_limit,str_pwrs_par.uc_
             -batt_charge_low_limit,0);
2443  10                                                                                                              #else
                                                                                                                      g_us_gsch_error_code = pwrsSetSOCLimit(str_pwrs_par.uc_batt_charge_upp_limit,str_pwrs_par.uc_
             -batt_charge_low_limit);
                                                                                                                      #endif
2446  10                                                                                                              break;
2447  10      
2448  10                                                                                                      //To set DATA_PWRS_US_PV_FV_1, DATA_PWRS_US_PV_FV_2, DATA_PWRS_US_PV_FV_3
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 42  

2449  10                                                                                                      case DATA_PWRS_US_PV_FV_1:
2450  10                                                                                                      case DATA_PWRS_US_PV_FV_2:
2451  10                                                                                                      case DATA_PWRS_US_PV_FV_3:
2452  10                                                                                                              changeData(l_us_data_id,0,0,g_uc_gsch_gs_arg[4],g_uc_gsch_gs_arg[5]);
2453  10                                                                                                              #if (DEBUGGING_FEATURE == 1)
2454  10                                                                                                              g_us_gsch_error_code = pwrsSetPVVolt(0);
2455  10                                                                                                              #else
                                                                                                                      g_us_gsch_error_code = pwrsSetPVVolt();
                                                                                                                      #endif
2458  10                                                                                                              break;                                                                                  
2459  10                                                                                                                                                                                              
2460  10                                                                                                      //If it is not in the SSCP list, return error code
2461  10                                                                                                      default:
2462  10                                                                                                              g_us_gsch_error_code = EC_INVALID_GDSN_SET_PWRS_SSCP_REQUEST;
2463  10                                                                                                              break;                                                                                  
2464  10                                                                                              }
2465   9                                                                                              #else
                                                                                                      g_us_gsch_error_code = EC_PWRS_CMD_DISABLED;
                                                                                                      #endif
2468   9                                                                                      }
2469   8              
2470   8                                                                                      //If it is not among the possibilities
2471   8                                                                                      else g_us_gsch_error_code = EC_INVALID_GDSN_SET_SSCP_REQUEST;
2472   8              
2473   8                                                                                      #if (SENDING_ENABLE == 1)
2474   8                                                                                      //Save essential state and send acknowledgement
2475   8                                                                                      groundSaveEssentialAndAck();
2476   8                                                                                      #endif
2477   8                                                                              }
2478   7                                                                                      
2479   7                                                                              break;
2480   7      
2481   7                                                                      #if (SENDING_ENABLE == 1)
2482   7                                                                      #if (ISIS_CMD_ENABLE == 1)
2483   7                                                                      //Get WOD data based on orbit
2484   7                                                                      case GDSN_GET_WOD:
2485   7                                                                              //Search proper block pointer based on the orbit requested
2486   7                                                                              g_us_obs_first_orbit_request    = (unsigned short)(g_uc_gsch_gs_arg[0] << 8) + g_uc_gsch_gs_arg[1];
2487   7                                                                              g_us_obs_last_orbit_request     = g_us_obs_first_orbit_request;
2488   7                                                                              #if (STORING_ENABLE == 1)
2489   7                                                                              g_us_gsch_error_code                    = searchBPByOrbitInfo(SD_HK);
2490   7                                                                              #else
                                                                                      g_us_gsch_error_code                    = EC_STORING_FUNCTIONS_ARE_DISABLED;
                                                                                      #endif
2493   7      
2494   7                                                                              //If there is initialization error, do not proceed
2495   7                                                                              //Else, proceeds to GSCH_STATE_SEND_STORED_DATA state
2496   7                                                                              if(!g_us_gsch_error_code){
2497   8                                                                                      //Indicates taking data from SD card
2498   8                                                                                      g_uc_ax25_header_package_property = AX25_HEADER_PROPERTY_STORED_DATA_BIT;
2499   8      
2500   8                                                                                      //Set current package no to 1
2501   8                                                                                      g_uc_ax25_header_no_of_this_package = 1;
2502   8      
2503   8                                                                                      //Initialize subsystem and data type to load
2504   8                                                                                      g_uc_gsch_subsystem_to_load = ALL_SUBSYSTEMS;
2505   8                                                                                      g_uc_gsch_data_type_to_load = SD_HK;
2506   8              
2507   8                                                                                      //Set the downlink rate as assigned
2508   8                                                                                      g_uc_gsch_sampling_step = g_uc_gsch_gs_arg[2];
2509   8      
2510   8                                                                                      //Check the limits
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 43  

2511   8                                                                                      if (g_uc_gsch_sampling_step < WOD_SAMPLE_STEP_LOWER_LIMIT) 
2512   8                                                                                              g_uc_gsch_sampling_step = WOD_SAMPLE_STEP_LOWER_LIMIT;
2513   8                                                                                      else if (g_uc_gsch_sampling_step > WOD_SAMPLE_STEP_UPPER_LIMIT) 
2514   8                                                                                              g_uc_gsch_sampling_step = WOD_SAMPLE_STEP_UPPER_LIMIT;
2515   8      
2516   8                                                                                      //Send stored data
2517   8                                                                                      groundEnterSendStored();
2518   8                                                                              }
2519   7                                                                              else sendAckMsg();
2520   7                                                                              break;
2521   7                                                                      #endif
2522   7                                                                      #endif
2523   7      
2524   7                                                                      #if (SATELLITE_SCHEDULE_HANDLER_ENABLE == 1)
2525   7                                                                      //To start logging data based on GDSN request
2526   7                                                                      case GDSN_LOG_DATA:
2527   7                                                                              //Time window validation check
2528   7                                                                              timeWindowCheck();
2529   7      
2530   7                                                                              //Only process the command if it passes time window validation
2531   7                                                                              if (g_uc_gsch_flag & GSCH_FLAG_TIME_WINDOW_VALID){
2532   8                                                                                      //Check if there is ADCS data in the log data type
2533   8                                                                                      if (checkADCSDataInLogDataType()){
2534   9                                                                                              //Check if there are at least 4 slots in scheduler
2535   9                                                                                              //If there is sufficient slot(s) in the scheduler
2536   9                                                                                              if (str_obdh_hk.uc_scheduler_block_size <= (SCHEDULER_BLOCK_SIZE-4)){ 
2537  10                                                                                                      //Schedule mission mode at requested time -20s with elapsed time as requested +30s
2538  10                                                                                                      g_us_gsch_error_code = scheduleMissionMode((uchar2ulong(g_uc_gsch_gs_arg[0],g_uc_gsch_gs_arg[1
             -],g_uc_gsch_gs_arg[2],g_uc_gsch_gs_arg[3])-SECONDS_FROM_TAI_TO_KILL_SWITCH_DEACTIVATION-20),(unsigned short)((unsigned s
             -hort)(g_uc_gsch_gs_arg[4] << 8)+g_uc_gsch_gs_arg[5]+30));
2539  10              
2540  10                                                                                                      //If there is no error code, it means that the scheduled time has not passed.
2541  10                                                                                                      if (!g_us_gsch_error_code){
2542  11                                                                                                              //Schedule to turn ON ADCS first
2543  11                                                                                                              g_us_gsch_error_code = scheduleTurnOnADCS(uchar2ulong(g_uc_gsch_gs_arg[0],g_uc_gsch_gs_arg[1]
             -,g_uc_gsch_gs_arg[2],g_uc_gsch_gs_arg[3])-SECONDS_FROM_TAI_TO_KILL_SWITCH_DEACTIVATION-20);
2544  11              
2545  11                                                                                                              //Insert schedule to log data
2546  11                                                                                                              scheduleLogData();
2547  11                                                                                                      }
2548  10                                                                                              }
2549   9                                                                                              //If there isn't sufficient slot(s) in the scheduler 
2550   9                                                                                              else g_us_gsch_error_code = EC_NOT_ENOUGH_SCHEDULE_SLOT;                                                                        
2551   9                                                                                      }
2552   8                                                                                      //Else, we need only 2 slots for PWRS data logging
2553   8                                                                                      else{
2554   9                                                                                              //If there is sufficient slot(s) in the scheduler
2555   9                                                                                              if (str_obdh_hk.uc_scheduler_block_size <= (SCHEDULER_BLOCK_SIZE-2)){
2556  10                                                                                                      //Schedule mission mode at requested time -20s with elapsed time as requested +30s
2557  10                                                                                                      g_us_gsch_error_code = scheduleMissionMode((uchar2ulong(g_uc_gsch_gs_arg[0],g_uc_gsch_gs_arg[1
             -],g_uc_gsch_gs_arg[2],g_uc_gsch_gs_arg[3])-SECONDS_FROM_TAI_TO_KILL_SWITCH_DEACTIVATION-20),(unsigned short)((unsigned s
             -hort)(g_uc_gsch_gs_arg[4] << 8)+g_uc_gsch_gs_arg[5]+30));
2558  10              
2559  10                                                                                                      //If there is no error code, it means that the scheduled time has not passed.
2560  10                                                                                                      if (!g_us_gsch_error_code) scheduleLogData();
2561  10                                                                                              }
2562   9                                                                                              //If there isn't sufficient slot(s) in the scheduler
2563   9                                                                                              else g_us_gsch_error_code = EC_NOT_ENOUGH_SCHEDULE_SLOT;                                                                        
2564   9                                                                                      }
2565   8      
2566   8                                                                                      #if (SENDING_ENABLE == 1)
2567   8                                                                                      //Save latest schedule and send acknowledgement message
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 44  

2568   8                                                                                      groundSaveScheduleAndAck();
2569   8                                                                                      #endif
2570   8                                                                              }                                                                       
2571   7                                                                              break;
2572   7                                                                      #endif
2573   7      
2574   7                                                                      #if (SENDING_ENABLE == 1)
2575   7                                                                      #if (ISIS_CMD_ENABLE == 1)
2576   7                                                                      //To send down special data requested
2577   7                                                                      case GDSN_GET_DATA_SPEC:
2578   7                                                                              //Check if there is any data logged
2579   7                                                                              if (g_us_log_data_block_size){
2580   8                                                                                      //Always successful
2581   8                                                                                      g_us_gsch_error_code = EC_SUCCESSFUL;
2582   8      
2583   8                                                                                      //Set initial and end block pointer for the wanted data
2584   8                                                                                      g_ul_obs_initial_bp = SD_BP_DATALOG_START;
2585   8                                                                                      g_ul_obs_end_bp = str_bp.ul_datalog_write_p-(1+NO_OF_COPIES_SD_LOG_DATA);
2586   8              
2587   8                                                                                      //Logical check (it is not possible to have overwritten block here)
2588   8                                                                                      if (g_ul_obs_end_bp < g_ul_obs_initial_bp)
2589   8                                                                                              g_ul_obs_end_bp = g_ul_obs_initial_bp;
2590   8              
2591   8                                                                                      //Indicates taking data from SD card
2592   8                                                                                      g_uc_ax25_header_package_property = AX25_HEADER_PROPERTY_STORED_DATA_BIT;
2593   8              
2594   8                                                                                      //Set current package no to 1
2595   8                                                                                      g_uc_ax25_header_no_of_this_package = 1;
2596   8              
2597   8                                                                                      //Initialize subsystem and data type to load
2598   8                                                                                      g_uc_gsch_subsystem_to_load = ALL_SUBSYSTEMS;
2599   8                                                                                      g_uc_gsch_data_type_to_load = SD_LOG_DATA;
2600   8              
2601   8                                                                                      //Set the downlink rate as assigned (always one for this case)
2602   8                                                                                      g_uc_gsch_sampling_step = 1;
2603   8      
2604   8                                                                                      //Send stored data
2605   8                                                                                      groundEnterSendStored();
2606   8                                                                              }
2607   7                                                                              //If there is no data logged yet
2608   7                                                                              else{ 
2609   8                                                                                      g_us_gsch_error_code = EC_NO_DATA_LOGGED_YET;
2610   8                                                                                      sendAckMsg();
2611   8                                                                              }
2612   7                                                                                      
2613   7                                                                              break;
2614   7      
2615   7                                                                      //To send down current satellite schedule
2616   7                                                                      case GDSN_GET_SAT_SCHEDULE:
2617   7                                                                              //Always successful
2618   7                                                                              g_us_gsch_error_code = EC_SUCCESSFUL;
2619   7      
2620   7                                                                              //Initialize schedule sent counter
2621   7                                                                              g_uc_schedule_sent_counter = 0;
2622   7      
2623   7                                                                              //Send current satellite schedule
2624   7                                                                              sendCommonData(SD_SCHEDULE);
2625   7                                                                              break;
2626   7      
2627   7                                                                      //To send down current satellite time
2628   7                                                                      case GDSN_GET_SAT_TIME:
2629   7                                                                              //Always successful
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 45  

2630   7                                                                              g_us_gsch_error_code = EC_SUCCESSFUL;
2631   7      
2632   7                                                                              //Send current satellite time (int TAI format)
2633   7                                                                              sendCommonData(SD_SAT_TIME);
2634   7                                                                              break;
2635   7                                                                      #endif
2636   7                                                                      #endif
2637   7      
2638   7                                                                      //To set current satellite time
2639   7                                                                      case GDSN_SET_SAT_TIME:
2640   7                                                                              //Update satellite time as specified by the ground station
2641   7                                                                              groundUpdateTime(uchar2ulong(g_uc_gsch_gs_arg[0],g_uc_gsch_gs_arg[1],g_uc_gsch_gs_arg[2],g_uc_gsc
             -h_gs_arg[3]));
2642   7      
2643   7                                                                              //Assign error code of RTC (by right, this should always be 0x0000)
2644   7                                                                              g_us_gsch_error_code = g_us_latest_gdsn_to_rtc_update_ec;
2645   7      
2646   7                                                                              #if (SENDING_ENABLE == 1)
2647   7                                                                              //Save essential state and send acknowledgement
2648   7                                                                              groundSaveEssentialAndAck();
2649   7                                                                              #endif
2650   7                                                                              break;
2651   7      
2652   7                                                                      #if (EXTRA_ENABLE == 1)
2653   7                                                                      //To reset satellite (to be developed later)
2654   7                                                                      case GDSN_RESET_SAT:
2655   7                                                                              //Time window validation check
2656   7                                                                              timeWindowCheck();
2657   7      
2658   7                                                                              //Only proccess the command if it passes time window validation
2659   7                                                                              if (g_uc_gsch_flag & GSCH_FLAG_TIME_WINDOW_VALID){
2660   8                                                                                      //Check if satellite rest flag has already been initialized, if it is not...
2661   8                                                                                      if (!(g_uc_evha_flag & EVENT_FLAG_RESET_SAT_INITIALIZED)){      
2662   9                                                                                              //Mark reset cause as RESET_SOURCE_MCC_COMMAND 
2663   9                                                                                              str_obdh_data.uc_sat_rstsrc = RESET_SOURCE_MCC_COMMAND;
2664   9              
2665   9                                                                                              //Trigger satellite's reset
2666   9                                                                                              callReset(OBDH_CMD_RESET_SAT);
2667   9              
2668   9                                                                                              #if (SENDING_ENABLE == 1)
2669   9                                                                                              #if (ISIS_CMD_ENABLE == 1)
2670   9                                                                                              //Return successful     message
2671   9                                                                                              g_us_gsch_error_code = EC_SUCCESSFUL;
2672   9              
2673   9                                                                                              //Send ACK MSG
2674   9                                                                                              sendAckMsg();
2675   9                                                                                              #endif
2676   9                                                                                              #endif
2677   9                                                                                      }
2678   8                                                                                      #if (SENDING_ENABLE == 1)
2679   8                                                                                      #if (ISIS_CMD_ENABLE == 1)
2680   8                                                                                      //If it is...
2681   8                                                                                      else{                                                                           
2682   9                                                                                              //Indicates that satellite reset has already been initialized
2683   9                                                                                              g_us_gsch_error_code = EC_INVALID_GDSN_RESET_SAT_ALREADY_INITIALIZED;
2684   9              
2685   9                                                                                              //Send ACK MSG
2686   9                                                                                              sendAckMsg();
2687   9                                                                                      }
2688   8                                                                                      #endif
2689   8                                                                                      #endif
2690   8                                                                              }
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 46  

2691   7                                                                              break;
2692   7                                                                      #endif
2693   7      
2694   7                                                                      //To start NOP
2695   7                                                                      case GDSN_START_NOP:
2696   7                                                                              //Time window validation check
2697   7                                                                              timeWindowCheck();
2698   7      
2699   7                                                                              //Only proccess the command if it passes time window validation
2700   7                                                                              if (g_uc_gsch_flag & GSCH_FLAG_TIME_WINDOW_VALID){
2701   8                                                                                      //Change satellite mode to NOP
2702   8                                                                                      str_obdh_hk.uc_sat_mode = SATELLITE_MODE_M6;
2703   8                                                                                      str_obdh_data.uc_previous_mode = SATELLITE_MODE_M5;
2704   8      
2705   8                                                                                      #if (BODY_RATE_HANDLER_ENABLE == 1)
2706   8                                                                                      #if (ADCS_CMD_ENABLE == 1)
2707   8                                                                                      #if (PWRS_CMD_ENABLE == 1)                              
2708   8                                                                                      //Disable bodyRateHandler
2709   8                                                                                      str_obdh_hk.us_brh_flag &= ~BRH_FLAG_ENABLE;
2710   8                                                                                      #endif
2711   8                                                                                      #endif
2712   8                                                                                      #endif
2713   8                                                      
2714   8                                                                                      #if (IDLE_MODE_HANDLER_ENABLE == 1)
2715   8                                                                                      #if (PWRS_CMD_ENABLE == 1)
2716   8                                                                                      //Enable idleModeHandler
2717   8                                                                                      str_obdh_hk.us_imh_flag |= IMH_FLAG_ENABLE;
2718   8                                                                                      #endif
2719   8                                                                                      #endif
2720   8      
2721   8                                                                                      //Update SoC thresholds
2722   8                                                                                      str_obdh_par.uc_soc_threshold[0] = THRESHOLD_SOC_M5_TO_M8_DEFAULT;
2723   8                                                                                      str_obdh_par.uc_soc_threshold[1] = THRESHOLD_SOC_M8_TO_M5_DEFAULT;
2724   8      
2725   8                                                                                      //Always successful
2726   8                                                                                      g_us_gsch_error_code = EC_SUCCESSFUL;
2727   8      
2728   8                                                                                      #if (SENDING_ENABLE == 1)
2729   8                                                                                      //Save essential state and send acknowledgement
2730   8                                                                                      groundSaveEssentialAndAck();
2731   8                                                                                      #endif
2732   8                                                                              }
2733   7                                                                              break;
2734   7      
2735   7                                                                      //To update ADCS TLE
2736   7                                                                      case GDSN_UPDATE_TLE:
2737   7                                                                              //Time window validation check
2738   7                                                                              timeWindowCheck();
2739   7      
2740   7                                                                              //Only proccess the command if it passes time window validation
2741   7                                                                              if (g_uc_gsch_flag & GSCH_FLAG_TIME_WINDOW_VALID){
2742   8                                                                                      //Command ADCS to update TLE
2743   8                                                                                      #if (ADCS_CMD_ENABLE == 1)
2744   8                                                                                      #if (DEBUGGING_FEATURE == 1)
2745   8                                                                                      g_us_gsch_error_code = adcsSetTLE(0);
2746   8                                                                                      #else
                                                                                              g_us_gsch_error_code = adcsSetTLE();
                                                                                              #endif
2749   8                                                                                      #else
                                                                                              g_us_gsch_error_code = EC_ADCS_CMD_DISABLED;
                                                                                              #endif
2752   8              
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 47  

2753   8                                                                                      #if (SENDING_ENABLE == 1)
2754   8                                                                                      #if (ISIS_CMD_ENABLE == 1)
2755   8                                                                                      //Send ACK MSG
2756   8                                                                                      sendAckMsg();
2757   8                                                                                      #endif
2758   8                                                                                      #endif
2759   8                                                                              }                                                                                                                                               
2760   7                                                                              break;
2761   7      
2762   7                                                                      //To update ADCS CGAIN
2763   7                                                                      case GDSN_UPDATE_CGAIN:
2764   7                                                                              //Time window validation check
2765   7                                                                              timeWindowCheck();
2766   7      
2767   7                                                                              //Only proccess the command if it passes time window validation
2768   7                                                                              if (g_uc_gsch_flag & GSCH_FLAG_TIME_WINDOW_VALID){
2769   8                                                                                      //Command ADCS to update CGAIN
2770   8                                                                                      #if (ADCS_CMD_ENABLE == 1)
2771   8                                                                                      #if (DEBUGGING_FEATURE == 1)
2772   8                                                                                      g_us_gsch_error_code = adcsSetCGain(0);
2773   8                                                                                      #else
                                                                                              g_us_gsch_error_code = adcsSetCGain();
                                                                                              #endif
2776   8                                                                                      #else
                                                                                              g_us_gsch_error_code = EC_ADCS_CMD_DISABLED;
                                                                                              #endif
2779   8                                                                                      
2780   8                                                                                      #if (SENDING_ENABLE == 1)
2781   8                                                                                      #if (ISIS_CMD_ENABLE == 1)
2782   8                                                                                      //Send ACK MSG
2783   8                                                                                      sendAckMsg();
2784   8                                                                                      #endif
2785   8                                                                                      #endif
2786   8                                                                              }
2787   7                                                                              break;
2788   7      
2789   7                                                                      #if (SATELLITE_SCHEDULE_HANDLER_ENABLE == 1)
2790   7                                                                      //To schedule sun tracking
2791   7                                                                      case GDSN_SCHEDULE_SUN_TRACKING:
2792   7                                                                              //Time window validation check
2793   7                                                                              timeWindowCheck();
2794   7      
2795   7                                                                              //Only proccess the command if it passes time window validation
2796   7                                                                              if (g_uc_gsch_flag & GSCH_FLAG_TIME_WINDOW_VALID){
2797   8                                                                                      //Only process the command if there are at least 4 empty schedule slots
2798   8                                                                                      if (str_obdh_hk.uc_scheduler_block_size <= (SCHEDULER_BLOCK_SIZE-4)){
2799   9                                                                                              //Schedule mission mode at requested time -20s with elapsed time as requested +30s
2800   9                                                                                              g_us_gsch_error_code = scheduleMissionMode((uchar2ulong(g_uc_gsch_gs_arg[0],g_uc_gsch_gs_arg[1]
             -,g_uc_gsch_gs_arg[2],g_uc_gsch_gs_arg[3])-SECONDS_FROM_TAI_TO_KILL_SWITCH_DEACTIVATION-20),(unsigned short)((unsigned sh
             -ort)(g_uc_gsch_gs_arg[4] << 8)+g_uc_gsch_gs_arg[5]+30));
2801   9      
2802   9                                                                                              //If there is no error code, it means that the scheduled time has not passed.
2803   9                                                                                              //Proceeds by turning on ADCS at -20s, and uploading the scheduled sun tracking on schedule wit
             -h the given elapsed time/10
2804   9                                                                                              if (!g_us_gsch_error_code){
2805  10                                                                                                      //Schedule to turn ON ADCS first
2806  10                                                                                                      g_us_gsch_error_code = scheduleTurnOnADCS(uchar2ulong(g_uc_gsch_gs_arg[0],g_uc_gsch_gs_arg[1],
             -g_uc_gsch_gs_arg[2],g_uc_gsch_gs_arg[3])-SECONDS_FROM_TAI_TO_KILL_SWITCH_DEACTIVATION-20);
2807  10      
2808  10                                                                                                      //Schedule sun tracking mission
2809  10                                                                                                      scheduleSunTracking();
2810  10                                                                                              }
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 48  

2811   9                                                                                      }
2812   8                                                                                      //Return error code: EC_NOT_ENOUGH_SCHEDULE_SLOT
2813   8                                                                                      else g_us_gsch_error_code = EC_NOT_ENOUGH_SCHEDULE_SLOT;
2814   8                                                                                      
2815   8                                                                                      #if (SENDING_ENABLE == 1)
2816   8                                                                                      //Save latest schedule and send acknowledgement message
2817   8                                                                                      groundSaveScheduleAndAck();
2818   8                                                                                      #endif
2819   8                                                                              }
2820   7                                                                              break;
2821   7      
2822   7                                                                      //To upload timed command (A)
2823   7                                                                      case GDSN_UPLOAD_TCMD_A:
2824   7                                                                              //Insert the scheduled command to the register
2825   7                                                                              for (l_us_i = 0; l_us_i < MAX_GSCH_CMD_ARG_LEN; l_us_i++)
2826   7                                                                                      g_uc_gsch_sch_register[l_us_i] = g_uc_gsch_gs_arg[l_us_i];
2827   7                                                                              
2828   7                                                                              //Always successful
2829   7                                                                              g_us_gsch_error_code = EC_SUCCESSFUL;
2830   7      
2831   7                                                                              #if (SENDING_ENABLE == 1)
2832   7                                                                              #if (ISIS_CMD_ENABLE == 1)
2833   7                                                                              //Send ACK MSG
2834   7                                                                              sendAckMsg();
2835   7                                                                              #endif
2836   7                                                                              #endif
2837   7                                                                              break;
2838   7      
2839   7                                                                      //To upload timed command (B)
2840   7                                                                      case GDSN_UPLOAD_TCMD_B:
2841   7                                                                              //Insert the scheduled command to the register
2842   7                                                                              for (l_us_i = 0; l_us_i < (MAX_SCHEDULER_ARG+SCHEDULER_NON_ARG_SIZE+2)-MAX_GSCH_CMD_ARG_LEN; l_us
             -_i++)
2843   7                                                                                      g_uc_gsch_sch_register[l_us_i+MAX_GSCH_CMD_ARG_LEN] = g_uc_gsch_gs_arg[l_us_i];
2844   7      
2845   7                                                                              #if (CRC_ENABLE == 1)
2846   7                                                                              //Check the uploaded timed command's CRC16
2847   7                                                                              //Ian (2012-05-15): Magic constant 7 is changed to SCHEDULER_NON_ARG_SIZE
2848   7                                                                              g_us_gsch_error_code = checkCRC16Match (&g_uc_gsch_sch_register, MAX_SCHEDULER_ARG+SCHEDULER_NON_
             -ARG_SIZE);
2849   7                                                                              #else
                                                                                      //Always successful
                                                                                      g_us_gsch_error_code = EC_SUCCESSFUL;
                                                                                      #endif
2853   7      
2854   7                                                                              //If the CRC matches, attempt to upload the schedule
2855   7                                                                              if (!g_us_gsch_error_code){
2856   8                                                                                      //Insert schedule to start the wanted task on the scheduled time
2857   8                                                                                      str_scheduler.ul_scheduled_time_register        = uchar2ulong(g_uc_gsch_sch_register[0],g_uc_gsch_sch_
             -register[1],g_uc_gsch_sch_register[2],g_uc_gsch_sch_register[3]) - SECONDS_FROM_TAI_TO_KILL_SWITCH_DEACTIVATION;
2858   8                                                                                      str_scheduler.us_cmd_register                           = (unsigned short)(g_uc_gsch_sch_register[4] << 8) + g_uc_gsch
             -_sch_register[5];
2859   8                                                                                      str_scheduler.uc_arg_length_register            = g_uc_gsch_sch_register[6];
2860   8                                                                                      //Ian (2012-05-15): Magic constant 7 is changed to SCHEDULER_NON_ARG_SIZE
2861   8                                                                                      for (l_us_i = 0; l_us_i < MAX_SCHEDULER_ARG; l_us_i++)
2862   8                                                                                              str_scheduler.uc_arg_register[l_us_i]   = g_uc_gsch_sch_register[l_us_i+SCHEDULER_NON_ARG_SIZE];        
2863   8                                                                                      g_us_gsch_error_code = addNewSchedule();
2864   8                                                                              }
2865   7      
2866   7                                                                              #if (SENDING_ENABLE == 1)
2867   7                                                                              //Save latest schedule and send acknowledgement message
2868   7                                                                              groundSaveScheduleAndAck();
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 49  

2869   7                                                                              #endif
2870   7                                                                              break;
2871   7                                                                      #endif
2872   7      
2873   7                                                                      //To turn OFF beacon
2874   7                                                                      case GDSN_OFF_TX:
2875   7                                                                              //Time window validation check
2876   7                                                                              timeWindowCheck();
2877   7      
2878   7                                                                              //Only proccess the command if it passes time window validation
2879   7                                                                              if (g_uc_gsch_flag & GSCH_FLAG_TIME_WINDOW_VALID){
2880   8                                                                                      //Disable the beacon flag until unspecified amount of time
2881   8                                                                                      str_obdh_hk.us_beacon_flag |= BEACON_FLAG_AUTO_BEACON_DISABLE;
2882   8      
2883   8                                                                                      //Always successful
2884   8                                                                                      g_us_gsch_error_code = EC_SUCCESSFUL;
2885   8      
2886   8                                                                                      #if (SENDING_ENABLE == 1)
2887   8                                                                                      //Save essential state and send acknowledgement
2888   8                                                                                      groundSaveEssentialAndAck();
2889   8                                                                                      #endif
2890   8                                                                              }
2891   7                                                                              break;
2892   7      
2893   7                                                                      //To turn ON beacon
2894   7                                                                      case GDSN_ON_TX:
2895   7                                                                              //Time window validation check
2896   7                                                                              timeWindowCheck();
2897   7      
2898   7                                                                              //Only proccess the command if it passes time window validation
2899   7                                                                              if (g_uc_gsch_flag & GSCH_FLAG_TIME_WINDOW_VALID){
2900   8                                                                                      //Enable the beacon flag until unspecified amount of time
2901   8                                                                                      str_obdh_hk.us_beacon_flag &= ~BEACON_FLAG_AUTO_BEACON_DISABLE;
2902   8      
2903   8                                                                                      //Always successful
2904   8                                                                                      g_us_gsch_error_code = EC_SUCCESSFUL;
2905   8      
2906   8                                                                                      #if (SENDING_ENABLE == 1)
2907   8                                                                                      //Save essential state and send acknowledgement
2908   8                                                                                      groundSaveEssentialAndAck();
2909   8                                                                                      #endif
2910   8                                                                              }
2911   7                                                                              break;
2912   7      
2913   7                                                                      #if (SENDING_ENABLE == 1)
2914   7                                                                      #if (ISIS_CMD_ENABLE == 1)
2915   7                                                                      //To get satellite orbit
2916   7                                                                      case GDSN_GET_SAT_REV:
2917   7                                                                              //Always successful
2918   7                                                                              g_us_gsch_error_code = EC_SUCCESSFUL;
2919   7      
2920   7                                                                              //Send current satellite revolution (orbit) no
2921   7                                                                              sendCommonData(SD_SAT_REV);
2922   7                                                                              break;
2923   7                                                                      #endif
2924   7                                                                      #endif
2925   7      
2926   7                                                                      //To set satellite orbit
2927   7                                                                      case GDSN_SET_SAT_REV:
2928   7                                                                              //Time window validation check
2929   7                                                                              timeWindowCheck();
2930   7      
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 50  

2931   7                                                                              //Only proccess the command if it passes time window validation
2932   7                                                                              if (g_uc_gsch_flag & GSCH_FLAG_TIME_WINDOW_VALID){
2933   8                                                                                      //Update revolution no based on GDSN inputs
2934   8                                                                                      groundUpdateRevNo();
2935   8      
2936   8                                                                                      //Always successful
2937   8                                                                                      g_us_gsch_error_code = EC_SUCCESSFUL;
2938   8              
2939   8                                                                                      #if (SENDING_ENABLE == 1)
2940   8                                                                                      //Save essential state and send acknowledgement
2941   8                                                                                      groundSaveEssentialAndAck();
2942   8                                                                                      #endif
2943   8                                                                              }
2944   7                                                                              break;
2945   7      
2946   7                                                                      #if (SENDING_ENABLE == 1)
2947   7                                                                      #if (ISIS_CMD_ENABLE == 1)
2948   7                                                                      //To get a specified SD card block data
2949   7                                                                      case GDSN_GET_SD_BLOCK:
2950   7                                                                              //Set initial and end block pointer for the wanted data
2951   7                                                                              g_ul_obs_initial_bp = uchar2ulong(g_uc_gsch_gs_arg[0],g_uc_gsch_gs_arg[1],g_uc_gsch_gs_arg[2],g_u
             -c_gsch_gs_arg[3]);
2952   7                                                                              g_ul_obs_end_bp = g_ul_obs_initial_bp;
2953   7      
2954   7                                                                              //Limit check
2955   7                                                                              if (g_ul_obs_initial_bp > SD_BP_MAX){
2956   8                                                                                      //Set error code EC_SD_CARD_BLOCK_DOES_NOT_EXIST
2957   8                                                                                      g_us_gsch_error_code = EC_SD_CARD_BLOCK_DOES_NOT_EXIST;
2958   8      
2959   8                                                                                      //Send ACK MSG
2960   8                                                                                      sendAckMsg();
2961   8                                                                              }
2962   7                                                                              //Successful request
2963   7                                                                              else{
2964   8                                                                                      //Always successful
2965   8                                                                                      g_us_gsch_error_code = EC_SUCCESSFUL;
2966   8      
2967   8                                                                                      //Indicates taking data from SD card
2968   8                                                                                      g_uc_ax25_header_package_property = AX25_HEADER_PROPERTY_STORED_DATA_BIT;
2969   8              
2970   8                                                                                      //Set current package no to 1
2971   8                                                                                      g_uc_ax25_header_no_of_this_package = 1;
2972   8              
2973   8                                                                                      //Initialize subsystem and data type to load
2974   8                                                                                      g_uc_gsch_subsystem_to_load = ALL_SUBSYSTEMS;
2975   8                                                                                      g_uc_gsch_data_type_to_load = SD_REQUESTED_BLOCK;
2976   8              
2977   8                                                                                      //Set the downlink rate as assigned (always one for this case)
2978   8                                                                                      g_uc_gsch_sampling_step = 1;
2979   8              
2980   8                                                                                      //Send stored data
2981   8                                                                                      groundEnterSendStored();
2982   8                                                                              }
2983   7                                                                              break;
2984   7                                                                      #endif
2985   7                                                                      #endif
2986   7      
2987   7                                                                      //To schedule OBDH's mission mode
2988   7                                                                      case GDSN_SCHEDULE_MISSION_MODE:
2989   7                                                                              //Time window validation check
2990   7                                                                              timeWindowCheck();
2991   7      
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 51  

2992   7                                                                              //Only proccess the command if it passes time window validation
2993   7                                                                              if (g_uc_gsch_flag & GSCH_FLAG_TIME_WINDOW_VALID){
2994   8                                                                                      #if (SATELLITE_SCHEDULE_HANDLER_ENABLE == 1)
2995   8                                                                                      //Schedule mission mode as requested
2996   8                                                                                      g_us_gsch_error_code = scheduleMissionMode((uchar2ulong(g_uc_gsch_gs_arg[0],g_uc_gsch_gs_arg[1],
             -g_uc_gsch_gs_arg[2],g_uc_gsch_gs_arg[3]) - SECONDS_FROM_TAI_TO_KILL_SWITCH_DEACTIVATION),(unsigned short)((unsigned shor
             -t)(g_uc_gsch_gs_arg[4] << 8) + g_uc_gsch_gs_arg[5]));
2997   8                                                                                      #else
                                                                                              g_us_gsch_error_code = EC_SATELLITE_SCHEDULE_IS_DISABLED;
                                                                                              #endif
3000   8      
3001   8                                                                                      #if (SENDING_ENABLE == 1)
3002   8                                                                                      //Save latest schedule and send acknowledgement message
3003   8                                                                                      groundSaveScheduleAndAck();
3004   8                                                                                      #endif
3005   8                                                                              }
3006   7                                                                              break;
3007   7      
3008   7                                                                      #if (SENDING_ENABLE == 1)
3009   7                                                                      #if (ISIS_CMD_ENABLE == 1)
3010   7                                                                      //To request lost frame package
3011   7                                                                      case GDSN_REQUEST_LOST_FRAME:
3012   7                                                                              //Check whether the input is not zero
3013   7                                                                              if (g_uc_gsch_gs_arg[0]){                                                                       
3014   8                                                                                      //Always successful
3015   8                                                                                      g_us_gsch_error_code = EC_SUCCESSFUL;
3016   8              
3017   8                                                                                      //Set initial and end block pointer for the wanted data
3018   8                                                                                      g_ul_obs_initial_bp = SD_BP_PACKAGE_RECOVERY_START + (g_uc_gsch_gs_arg[0]-1) * (1+NO_OF_COPIES_S
             -D_RECOVERY_PACKAGE);
3019   8                                                                                      g_ul_obs_end_bp = g_ul_obs_initial_bp;
3020   8              
3021   8                                                                                      //Indicates taking data from SD card and is a special recovery case
3022   8                                                                                      g_uc_ax25_header_package_property = AX25_HEADER_PROPERTY_STORED_DATA_BIT + AX25_HEADER_PROPERTY_
             -PACKAGE_RECOVERY_DATA_BIT;
3023   8              
3024   8                                                                                      //Set current package no to 1
3025   8                                                                                      g_uc_ax25_header_no_of_this_package = 1;
3026   8              
3027   8                                                                                      //Initialize subsystem and data type to load
3028   8                                                                                      g_uc_gsch_subsystem_to_load = ALL_SUBSYSTEMS;
3029   8                                                                                      g_uc_gsch_data_type_to_load = SD_RECOVERY_PACKAGE;
3030   8              
3031   8                                                                                      //Set the downlink rate as assigned (always one for this case)
3032   8                                                                                      g_uc_gsch_sampling_step = 1;
3033   8              
3034   8                                                                                      //Send stored data
3035   8                                                                                      groundEnterSendStored();
3036   8                                                                              }
3037   7                                                                              //If index = 0 -> Invalid lost frame index
3038   7                                                                              else{
3039   8                                                                                      g_us_gsch_error_code = EC_INVALID_GDSN_LOST_FRAME_INDEX;
3040   8                                                                                      sendAckMsg();                                                                           
3041   8                                                                              }
3042   7                                                                              break;
3043   7      
3044   7                                                                      //Get GDSN_GET_WOE data based on orbit dec22_yc
3045   7                                                                      case GDSN_GET_WOE:
3046   7                                                                              //Search proper block pointer based on the orbit requested
3047   7                                                                              g_us_obs_first_orbit_request    = (unsigned short)(g_uc_gsch_gs_arg[0] << 8) + g_uc_gsch_gs_arg[1];
3048   7                                                                              g_us_obs_last_orbit_request     = g_us_obs_first_orbit_request;
3049   7                                                                              #if (STORING_ENABLE == 1)
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 52  

3050   7                                                                              g_us_gsch_error_code                    = searchBPByOrbitInfo(SD_EVENTLOG_DATA);
3051   7                                                                              #else
                                                                                      g_us_gsch_error_code                    = EC_STORING_FUNCTIONS_ARE_DISABLED;
                                                                                      #endif
3054   7      
3055   7                                                                              //If there is initialization error, do not proceed
3056   7                                                                              //Else, proceeds to GSCH_STATE_SEND_STORED_DATA state
3057   7                                                                              if(!g_us_gsch_error_code){
3058   8                                                                                      //Indicates taking data from SD card
3059   8                                                                                      g_uc_ax25_header_package_property = AX25_HEADER_PROPERTY_STORED_DATA_BIT;
3060   8      
3061   8                                                                                      //Set current package no to 1
3062   8                                                                                      g_uc_ax25_header_no_of_this_package = 1;
3063   8      
3064   8                                                                                      //Initialize subsystem and data type to load
3065   8                                                                                      g_uc_gsch_subsystem_to_load = ALL_SUBSYSTEMS;
3066   8                                                                                      g_uc_gsch_data_type_to_load = SD_EVENTLOG_DATA;
3067   8              
3068   8                                                                                      //Set the downlink rate as assigned
3069   8                                                                                      g_uc_gsch_sampling_step = g_uc_gsch_gs_arg[2];
3070   8      
3071   8                                                                                      //Check the limits
3072   8                                                                                      if (g_uc_gsch_sampling_step < WOD_SAMPLE_STEP_LOWER_LIMIT)//no change.. same sample step. 
3073   8                                                                                              g_uc_gsch_sampling_step = WOD_SAMPLE_STEP_LOWER_LIMIT;
3074   8                                                                                      else if (g_uc_gsch_sampling_step > WOD_SAMPLE_STEP_UPPER_LIMIT) 
3075   8                                                                                              g_uc_gsch_sampling_step = WOD_SAMPLE_STEP_UPPER_LIMIT;
3076   8      
3077   8                                                                                      //Send stored data
3078   8                                                                                      groundEnterSendStored();
3079   8                                                                              }
3080   7                                                                              else sendAckMsg();
3081   7                                                                              break;
3082   7                                                                      #endif
3083   7                                                                      #endif
3084   7      
3085   7                                                                      //If GDSN command is not recognized, the satellite will still send ACK MSG will proper error codes
3086   7                                                                      //No, better don't send anything to save energy
3087   7                                                                      default:
3088   7                                                                              break;
3089   7                                                              }
3090   6                                                      }
3091   5                                              }               
3092   4                                      }
3093   3                                      //Else, if energy is insufficient, go to GSCH_STATE_IDLE state
3094   3                                      else groundTerminateGroundPass();
3095   3                                      
3096   3                              }
3097   2                              //Else, when the time has up, go back to idle state
3098   2                              else groundTerminateGroundPass();
3099   2                                              
3100   2                              break;
3101   2      
3102   2                      //When GSCH is sending real time data
3103   2                      case GSCH_STATE_SEND_REAL_TIME_DATA:
3104   2                              //Sending time flag is always raised in this state
3105   2                              g_uc_gsch_flag |= GSCH_FLAG_TOTAL_SENDING;
3106   2      
3107   2                              //For all transition state case, it is important to get latest beacon status
3108   2                              //Only proceeds when beacon is functional
3109   2                              if ((str_obdh_hk.us_beacon_flag & BEACON_FLAG_FILTER_PRIMARY) == BEACON_FUNCTIONAL){
3110   3                                      //If it is functional, check its case
3111   3                                      l_us_beacon_status = str_obdh_hk.us_beacon_flag & BEACON_FLAG_FILTER_SECONDARY;
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 53  

3112   3      
3113   3                                      //Switch the case for beacon status
3114   3                                      switch (l_us_beacon_status){
3115   4                                              //There are only four valid cases
3116   4                                              //First, beacon is free, initiates transmission here
3117   4                                              case BEACON_FREE:
3118   4                                                      //Reset g_us_groundpass_time_register
3119   4                                                      g_us_groundpass_time_register = TIME_RESET_GROUND_PASS_S;
3120   4      
3121   4                                                      #if (SENDING_ENABLE == 1)
3122   4                                                      //Start sending request
3123   4                                                      groundStartSendRequest();
3124   4                                                      #endif
3125   4                                                      break;
3126   4              
3127   4                                              //Second, beacon is busy of other sending task, do nothing
3128   4                                              //Third, beacon is currently sending your request, do nothing too
3129   4                                              //If the sending has gone too long, however, terminates the requets
3130   4                                              //Go back to GSCH_STATE_GROUND_PASS state
3131   4                                              case BEACON_BUSY_1:
3132   4                                              case BEACON_BUSY_2:
3133   4                                              case BEACON_SENDING:
3134   4                                              case BEACON_WAITING:
3135   4                                                      break;
3136   4              
3137   4                                              //Fourth, beacon sending is completed                                   
3138   4                                              case BEACON_SEND_COMPLETED:
3139   4                                                      //Reset g_us_groundpass_time_register
3140   4                                                      g_us_groundpass_time_register = TIME_RESET_GROUND_PASS_S;
3141   4      
3142   4                                                      //If the sending package is not completed
3143   4                                                      if (!(g_uc_strsnd_flag & SNDNG_FLAG_COMPLETED))
3144   4                                                              #if (SENDING_ENABLE == 1)
3145   4                                                              //Generate new sending request to the beaconHandler
3146   4                                                              groundKeepSendRequest();                                                
3147   4                                                              #else
                                                                      ;
                                                                      #endif
3150   4                                                      //Else if there is no remaining sending package
3151   4                                                      else { 
3152   5                                                              //Reset transitional state monitoring flag
3153   5                                                              g_uc_gsch_flag &= ~GSCH_FLAG_MONITOR_TRANSITIONAL;
3154   5      
3155   5                                                              //Reset sending completed flag
3156   5                                                              g_uc_strsnd_flag &= ~SNDNG_FLAG_COMPLETED;
3157   5      
3158   5                                                              #if (SENDING_ENABLE == 1)
3159   5                                                              //Release beacon's claim
3160   5                                                              groundReleaseClaimBeacon();
3161   5                                                              #endif
3162   5              
3163   5                                                              //Go back to the GSCH_STATE_GROUND_PASS state,
3164   5                                                              str_obdh_hk.uc_gsch_state = GSCH_STATE_GROUND_PASS;
3165   5                                                      }
3166   4                                                      break;
3167   4              
3168   4                                              //Besides the above cases, something wrong with the beacon, terminates the sending
3169   4                                              default:
3170   4                                                      #if (SENDING_ENABLE == 1)
3171   4                                                      //Terminates send real time state
3172   4                                                      groundTerminateSendRealTimeData();
3173   4                                                      #endif
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 54  

3174   4                                                      break;
3175   4                                      }
3176   3                              }
3177   2                              #if (SENDING_ENABLE == 1)
3178   2                              //If beacon is not found to be functional at this stage, return to GSCH_STATE_GROUND_PASS
3179   2                              else
3180   2                                      //Terminates send real time state
3181   2                                      groundTerminateSendRealTimeData();
3182   2      
3183   2                              //If at any point timeout for monitoring occurs
3184   2                              if (g_us_gsch_monitoring_transitional_period > TIME_LIMIT_GSCH_TRANSITIONAL_STATE_S)
3185   2                                      //Terminates send real time state
3186   2                                      groundTerminateSendRealTimeData();
3187   2                              #endif
3188   2      
3189   2                              break;
3190   2      
3191   2                      //When GSCH is sending stored data
3192   2                      case GSCH_STATE_SEND_STORED_DATA:
3193   2                              //Sending time flag is always raised in this state
3194   2                              g_uc_gsch_flag |= GSCH_FLAG_TOTAL_SENDING;
3195   2      
3196   2                              //For all transition state case, it is important to get latest beacon status
3197   2                              //Only proceeds when beacon is functional
3198   2                              if ((str_obdh_hk.us_beacon_flag & BEACON_FLAG_FILTER_PRIMARY) == BEACON_FUNCTIONAL){
3199   3                                      //If it is functional, check its case
3200   3                                      l_us_beacon_status = str_obdh_hk.us_beacon_flag & BEACON_FLAG_FILTER_SECONDARY;
3201   3      
3202   3                                      //Switch the case for beacon status
3203   3                                      switch (l_us_beacon_status){
3204   4                                              //There are only four valid cases
3205   4                                              //First, beacon is free, initiates transmission here
3206   4                                              case BEACON_FREE:
3207   4                                                      //Reset g_us_groundpass_time_register
3208   4                                                      g_us_groundpass_time_register = TIME_RESET_GROUND_PASS_S;
3209   4      
3210   4                                                      #if (STORING_ENABLE == 1)
3211   4                                                      //Attempt to load data
3212   4                                                      g_us_sd_load_error_code = loadDataProtected(g_uc_gsch_subsystem_to_load,g_uc_gsch_data_type_to_load,
             -g_ul_obs_initial_bp,g_ul_obs_end_bp);
3213   4                                                      #else
                                                              g_us_sd_load_error_code = EC_STORING_FUNCTIONS_ARE_DISABLED;
                                                              #endif
3216   4      
3217   4                                                      //If data is corrupted at this point, still sending, nothing to lose
3218   4                                                      if (g_us_sd_load_error_code == EC_SD_ALL_STORED_DATA_IS_CORRUPTED) g_us_sd_load_error_code = EC_SUCC
             -ESSFUL;
3219   4                                                      
3220   4                                                      //If there is no error code, read the SD card block property it returns
3221   4                                                      //and proceeds by sending the data
3222   4                                                      if(!g_us_sd_load_error_code){
3223   5                                                              g_uc_gsch_sd_block_property = g_uc_sd_data_buffer[2];
3224   5                              
3225   5                                                              //Reset g_uc_gsch_loading_retry_counter
3226   5                                                              g_uc_gsch_loading_retry_counter = 0;
3227   5      
3228   5                                                              #if (SENDING_ENABLE == 1)
3229   5                                                              //Start sending request
3230   5                                                              groundStartSendRequest();
3231   5                                                              #endif
3232   5                                                      }
3233   4                                                      //Else, if there is error in first time loading, increase retry counter, try again next loop
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 55  

3234   4                                                      //Do not raise the send request flag yet, unless we are sure about our data to send
3235   4                                                      else {
3236   5                                                              g_uc_sd_load_data_timeout_counter = TIME_LIMIT_LOAD_DATA_S; 
3237   5                                                              g_uc_gsch_loading_retry_counter++;
3238   5                                                      }
3239   4      
3240   4                                                      //If for any reason the number of loading trial has gone too many times
3241   4                                                      //Terminates Groundpass
3242   4                                                      if (g_uc_gsch_loading_retry_counter > GSCH_LOADING_FAIL_LIMIT){
3243   5                                                              //Set SD load error code as SD card irresponsive
3244   5                                                              g_us_sd_load_error_code = EC_SD_CARD_IRRESPONSIVE;
3245   5      
3246   5                                                              #if (SENDING_ENABLE == 1)
3247   5                                                              //Terminates send stored data state but gives ACK_MSG to MCC
3248   5                                                              groundTerminateSendStoredDataWithAckMsg();
3249   5                                                              #endif
3250   5                                                      }
3251   4                                                      break;
3252   4              
3253   4                                              //Second, beacon is busy of other sending task, do nothing
3254   4                                              //Third, beacon is currently sending your request, do nothing too
3255   4                                              //If the sending has gone too long, however, terminates the requets
3256   4                                              //Go back to GSCH_STATE_GROUND_PASS state
3257   4                                              case BEACON_BUSY_1:
3258   4                                              case BEACON_BUSY_2:
3259   4                                              case BEACON_SENDING:
3260   4                                              case BEACON_WAITING:
3261   4                                                      break;
3262   4              
3263   4                                              //Fourth, beacon sending is completed                                   
3264   4                                              case BEACON_SEND_COMPLETED:
3265   4                                                      //Reset g_us_groundpass_time_register
3266   4                                                      g_us_groundpass_time_register = TIME_RESET_GROUND_PASS_S;
3267   4      
3268   4                                                      //If the sending package is not completed
3269   4                                                      if (!(g_uc_strsnd_flag & SNDNG_FLAG_COMPLETED))
3270   4                                                              #if (SENDING_ENABLE == 1)
3271   4                                                              //Generate new sending request to the beaconHandler
3272   4                                                              groundKeepSendRequest();                                                
3273   4                                                              #else
                                                                      ;
                                                                      #endif
3276   4      
3277   4                                                      //If sending is completed but loading is not completed
3278   4                                                      else if ((g_uc_strsnd_flag & SNDNG_FLAG_COMPLETED) && !(g_uc_strsnd_flag & STRNG_FLAG_SD_LOAD_COMPLE
             -TED)){
3279   5      
3280   5                                                              //Do the loading based on the previous g_uc_gsch_sd_block_property
3281   5                                                              //And downloading rate the ground station specifies     in g_uc_gsch_sampling_step
3282   5                              
3283   5                                                              //If the g_uc_gsch_sd_block_property shows that previous data is on going, download once only
3284   5                                                              if (g_uc_gsch_sd_block_property == 0x01){
3285   6                                                                      #if (STORING_ENABLE == 1)
3286   6                                                                      //Attempt to load data
3287   6                                                                      g_us_sd_load_error_code = loadDataProtected(g_uc_gsch_subsystem_to_load,g_uc_gsch_data_type_to_loa
             -d,g_ul_obs_initial_bp,g_ul_obs_end_bp);
3288   6      
3289   6                                                                      //If data is corrupted at this point, still sending, nothing to lose
3290   6                                                                      if (g_us_sd_load_error_code == EC_SD_ALL_STORED_DATA_IS_CORRUPTED) g_us_sd_load_error_code = EC_SU
             -CCESSFUL;                                                
3291   6                                                                      #else
                                                                              g_us_sd_load_error_code = EC_STORING_FUNCTIONS_ARE_DISABLED;
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 56  

                                                                              #endif
3294   6                                                              }
3295   5                              
3296   5                                                              //Else, if the g_uc_gsch_sd_block_property shows that previous data is the end
3297   5                                                              //Load as many number of times as (g_uc_gsch_sampling_step-1) times we get g_uc_gsch_sd_block_prope
             -rty == 0x02
3298   5                                                              //Then the next loading is the wanted data
3299   5                                                              else if (g_uc_gsch_sd_block_property == 0x02){
3300   6                                                                      //Reset error code for loading
3301   6                                                                      g_us_sd_load_error_code = EC_SUCCESSFUL;
3302   6                              
3303   6                                                                      //Initialize no of data loading as zero
3304   6                                                                      g_uc_gsch_no_of_loading = 0; 
3305   6                              
3306   6                                                                      //This is to anticipate different downloading rate applies by the GDSN
3307   6                                                                      //While the number of data loading is less than (g_uc_gsch_sampling_step-1), repeat the steps
3308   6                                                                      //If the number of data loading is equal to or more than (g_uc_gsch_sampling_step-1)
3309   6                                                                      //Whenever there is an error code, terminates
3310   6                                                                      while ((g_uc_gsch_no_of_loading < (g_uc_gsch_sampling_step-1)) && (g_us_sd_load_error_code == EC_S
             -UCCESSFUL)){
3311   7                                                                              //Attempt to load data, so long as the loading is not completed
3312   7                                                                              if (!(g_uc_strsnd_flag & STRNG_FLAG_SD_LOAD_COMPLETED)){
3313   8                                                                                      #if (STORING_ENABLE == 1)
3314   8                                                                                      g_us_sd_load_error_code = loadDataProtected(g_uc_gsch_subsystem_to_load,g_uc_gsch_data_type_to_l
             -oad,g_ul_obs_initial_bp,g_ul_obs_end_bp);
3315   8      
3316   8                                                                                      //If data is corrupted at this point, still proceeds, nothing to lose
3317   8                                                                                      if (g_us_sd_load_error_code == EC_SD_ALL_STORED_DATA_IS_CORRUPTED) g_us_sd_load_error_code = EC_
             -SUCCESSFUL;                                                
3318   8                                                                                      #else
                                                                                              g_us_sd_load_error_code = EC_STORING_FUNCTIONS_ARE_DISABLED;
                                                                                              #endif
3321   8                                                                              }
3322   7                                                                              else g_uc_gsch_no_of_loading = g_uc_gsch_sampling_step; //This is impossible to happen, use this 
             -as indicator of pre-mature termination
3323   7                                                                              
3324   7                                                                              //If there is no error code
3325   7                                                                              if (!g_us_sd_load_error_code){
3326   8                                                                                      //Check the block property of the SD card block loaded
3327   8                                                                                      g_uc_gsch_sd_block_property = g_uc_sd_data_buffer[2];
3328   8                              
3329   8                                                                                      //If for any reason g_uc_gsch_sd_block_property is neither 0x01 nor 0x02
3330   8                                                                                      if (g_uc_gsch_sd_block_property != 0x01 && g_uc_gsch_sd_block_property != 0x02)
3331   8                                                                                              g_us_sd_load_error_code = EC_UNEXPECTED_BLOCK_PROPERTY;
3332   8                              
3333   8                                                                                      //If the block property shows that this block is end block
3334   8                                                                                      //Ian (2012-05-15): By the format defined when we write to SD card, if the block property is not
             - 0x02,
3335   8                                                                                      //                                      then something is wrong with the data.
3336   8                                                                                      if(g_uc_gsch_sd_block_property == 0x02)
3337   8                                                                                              //Add the number of loading
3338   8                                                                                              g_uc_gsch_no_of_loading++;
3339   8                                                                              }
3340   7              
3341   7                                                                              //If there is any error code during this reading, it would have been pretty disastrous
3342   7                                                                              //Hence, terminates the sending immediately, go to GSCH_STATE_GROUND_PASS again,
3343   7                                                                              //It is better than sending wrong, funny data. No retry is possible for this case
3344   7                                                                              if (g_us_sd_load_error_code){
3345   8                                                                                      //Set error code as interrupted loading
3346   8                                                                                      g_us_sd_load_error_code = EC_LOADING_INTERRUPTED_WITH_ERROR;
3347   8      
3348   8                                                                                      #if (SENDING_ENABLE == 1)
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 57  

3349   8                                                                                      //Terminates send stored data state but gives ACK_MSG to MCC
3350   8                                                                                      groundTerminateSendStoredDataWithAckMsg();
3351   8                                                                                      #endif
3352   8                                                                              }
3353   7                                                                      }
3354   6      
3355   6                                                                      //If it reaches this point without error code, 
3356   6                                                                      //It means all data which is not supposed to be sent would have been skipped. 
3357   6                                                                      //Attempt to load data for the last time occurs here, given that the loading is not finished earli
             -er
3358   6                                                                      if (!g_us_sd_load_error_code && !(g_uc_strsnd_flag & STRNG_FLAG_SD_LOAD_COMPLETED)){
3359   7                                                                              #if (STORING_ENABLE == 1)
3360   7                                                                              g_us_sd_load_error_code = loadDataProtected(g_uc_gsch_subsystem_to_load,g_uc_gsch_data_type_to_lo
             -ad,g_ul_obs_initial_bp,g_ul_obs_end_bp);
3361   7                                                                              //If data is corrupted at this point, still proceeds, nothing to lose
3362   7                                                                              if (g_us_sd_load_error_code == EC_SD_ALL_STORED_DATA_IS_CORRUPTED) g_us_sd_load_error_code = EC_S
             -UCCESSFUL;                                                
3363   7                                                                              #else
                                                                                      g_us_sd_load_error_code = EC_STORING_FUNCTIONS_ARE_DISABLED;
                                                                                      #endif
3366   7                                                                      }
3367   6                                                              }
3368   5                                                              //If for any reason g_uc_gsch_sd_block_property is neither 0x01 nor 0x02
3369   5                                                              else {
3370   6                                                                      //If there is any error code during this reading, it would have been pretty disastrous
3371   6                                                                      //Hence, terminates the sending immediately, go to GSCH_STATE_GROUND_PASS again,
3372   6                                                                      //It is better than sending wrong, funny data. No retry is possible for this case
3373   6                                                                      g_us_sd_load_error_code = EC_UNEXPECTED_BLOCK_PROPERTY;
3374   6      
3375   6                                                                      #if (SENDING_ENABLE == 1)
3376   6                                                                      //Terminates send stored data state but gives ACK_MSG to MCC
3377   6                                                                      groundTerminateSendStoredDataWithAckMsg();
3378   6                                                                      #endif
3379   6                                                              }
3380   5      
3381   5                                                              //If there is no error code so far, proceeds by sending the data
3382   5                                                              if(!g_us_sd_load_error_code){   
3383   6                                                                      //The sending data is purposely put here so that if the loading data failed
3384   6                                                                      //Next turn it will come back to this state (not somewhere else)
3385   6                                                                      g_uc_strsnd_flag &= ~SNDNG_FLAG_COMPLETED;
3386   6      
3387   6                                                                      #if (SENDING_ENABLE == 1)
3388   6                                                                      //Generate new sending request to the beaconHandler
3389   6                                                                      groundKeepSendRequest();                                                
3390   6                                                                      #endif
3391   6                                                              }
3392   5      
3393   5                                                              //Else, if the error in loading is neither EC_UNEXPECTED_BLOCK_PROPERTY nor EC_LOADING_INTERRUPTED_
             -WITH_ERROR, 
3394   5                                                              //increase retry counter, try again next time
3395   5                                                              else if ((g_us_sd_load_error_code != EC_UNEXPECTED_BLOCK_PROPERTY) && (g_us_sd_load_error_code != E
             -C_LOADING_INTERRUPTED_WITH_ERROR)) 
3396   5                                                                      g_uc_gsch_loading_retry_counter++;
3397   5                              
3398   5                                                              #if (SENDING_ENABLE == 1)
3399   5                                                              //Other error would be unhandled, terminates the sending immediately                            
3400   5                                                              else
3401   5                                                                      //Terminates send stored data state but gives ACK_MSG to MCC
3402   5                                                                      groundTerminateSendStoredDataWithAckMsg();
3403   5                                                              #endif
3404   5      
3405   5                                                              //If for any reason the number of loading trial has gone too many times
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 58  

3406   5                                                              //Terminates Groundpass
3407   5                                                              if (g_uc_gsch_loading_retry_counter > GSCH_LOADING_FAIL_LIMIT){
3408   6                                                                      //Set SD load error code as SD card irresponsive
3409   6                                                                      g_us_sd_load_error_code = EC_SD_CARD_IRRESPONSIVE;
3410   6              
3411   6                                                                      #if (SENDING_ENABLE == 1)
3412   6                                                                      //Terminates send stored data state but gives ACK_MSG to MCC
3413   6                                                                      groundTerminateSendStoredDataWithAckMsg();
3414   6                                                                      #endif
3415   6                                                              }
3416   5                                                      } 
3417   4      
3418   4                                                      //If both sending and loading are completed
3419   4                                                      else if ((g_uc_strsnd_flag & SNDNG_FLAG_COMPLETED) && (g_uc_strsnd_flag & STRNG_FLAG_SD_LOAD_COMPLET
             -ED)){
3420   5                                                              //Don't reset the sending and loading flags here
3421   5                                                              //Because in the event of retry, it cannot come back to this state
3422   5                                                              //But reset the sending and loading flags at the beginning of sending
3423   5                                                              //Reset sending and loading flags
3424   5                                                              //In ground pass, all flags will be reset, anyway
3425   5                                                              g_uc_strsnd_flag &= ~SNDNG_FLAG_COMPLETED;
3426   5                                                              g_uc_strsnd_flag &= ~STRNG_FLAG_SD_LOAD_COMPLETED;
3427   5                              
3428   5                                                              //Reset transitional state monitoring flag
3429   5                                                              g_uc_gsch_flag &= ~GSCH_FLAG_MONITOR_TRANSITIONAL;
3430   5      
3431   5                                                              //Reset g_uc_gsch_loading_retry_counter
3432   5                                                              g_uc_gsch_loading_retry_counter = 0;
3433   5      
3434   5                                                              //Reset recovery package block pointer
3435   5                                                              str_bp.ul_package_recovery_write_p = SD_BP_PACKAGE_RECOVERY_START;
3436   5      
3437   5                                                              #if (SENDING_ENABLE == 1)
3438   5                                                              //Release beacon's claim
3439   5                                                              groundReleaseClaimBeacon();
3440   5                                                              #endif
3441   5              
3442   5                                                              //Go back to GSCH_STATE_GROUND_PASS
3443   5                                                              str_obdh_hk.uc_gsch_state = GSCH_STATE_GROUND_PASS;                     
3444   5                                                      }
3445   4                                                      break;
3446   4              
3447   4                                              //Besides the above cases, something wrong with the beacon, terminates the sending
3448   4                                              default:
3449   4                                                      #if (SENDING_ENABLE == 1)
3450   4                                                      //Terminates send stored data state
3451   4                                                      groundTerminateSendStoredData();
3452   4                                                      #endif
3453   4                                                      break;
3454   4                                      }
3455   3                                      //See if we should put something here: to check if we receive further command and terminates the curre
             -nt sending
3456   3                                      //Get AX.25 no of frame from COMM board twice
3457   3                                      for (l_us_i = 0; l_us_i < 2; l_us_i++)
3458   3                                              if (isisI2C(IMC_ADDR,IMC_I2C_GET_NOFR,0)) 
3459   3                                                      break;
3460   3      
3461   3                                      if (l_us_i == 2 && g_uc_i2c_data_in[0]) //If it is successful & there is something in the COMM board, 
             -then terminates the current sending
3462   3                                              //Terminates send stored data state
3463   3                                              groundTerminateSendStoredData();
3464   3                              }
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 59  

3465   2                              #if (SENDING_ENABLE == 1)
3466   2                              //If beacon is not found to be functional at this stage, return to GSCH_STATE_GROUND_PASS
3467   2                              else 
3468   2                                      //Terminates send stored data state
3469   2                                      groundTerminateSendStoredData();
3470   2      
3471   2                              //If at any point timeout for monitoring occurs
3472   2                              if (g_us_gsch_monitoring_transitional_period > TIME_LIMIT_GSCH_TRANSITIONAL_STATE_S)
3473   2                                      //Terminates send stored data state
3474   2                                      groundTerminateSendStoredData();
3475   2                              #endif
3476   2      
3477   2                              break;
3478   2      
3479   2                      //When GSCH is dead
3480   2                      case GSCH_STATE_DEAD:
3481   2                              //This flag should be raised every second
3482   2                              if (g_uc_gsch_flag & GSCH_FLAG_INITIAL_CHECK){
3483   3                                      //Reset first the checking flag
3484   3                                      g_uc_gsch_flag &= ~GSCH_FLAG_CHECK_RESET;
3485   3              
3486   3                                      //Increase monitoring period
3487   3                                      g_us_gsch_monitoring_period++;
3488   3              
3489   3                                      //If the monitoring period has exceeding TIME_LIMIT_GSCH_DEAD_STATE_S
3490   3                                      //Enter recovery state
3491   3                                      if (g_us_gsch_monitoring_period > TIME_LIMIT_GSCH_DEAD_STATE_S){
3492   4                                              resetGSCHCounters();
3493   4                                              str_obdh_hk.uc_gsch_state = GSCH_STATE_RECOVERY;
3494   4                                      }
3495   3                              }                       
3496   2                              break;
3497   2      
3498   2                      //When GSCH is recovering
3499   2                      case GSCH_STATE_RECOVERY:
3500   2                              //This flag should be raised every second
3501   2                              if (g_uc_gsch_flag & GSCH_FLAG_INITIAL_CHECK){
3502   3                                      //Reset first the checking flag
3503   3                                      g_uc_gsch_flag &= ~GSCH_FLAG_CHECK_RESET;
3504   3                      
3505   3                                      //Increase monitoring period
3506   3                                      g_us_gsch_monitoring_period++;
3507   3              
3508   3                                      //If the monitoring period has exceeding TIME_LIMIT_GSCH_RECOVERY_STATE_S
3509   3                                      //Enter dead state again
3510   3                                      if (g_us_gsch_monitoring_period > TIME_LIMIT_GSCH_RECOVERY_STATE_S){
3511   4                                              resetGSCHCounters();
3512   4                                              str_obdh_hk.uc_gsch_state = GSCH_STATE_DEAD;
3513   4                                      }                               
3514   3                                      //Else 
3515   3                                      else{
3516   4                                              //Try to communicate with COMM board
3517   4                                              l_us_comm_error_code = isisI2C(ITC_ADDR,ITC_I2C_TRN_UPTM,0);
3518   4              
3519   4                                              //If the communication is successful, enters one of the following states:
3520   4                                              //1) If (g_uc_gsch_flag & GSCH_FLAG_GROUNDPASS_STARTED) flag is raised, go to groundpass mode
3521   4                                              if(!l_us_comm_error_code){
3522   5                                                      //If there is currently groundpass going on
3523   5                                                      if      ((g_uc_gsch_flag & GSCH_FLAG_GROUNDPASS_STARTED))
3524   5                                                              str_obdh_hk.uc_gsch_state = GSCH_STATE_GROUND_PASS;
3525   5                                                      else
3526   5                                                              str_obdh_hk.uc_gsch_state = GSCH_STATE_IDLE;
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 60  

3527   5                                              }
3528   4                                      }
3529   3                              }                       
3530   2                              break;
3531   2      
3532   2                      //No other state is possible
3533   2                      default:
3534   2                              break;
3535   2              }
3536   1      
3537   1              #if (SENDING_ENABLE == 1)
3538   1              //Check if at any point of time the sending time has gone too long, terminates the transitional (sending)
             - state
3539   1              if (g_us_gsch_total_sending_time >= TIME_LIMIT_GROUND_PASS_S && (g_uc_gsch_flag & GSCH_FLAG_TOTAL_SENDING
             -))
3540   1                      groundTerminateSendStoredData();
3541   1              #endif
3542   1      
3543   1              //If for any reason there is no communication occur, go to GSCH_STATE_DEAD
3544   1              if (g_uc_gsch_comm_retry_counter > GSCH_COMM_FAIL_LIMIT){
3545   2                      //Reset all counters and flags
3546   2                      g_uc_gsch_comm_retry_counter = 0;
3547   2      
3548   2                      //Terminates transitional states
3549   2                      groundTerminateTransitionalState();
3550   2      
3551   2                      //Set GSCH to dead state
3552   2                      str_obdh_hk.uc_gsch_state = GSCH_STATE_DEAD;                    
3553   2              }
3554   1      
3555   1              #if (EXTRA_ENABLE == 1)
3556   1              //If, for whatever reason there is no communication with MCC until timeout
3557   1              if (g_ul_gsch_time_elapsed_since_last_communication_with_mcc >= TIME_LIMIT_NO_COMM_WITH_MCC_S) {
3558   2                      //Mark reset cause as RESET_SOURCE_GSCH_WATCHDOG 
3559   2                      str_obdh_data.uc_sat_rstsrc = RESET_SOURCE_GSCH_WATCHDOG;
3560   2      
3561   2                      //Trigger reset satellite every 5 minutes (prevent from satellite's reset failure)
3562   2                      g_ul_gsch_time_elapsed_since_last_communication_with_mcc -= 300;
3563   2      
3564   2                      //Trigger satellite's reset
3565   2                      callReset(OBDH_CMD_RESET_SAT);  
3566   2              }
3567   1              #endif
3568   1      
3569   1              #endif
3570   1      }
3571          #endif
3572          
3573          #if (SATELLITE_SCHEDULE_HANDLER_ENABLE == 1)
3574          //------------------------------------------------------------------------------------
3575          // To handle satellite scheduled command
3576          //------------------------------------------------------------------------------------
3577          // Function's test result: untested
3578          //------------------------------------------------------------------------------------
3579          void satelliteScheduleHandler (void)
3580          {
3581   1              unsigned long l_ul_nearest_scheduled_time;
3582   1              unsigned short l_us_i;
3583   1              unsigned short l_us_error_code;
3584   1      
3585   1              //Check if there is something in the scheduler
3586   1              if (str_obdh_hk.uc_scheduler_block_size){
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 61  

3587   2                      //If the schedule is not arranged, arrange it first
3588   2                      if(!(g_uc_evha_flag & EVENT_FLAG_SCHEDULE_IS_REARRANGED)){
3589   3                              rearrangeSchedule();
3590   3                              g_uc_evha_flag |= EVENT_FLAG_SCHEDULE_IS_REARRANGED;
3591   3                      }
3592   2      
3593   2                      //Check the schedule, so long as there is a scheduled command, attempt to
3594   2                      //upload it to the command queue. So long as the upload is successful or 
3595   2                      //there is an invalid command length but there is any scheduled command
3596   2                      //left, keeps uploading till all the schduled 
3597   2                      //command is uploaded. Not so if the error code is EC_COMMAND_ALREADY_EXIST
3598   2                      //or EC_COMMAND_QUEUE_FULL, we will stop uploading the command
3599   2                      do {
3600   3                      
3601   3                              //Check nearest scheduled time
3602   3                              l_ul_nearest_scheduled_time = str_scheduler.ul_scheduled_time[str_scheduler.uc_reindexing[0]];
3603   3      
3604   3                              //Initialize the error code as EC_SCHEDULE_STOP_UPLOADING_COMMAND
3605   3                              //In the case where the schedule does not upload any command and the last upload
3606   3                              //was successful, and the nearest schedule time reading is greater than zero,
3607   3                              //This error code will act as a way of exit from this infinite loop
3608   3                              l_us_error_code = EC_SCHEDULE_STOP_UPLOADING_COMMAND;
3609   3              
3610   3                              #if (CQUEUE_ENABLE == 1)
                                      //If satellite time has exceeded or equal to the scheduled time and the 
                                      //nearest scheduled time is not zero, upload the schedule to the command queue
                                      //then, upon successful uploading, remove the scheduled item from the schedule
                                      if ((l_ul_nearest_scheduled_time > 0) && (str_obdh_data.ul_obc_time_s >= l_ul_nearest_scheduled_time)){
                                              //Upload the command here!!
                                              //Upload command header
                                              g_uc_command_entry[0] = 0xBB;
                                              g_uc_command_entry[1] = str_scheduler.us_cmd[str_scheduler.uc_reindexing[0]] >> 8;
                                              g_uc_command_entry[2] = str_scheduler.us_cmd[str_scheduler.uc_reindexing[0]];
                                              g_uc_command_entry[3] = str_scheduler.uc_arg_length[str_scheduler.uc_reindexing[0]];
              
                                              //Limit the scheduler length to MAX_CMD_ARG_LEN for making command
                                              if (str_scheduler.uc_arg_length[str_scheduler.uc_reindexing[0]] > MAX_CMD_ARG_LEN)
                                                      str_scheduler.uc_arg_length[str_scheduler.uc_reindexing[0]] = MAX_CMD_ARG_LEN;
              
                                              //Upload command argument (if any)
                                              for (l_us_i = 0; l_us_i < str_scheduler.uc_arg_length[str_scheduler.uc_reindexing[0]]; l_us_i++)
                                                      g_uc_command_entry[l_us_i+COMMAND_HEADER_SIZE] = str_scheduler.uc_arg[str_scheduler.uc_reindexing[0]]
             -[l_us_i];
              
                                              #if (CRC_ENABLE == 1)
                                              //Create CRC16 bytes for the command generated
                                              insertCRC16(g_uc_command_entry,str_scheduler.uc_arg_length[str_scheduler.uc_reindexing[0]]+COMMAND_HEA
             -DER_SIZE);
                                              #endif
              
                                              //Attempt to upload the scheduled item to the command queue
                                              l_us_error_code = addCommandToQueue();
                                              
                                              #if (EVENT_HANDLER_ENABLE == 1)
                                              //dec22_yc here add even logging for command added to queue tested                      
                                              eventHandler(EV_SCHEDULER_TO_COMMAND+l_us_error_code,
                                                      str_scheduler.us_cmd[str_scheduler.uc_reindexing[0]] >> 8,str_scheduler.us_cmd[str_scheduler.uc_reind
             -exing[0]],
                                                              str_scheduler.uc_arg[str_scheduler.uc_reindexing[0]][0],
                                                              str_scheduler.uc_arg[str_scheduler.uc_reindexing[0]][1],
                                                              str_scheduler.uc_arg[str_scheduler.uc_reindexing[0]][2],
                                                              str_scheduler.uc_arg[str_scheduler.uc_reindexing[0]][3]);
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 62  

                                              #endif
              
                                              //Remove top scheduled command, if adding command is successful
                                              //Or if the error code for adding command is due to unacceptable command length
                                              //
                                              //If the adding command to the queue is not successful, the top most
                                              //Schedule will still be there. It will try to be uploaded again
                                              //In the next second
                                              //
                                              //There are only four possible error codes for uploading a command to a queue
                                              // 1) EC_SUCCESSFUL
                                              // 2) EC_COMMAND_ALREADY_EXIST
                                              // 3) EC_INVALID_COMMAND_LENGTH
                                              // 4) EC_COMMAND_QUEUE_FULL
                                              //
                                              //Error codes (2) and (4) allow re-attempt
                                              if (!l_us_error_code || l_us_error_code == EC_INVALID_COMMAND_LENGTH) 
                                                      removeSchedule(1,1);
                                      }
                                      #else
3666   3                              //If satellite time has exceeded or equal to the scheduled time and the 
3667   3                              //nearest scheduled time is not zero, upload the schedule to the command queue
3668   3                              //then, upon successful uploading, remove the scheduled item from the schedule
3669   3                              if ((l_ul_nearest_scheduled_time > 0) && (str_obdh_data.ul_obc_time_s >= l_ul_nearest_scheduled_time)){
3670   4                                      //Limit the scheduler length to MAX_CMD_ARG_LEN for making command
3671   4                                      if (str_scheduler.uc_arg_length[str_scheduler.uc_reindexing[0]] > MAX_CMD_ARG_LEN)
3672   4                                              l_us_error_code = EC_INVALID_COMMAND_LENGTH;
3673   4                                      else{
3674   5                                              //Upload the command here!!
3675   5                                              //Upload command header
3676   5                                              g_uc_call_task_buffer[0] = 0xBB;
3677   5                                              g_uc_call_task_buffer[1] = str_scheduler.us_cmd[str_scheduler.uc_reindexing[0]] >> 8;
3678   5                                              g_uc_call_task_buffer[2] = str_scheduler.us_cmd[str_scheduler.uc_reindexing[0]];
3679   5                                              g_uc_call_task_buffer[3] = 0x00;
3680   5                                              g_uc_call_task_buffer[4] = str_scheduler.uc_arg_length[str_scheduler.uc_reindexing[0]];
3681   5              
3682   5                                              //Upload command argument (if any)
3683   5                                              for (l_us_i = 0; l_us_i < str_scheduler.uc_arg_length[str_scheduler.uc_reindexing[0]]; l_us_i++)
3684   5                                                      g_uc_call_task_buffer[l_us_i+COMMAND_HEADER_SIZE+1] = str_scheduler.uc_arg[str_scheduler.uc_reindexi
             -ng[0]][l_us_i];
3685   5              
3686   5                                              #if (CRC_ENABLE == 1)
3687   5                                              //Create CRC16 bytes for the command generated
3688   5                                              insertCRC16(g_uc_call_task_buffer,str_scheduler.uc_arg_length[str_scheduler.uc_reindexing[0]]+COMMAND
             -_HEADER_SIZE+1);
3689   5                                              #endif
3690   5              
3691   5                                              //Mark as successful
3692   5                                              l_us_error_code = EC_SUCCESSFUL;
3693   5                                      }
3694   4      
3695   4                                      //Always removing the top schedule
3696   4                                      removeSchedule(1,1);
3697   4      
3698   4                                      //If there is no error
3699   4                                      if (!l_us_error_code) {
3700   5                                              //Proceeds to executing the command
3701   5                                              commandControlModule(g_uc_call_task_buffer,g_uc_call_task_buffer);
3702   5      
3703   5                                              //Clear call task buffer header
3704   5                                              g_uc_call_task_buffer[0] = 0x00;
3705   5                                      }
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 63  

3706   4                              }
3707   3                              #endif
3708   3                      //Keep uploading the command if:
3709   3                      // 1) Error code while updating the command is either successful or invalid command length, and
3710   3                      // 2) There is still something in the scheduler
3711   3                      // 3) The nearest scheduled time (that is obtained from the schedule) is greater than zero
3712   3                      } while ((!l_us_error_code || l_us_error_code == EC_INVALID_COMMAND_LENGTH) && str_obdh_hk.uc_scheduler_
             -block_size && l_ul_nearest_scheduled_time > 0);
3713   2              }
3714   1      }
3715          #endif
3716          
3717          #if (SATELLITE_MODE_HANDLER_ENABLE == 1)
3718          #if (BODY_RATE_HANDLER_ENABLE == 1)
3719          #if (ADCS_CMD_ENABLE == 1)
3720          #if (PWRS_CMD_ENABLE == 1)
3721          //------------------------------------------------------------------------------------
3722          // To handle body rate control of the satellite
3723          //------------------------------------------------------------------------------------
3724          // This handler assumes that ADS is ON and PWRS is functional
3725          // If any of the two is not satisfied, this handler should be disabled elsewhere
3726          // in the program.
3727          //------------------------------------------------------------------------------------
3728          void bodyRateHandler (void)
3729          {
3730   1              unsigned short l_us_error_code = EC_INIT;
3731   1      
3732   1              //Only check if it is time to check
3733   1              if ((str_obdh_hk.us_brh_flag & BRH_CHECK_FILTER) == BRH_CHECK_CONDITION){
3734   2      
3735   2                      //Reset check flag
3736   2                      str_obdh_hk.us_brh_flag &= ~BRH_FLAG_CHECK;
3737   2      
3738   2                      //If there is an error at this state, try to recover first
3739   2                      if (str_obdh_hk.us_brh_flag & BRH_FLAG_ERROR){
3740   3                              //Attempt to communicate with PWRS
3741   3                              #if (DEBUGGING_FEATURE == 1)
3742   3                              l_us_error_code = pwrsGetData((unsigned char)DATA_PWRS_US_FIRMWARE_VER, 0);
3743   3                              #else
                                      l_us_error_code = pwrsGetData((unsigned char)DATA_PWRS_US_FIRMWARE_VER);
                                      #endif
3746   3      
3747   3                              //If there is no error, then attempt to recover is successful, reset the error flag
3748   3                              //And the error counter
3749   3                              if(!l_us_error_code) {
3750   4                                      str_obdh_hk.us_brh_flag &= ~BRH_FLAG_ERROR;
3751   4                                      g_uc_brh_retry_counter = 0;
3752   4                                      g_uc_brh_timeout_retry_counter = 0;
3753   4                              }
3754   3                      }
3755   2      
3756   2                      //If there is no error at this point of time, we can start considering the current state of ACS
3757   2                      if (!(str_obdh_hk.us_brh_flag & BRH_FLAG_ERROR)){
3758   3                              //Check if timeout flag is not set
3759   3                              if (!(str_obdh_hk.us_brh_flag & BRH_FLAG_DET_TO)){
3760   4                                      //Check whether what we desire state has been achieved, if not, just skip this check
3761   4                                      if ((str_obdh_hk.us_brh_flag & BRH_FLAG_DET_WT) && (((str_obdh_hk.us_brh_flag & BRH_FLAG_DET_ON) && (s
             -tr_obdh_hk.us_brh_flag & BRH_FLAG_DET_RS)) || (!(str_obdh_hk.us_brh_flag & BRH_FLAG_DET_ON) && !(str_obdh_hk.us_brh_flag
             - & BRH_FLAG_DET_RS)))){
3762   5                                              //Drop waiting & timeout flags
3763   5                                              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_DET_WT;
3764   5                                              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_DET_TO;
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 64  

3765   5      
3766   5                                              //Reset waiting time and timeout retry counter
3767   5                                              g_uc_brh_wait_det_time_s = 0;
3768   5                                              g_uc_brh_timeout_retry_counter = 0;
3769   5                                      }
3770   4      
3771   4                                      //If currently we are not waiting for something to happen (Detumbling mode has achieved its desired st
             -ate)
3772   4                                      if (!(str_obdh_hk.us_brh_flag & BRH_FLAG_DET_WT)){
3773   5                                              //If timeout occurs and Detumbling mode is ON (always undesired), turn OFF Detumbling mode
3774   5                                              //Ian (2012-05-15): it is noted that this code segment is almost identical with other code below
3775   5                                              if ((str_obdh_hk.us_brh_flag & BRH_FLAG_BR_ST_TO) && (str_obdh_hk.us_brh_flag & BRH_FLAG_DET_ON)){
3776   6                                                      //Set Detumbling mode desired output to OFF (for repetition purpose, in case it failed)
3777   6                                                      str_obdh_hk.us_brh_flag &= ~BRH_FLAG_DET_RS;
3778   6      
3779   6                                                      //Set waiting flag
3780   6                                                      str_obdh_hk.us_brh_flag |= BRH_FLAG_DET_WT;
3781   6                                                      
3782   6                                                      //Clear stabilizing flag (stabilizing time is over)
3783   6                                                      str_obdh_hk.us_brh_flag &= ~BRH_FLAG_STABILIZING;
3784   6      
3785   6                                                      //Attempt to set Detumbling mode to OFF immediately.
3786   6                                                      #if (DEBUGGING_FEATURE == 1)
3787   6                                                      l_us_error_code = adcsSetMode(ADCS_MODE_IDLE,0,0);
3788   6                                                      #else
                                                              l_us_error_code = adcsSetMode(ADCS_MODE_IDLE,0);
                                                              #endif
3791   6      
3792   6                                                      //If this fail, increase the retry counter, and if it is successful, reset it.
3793   6                                                      if (l_us_error_code) g_uc_brh_retry_counter++;
3794   6                                                      else g_uc_brh_retry_counter = 0;                                                
3795   6                                              }
3796   5      
3797   5                                              //If timeout does not occur and Detumbling mode is ON
3798   5                                              //Monitor its current state, handle if there is any undesired state
3799   5                                              else if (!(str_obdh_hk.us_brh_flag & BRH_FLAG_BR_ST_TO) && (str_obdh_hk.us_brh_flag & BRH_FLAG_DET_ON
             -)){
3800   6                                                      //Check stabilizing flag: if stabilizing flag is set, then this is during stabilization
3801   6                                                      if (str_obdh_hk.us_brh_flag & BRH_FLAG_STABILIZING){
3802   7                                                              //If this is stabilizing state, Detumbling mode should be ON so long as BR_LOW is not set
3803   7                                                              //However, if BR_LOW is set, Detumbling mode should be turned OFF, and stabilizing time is over
3804   7                                                              if (str_obdh_hk.us_brh_flag & BRH_FLAG_BR_LOW){
3805   8                                                                      //Set Detumbling mode desired output to OFF (for repetition purpose, in case it failed)
3806   8                                                                      str_obdh_hk.us_brh_flag &= ~BRH_FLAG_DET_RS;
3807   8                      
3808   8                                                                      //Set waiting flag
3809   8                                                                      str_obdh_hk.us_brh_flag |= BRH_FLAG_DET_WT;
3810   8                                                                      
3811   8                                                                      //Clear stabilizing flag (stabilizing time is over, man)
3812   8                                                                      str_obdh_hk.us_brh_flag &= ~BRH_FLAG_STABILIZING;
3813   8      
3814   8                                                                      //Attempt to set Detumbling mode to OFF immediately.
3815   8                                                                      #if (DEBUGGING_FEATURE == 1)
3816   8                                                                      l_us_error_code = adcsSetMode(ADCS_MODE_IDLE,0,0);
3817   8                                                                      #else
                                                                              l_us_error_code = adcsSetMode(ADCS_MODE_IDLE,0);
                                                                              #endif
3820   8                      
3821   8                                                                      //If this fail, increase the retry counter, and if it is successful, reset it.
3822   8                                                                      if (l_us_error_code) g_uc_brh_retry_counter++;
3823   8                                                                      else g_uc_brh_retry_counter = 0;                                                
3824   8                                                              }
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 65  

3825   7                                                      }
3826   6      
3827   6                                                      //Else, this is not stabilizing state
3828   6                                                      else{                                                   
3829   7                                                              //This is very funny, because if Detumbling mode is ON, we should be in stabilizing state. 
3830   7                                                              //Unknown state, very dangerous to let Detumbling mode ON, turn it OFF!
3831   7                                                              //Set Detumbling mode desired output to OFF (for repetition purpose, in case 1st time it failed)
3832   7                                                              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_DET_RS;
3833   7              
3834   7                                                              //Set waiting flag
3835   7                                                              str_obdh_hk.us_brh_flag |= BRH_FLAG_DET_WT;
3836   7                                                              
3837   7                                                              //Attempt to set Detumbling mode to OFF immediately.
3838   7                                                              #if (DEBUGGING_FEATURE == 1)
3839   7                                                              l_us_error_code = adcsSetMode(ADCS_MODE_IDLE,0,0);
3840   7                                                              #else
                                                                      l_us_error_code = adcsSetMode(ADCS_MODE_IDLE,0);
                                                                      #endif
3843   7              
3844   7                                                              //If this fail, increase the retry counter, and if it is successful, reset it.
3845   7                                                              if (l_us_error_code) g_uc_brh_retry_counter++;
3846   7                                                              else g_uc_brh_retry_counter = 0;                                                
3847   7                                                      }
3848   6                                              }
3849   5      
3850   5                                              //If timeout does not occur and Detumbling mode is OFF
3851   5                                              //Monitor its current state, handle if there is any undesired state
3852   5                                              else if (!(str_obdh_hk.us_brh_flag & BRH_FLAG_BR_ST_TO) && !(str_obdh_hk.us_brh_flag & BRH_FLAG_DET_O
             -N)){
3853   6                                                      //Check stabilizing flag: if stabilizing flag is set, then this is during stabilization
3854   6                                                      if (str_obdh_hk.us_brh_flag & BRH_FLAG_STABILIZING){
3855   7                                                              //This is undesired, if for whatsoever reason Detumbling mode is OFF though it is desired to be ON
3856   7                                                              //Set Detumbling mode desired output to ON (for repetition purpose, in case 1st time it failed)
3857   7                                                              str_obdh_hk.us_brh_flag |= BRH_FLAG_DET_RS;
3858   7              
3859   7                                                              //Set waiting flag
3860   7                                                              str_obdh_hk.us_brh_flag |= BRH_FLAG_DET_WT;
3861   7      
3862   7                                                              //Set error code as error init
3863   7                                                              l_us_error_code = EC_INIT;
3864   7                                                              
3865   7                                                              //Attempt to set Detumbling mode to ON immediately if ADS has been ON for at least TIME_DELAY_ACS_T
             -O_ON_AFTER_ADS_ON_S second(s).
3866   7                                                              if (g_ul_ads_uptime_s >= TIME_DELAY_ACS_TO_ON_AFTER_ADS_ON_S){
3867   8                                                                      #if (DEBUGGING_FEATURE == 1)
3868   8                                                                      l_us_error_code = adcsSetMode(g_uc_desired_adcs_mode,str_obdh_par.ul_det_uptime_limit_s/10,0);
3869   8                                                                      #else
                                                                              l_us_error_code = adcsSetMode(g_uc_desired_adcs_mode,str_obdh_par.ul_det_uptime_limit_s/10);
                                                                              #endif
3872   8                                                              }
3873   7              
3874   7                                                              //If this fail, increase the retry counter, and if it is successful, reset it.
3875   7                                                              if (l_us_error_code && l_us_error_code != EC_INIT) g_uc_brh_retry_counter++;
3876   7                                                              else g_uc_brh_retry_counter = 0;                                                
3877   7                                                      }
3878   6      
3879   6                                                      //Else, this is not stabilizing state
3880   6                                                      else{
3881   7                                                              //If this is not stabilizing state, then we can see what is going on
3882   7                                                              //If BR_HI is set, try to stabilize the satellite (turn ON detumbling mode). Else, leave it alone
3883   7                                                              if (str_obdh_hk.us_brh_flag & BRH_FLAG_BR_HI){
3884   8                                                                      //Set detumbling mode desired output to ON (for repetition purpose, in case 1st time it failed)
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 66  

3885   8                                                                      str_obdh_hk.us_brh_flag |= BRH_FLAG_DET_RS;
3886   8                      
3887   8                                                                      //Set waiting flag
3888   8                                                                      str_obdh_hk.us_brh_flag |= BRH_FLAG_DET_WT;
3889   8                                                                      
3890   8                                                                      //Set stabilizing flag
3891   8                                                                      str_obdh_hk.us_brh_flag |= BRH_FLAG_STABILIZING;
3892   8                                                                      
3893   8                                                                      //Set error code as error init
3894   8                                                                      l_us_error_code = EC_INIT;
3895   8                                                                      
3896   8                                                                      //Attempt to set detumbling mode to ON immediately
3897   8                                                                      if (g_ul_ads_uptime_s >= TIME_DELAY_ACS_TO_ON_AFTER_ADS_ON_S){
3898   9                                                                              #if (DEBUGGING_FEATURE == 1)
3899   9                                                                              l_us_error_code = adcsSetMode(g_uc_desired_adcs_mode,str_obdh_par.ul_det_uptime_limit_s/10,0);
3900   9                                                                              #else
                                                                                      l_us_error_code = adcsSetMode(g_uc_desired_adcs_mode,str_obdh_par.ul_det_uptime_limit_s/10);
                                                                                      #endif
3903   9                                                                      }
3904   8                      
3905   8                                                                      //If this fail, increase the retry counter, and if it is successful, reset it.
3906   8                                                                      if (l_us_error_code && l_us_error_code != EC_INIT) g_uc_brh_retry_counter++;
3907   8                                                                      else g_uc_brh_retry_counter = 0;                                                
3908   8                                                              }
3909   7                                                      }
3910   6                                              }
3911   5      
3912   5                                              //If timeout occurs and detumbling mode is OFF, it is always a desired state, do nothing
3913   5                                      }
3914   4                              }
3915   3                              //But if we are waiting detumbling mode to be in the desired state and there is 
3916   3                              //time out flag, clear the timeout flag and the timer, but increase the timeout retry counter
3917   3                              else if ((str_obdh_hk.us_brh_flag & BRH_FLAG_DET_WT) && (str_obdh_hk.us_brh_flag & BRH_FLAG_DET_TO)){
3918   4                                      //Reset waiting time
3919   4                                      g_uc_brh_wait_det_time_s = 0;
3920   4      
3921   4                                      //Reset timeout flag
3922   4                                      str_obdh_hk.us_brh_flag &= ~BRH_FLAG_DET_TO;
3923   4      
3924   4                                      //Increase timeout retry counter
3925   4                                      g_uc_brh_timeout_retry_counter++;
3926   4      
3927   4                                      //Set error code as error init
3928   4                                      l_us_error_code = EC_INIT;
3929   4      
3930   4                                      //Get what is the reference state of detumbling mode again
3931   4                                      if (str_obdh_hk.us_brh_flag & BRH_FLAG_DET_RS){
3932   5                                              //Only turn ON detumbling mode if ADS has been ON for at least 10s
3933   5                                              if (g_ul_ads_uptime_s >= TIME_DELAY_ACS_TO_ON_AFTER_ADS_ON_S){
3934   6                                                      //Attempt to set detumbling mode to the desired state again immediately
3935   6                                                      #if (DEBUGGING_FEATURE == 1)
3936   6                                                      l_us_error_code = adcsSetMode(g_uc_desired_adcs_mode,str_obdh_par.ul_det_uptime_limit_s/10,0);
3937   6                                                      #else
                                                              l_us_error_code = adcsSetMode(g_uc_desired_adcs_mode,str_obdh_par.ul_det_uptime_limit_s/10);
                                                              #endif
3940   6                                              }
3941   5                                      }
3942   4                                      else {
3943   5                                              //Attempt to set detumbling mode to the desired state again immediately
3944   5                                              #if (DEBUGGING_FEATURE == 1)
3945   5                                              l_us_error_code = adcsSetMode(ADCS_MODE_IDLE,0,0);
3946   5                                              #else
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 67  

                                                      l_us_error_code = adcsSetMode(ADCS_MODE_IDLE,0);
                                                      #endif
3949   5                                      }
3950   4      
3951   4                                      //If this fail, increase the retry counter, and if it is successful, reset it.
3952   4                                      if (l_us_error_code && l_us_error_code != EC_INIT) g_uc_brh_retry_counter++;
3953   4                                      else g_uc_brh_retry_counter = 0;
3954   4                              }
3955   3                              //If for any reason an unexpected state occur, recover it
3956   3                              else if (!(str_obdh_hk.us_brh_flag & BRH_FLAG_DET_WT) && (str_obdh_hk.us_brh_flag & BRH_FLAG_DET_TO)){
3957   4                                      //Reset waiting time
3958   4                                      g_uc_brh_wait_det_time_s = 0;
3959   4      
3960   4                                      //Reset timeout flag
3961   4                                      str_obdh_hk.us_brh_flag &= ~BRH_FLAG_DET_TO;
3962   4      
3963   4                                      //Reset timeout retry counter
3964   4                                      g_uc_brh_timeout_retry_counter = 0;
3965   4                              }
3966   3                                      
3967   3                      }
3968   2      
3969   2                      //If at any point of time, reset counter goes beyond the limit
3970   2                      if (g_uc_brh_retry_counter > BRH_RETRY_FAIL_LIMIT || g_uc_brh_timeout_retry_counter > BRH_TIMEOUT_RETRY_
             -FAIL_LIMIT){
3971   3                              //Reset retry counter
3972   3                              g_uc_brh_retry_counter = 0;
3973   3                              g_uc_brh_timeout_retry_counter = 0;
3974   3      
3975   3                              //Reset waiting time
3976   3                              g_uc_brh_wait_det_time_s = 0;
3977   3      
3978   3                              //Clear unrelevant (transitional) flags
3979   3                              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_DET_WT;
3980   3                              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_DET_TO;
3981   3                              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_STABILIZING;
3982   3      
3983   3                              //Set error flag
3984   3                              str_obdh_hk.us_brh_flag |= BRH_FLAG_ERROR;
3985   3                      }
3986   2      
3987   2              }
3988   1      
3989   1              //Readings always going on whether BRH is enabled or not, so long as this function is called
3990   1              //At any point of time, if the satellite is found to be having low body rate, considers it as stable
3991   1              if (str_obdh_hk.us_brh_flag & BRH_FLAG_BR_LOW)                                                          
3992   1                      //Stabilizing is completed successfully, set the successful flag
3993   1                      str_obdh_hk.us_brh_flag |= BRH_FLAG_ST_COMPLETED;
3994   1      
3995   1              //At any point of time, if the satellite is found to be having high body rate, considers it as unstable
3996   1              if (str_obdh_hk.us_brh_flag & BRH_FLAG_BR_HI)                                                           
3997   1                      //Stabilizing is completed successfully, set the successful flag
3998   1                      //Ian (2012-05-15): The case for BRH_FLAG_BR_HI and BRH_FLAG_BR_LOW is not made as an either-OR to preve
             -nt oscillatory behavior.
3999   1                      str_obdh_hk.us_brh_flag &= ~BRH_FLAG_ST_COMPLETED;
4000   1      
4001   1      }
4002          #endif
4003          #endif
4004          #endif
4005          
4006          #if (IDLE_MODE_HANDLER_ENABLE == 1)
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 68  

4007          #if (PWRS_CMD_ENABLE == 1)
4008          //------------------------------------------------------------------------------------
4009          // To control satellite state during idle mode
4010          //------------------------------------------------------------------------------------
4011          // Just like bodyRateHandler, this handler assumes that PWRS board is okay
4012          // if PWRS board is not okay, this handler will not be working at all.
4013          //
4014          // In addition, idle mode handler only works straightforwardly when bodyRateHandler
4015          // is disabled.
4016          //------------------------------------------------------------------------------------
4017          void idleModeHandler (void)
4018          {       
4019   1              unsigned short l_us_error_code = EC_INIT;
4020   1              unsigned char l_uc_desired_state;
4021   1      
4022   1              //In the idle mode, so long as bodyRateHandler is not enabled the ADS
4023   1              //and ACS channels must be turned OFF
4024   1              if (!(str_obdh_hk.us_brh_flag & BRH_FLAG_ENABLE)){
4025   2      
4026   2                      //Only check if it is time to check
4027   2                      if ((str_obdh_hk.us_imh_flag & IMH_CHECK_FILTER) == IMH_CHECK_CONDITION){
4028   3                              //Reset check flag
4029   3                              str_obdh_hk.us_imh_flag &= ~IMH_FLAG_CHECK;
4030   3              
4031   3                              //If there is an error at this state, try to recover first
4032   3                              if (str_obdh_hk.us_imh_flag & IMH_FLAG_ERROR){
4033   4                                      //Attempt to communicate with PWRS
4034   4                                      #if (DEBUGGING_FEATURE == 1)
4035   4                                      l_us_error_code = pwrsGetData((unsigned char)DATA_PWRS_US_FIRMWARE_VER, 0);
4036   4                                      #else
                                              l_us_error_code = pwrsGetData((unsigned char)DATA_PWRS_US_FIRMWARE_VER);
                                              #endif
4039   4              
4040   4                                      //If there is no error, then attempt to recover is successful, reset the error flag
4041   4                                      //And the error counter
4042   4                                      if(!l_us_error_code) {
4043   5                                              str_obdh_hk.us_imh_flag &= ~IMH_FLAG_ERROR;
4044   5                                              g_uc_imh_retry_counter = 0;
4045   5                                              g_uc_imh_acs_timeout_retry_counter = 0;
4046   5                                              g_uc_imh_ads_timeout_retry_counter = 0;
4047   5                                      }
4048   4                              }
4049   3              
4050   3                              //If there is no error at this point of time, we can start considering the current state of ADS
4051   3                              if (!(str_obdh_hk.us_imh_flag & IMH_FLAG_ERROR)){
4052   4                                      //ADS case
4053   4                                      //Check if timeout flag is not set
4054   4                                      if (!(str_obdh_hk.us_imh_flag & IMH_FLAG_ADS_TO)){
4055   5                                              //Check whether what we desire state has been achieved, if not, just skip this check
4056   5                                              if ((str_obdh_hk.us_imh_flag & IMH_FLAG_ADS_WT) && (((str_obdh_hk.us_imh_flag & IMH_FLAG_ADS_ON) && (
             -str_obdh_hk.us_imh_flag & IMH_FLAG_ADS_RS)) || (!(str_obdh_hk.us_imh_flag & IMH_FLAG_ADS_ON) && !(str_obdh_hk.us_imh_fla
             -g & IMH_FLAG_ADS_RS)))){
4057   6                                                      //Drop waiting & timeout flags
4058   6                                                      str_obdh_hk.us_imh_flag &= ~IMH_FLAG_ADS_WT;
4059   6                                                      str_obdh_hk.us_imh_flag &= ~IMH_FLAG_ADS_TO;
4060   6              
4061   6                                                      //Reset waiting time and timeout retry counter
4062   6                                                      g_uc_imh_wait_ads_time_s = 0;
4063   6                                                      g_uc_imh_ads_timeout_retry_counter = 0;
4064   6                                              }
4065   5      
4066   5                                              //If currently we are not waiting for something to happen (ADS has achieved its desired state)
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 69  

4067   5                                              if (!(str_obdh_hk.us_imh_flag & IMH_FLAG_ADS_WT)){
4068   6                                                      //If ADS is ON, turns it off
4069   6                                                      if (str_obdh_hk.us_imh_flag & IMH_FLAG_ADS_ON){
4070   7                                                              //Set ADS desired output to OFF (for repetition purpose, in case it failed)
4071   7                                                              str_obdh_hk.us_imh_flag &= ~IMH_FLAG_ADS_RS;
4072   7              
4073   7                                                              //Set waiting flag
4074   7                                                              str_obdh_hk.us_imh_flag |= IMH_FLAG_ADS_WT;
4075   7                                                              
4076   7                                                              //Attempt to set ADS to OFF in 50ms
4077   7                                                              #if (DEBUGGING_FEATURE == 1)
4078   7                                                              l_us_error_code = pwrsSetSingleOutput(ADS_CHANNEL,CHANNEL_OFF,TIME_LIMIT_SET_RESET_CHANNEL_MS,0);
4079   7                                                              #else
                                                                      l_us_error_code = pwrsSetSingleOutput(ADS_CHANNEL,CHANNEL_OFF,TIME_LIMIT_SET_RESET_CHANNEL_MS);
                                                                      #endif
4082   7              
4083   7                                                              //If this fail, increase the retry counter, and if it is successful, reset it.
4084   7                                                              if (l_us_error_code) g_uc_imh_retry_counter++;
4085   7                                                              else g_uc_imh_retry_counter = 0;                                                
4086   7                                                      }
4087   6                                                      //Else, it is desired
4088   6                                              }
4089   5                                      }
4090   4              
4091   4                                      //But if we are waiting ADS to be in the desired state and there is 
4092   4                                      //time out flag, clear the timeout flag and the timer, but increase the timeout retry counter
4093   4                                      else if ((str_obdh_hk.us_imh_flag & IMH_FLAG_ADS_WT) && (str_obdh_hk.us_imh_flag & IMH_FLAG_ADS_TO)){
4094   5                                              //Reset waiting time
4095   5                                              g_uc_imh_wait_ads_time_s = 0;
4096   5              
4097   5                                              //Reset timeout flag
4098   5                                              str_obdh_hk.us_imh_flag &= ~IMH_FLAG_ADS_TO;
4099   5              
4100   5                                              //Increase timeout retry counter
4101   5                                              g_uc_imh_ads_timeout_retry_counter++;
4102   5              
4103   5                                              //Get what is the reference state of ADS again
4104   5                                              if (str_obdh_hk.us_imh_flag & IMH_FLAG_ADS_RS)
4105   5                                                      l_uc_desired_state = CHANNEL_ON;
4106   5                                              else l_uc_desired_state = CHANNEL_OFF;
4107   5              
4108   5                                              //Attempt to set ADS to the desired state again in 50ms
4109   5                                              #if (DEBUGGING_FEATURE == 1)
4110   5                                              l_us_error_code = pwrsSetSingleOutput(ADS_CHANNEL,l_uc_desired_state,TIME_LIMIT_SET_RESET_CHANNEL_MS,
             -0);
4111   5                                              #else
                                                      l_us_error_code = pwrsSetSingleOutput(ADS_CHANNEL,l_uc_desired_state,TIME_LIMIT_SET_RESET_CHANNEL_MS)
             -;
                                                      #endif
4114   5              
4115   5                                              //If this fail, increase the retry counter, and if it is successful, reset it.
4116   5                                              if (l_us_error_code) g_uc_imh_retry_counter++;
4117   5                                              else g_uc_imh_retry_counter = 0;
4118   5                                      }
4119   4                                      //If for any reason an unexpected state occur, recover it
4120   4                                      else if (!(str_obdh_hk.us_imh_flag & IMH_FLAG_ADS_WT) && (str_obdh_hk.us_imh_flag & IMH_FLAG_ADS_TO)){
4121   5                                              //Reset waiting time
4122   5                                              g_uc_imh_wait_ads_time_s = 0;
4123   5              
4124   5                                              //Reset timeout flag
4125   5                                              str_obdh_hk.us_imh_flag &= ~IMH_FLAG_ADS_TO;
4126   5              
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 70  

4127   5                                              //Reset timeout retry counter
4128   5                                              g_uc_imh_acs_timeout_retry_counter = 0;
4129   5                                      }
4130   4                              }
4131   3              
4132   3                              //If at any point of time, reset counter goes beyond the limit
4133   3                              if (g_uc_imh_retry_counter > IMH_RETRY_FAIL_LIMIT || g_uc_imh_acs_timeout_retry_counter > IMH_ACS_TIMEO
             -UT_RETRY_FAIL_LIMIT || g_uc_imh_ads_timeout_retry_counter > IMH_ADS_TIMEOUT_RETRY_FAIL_LIMIT){
4134   4                                      //Reset retry counter
4135   4                                      g_uc_imh_retry_counter = 0;
4136   4                                      g_uc_imh_acs_timeout_retry_counter = 0;
4137   4                                      g_uc_imh_ads_timeout_retry_counter = 0;
4138   4              
4139   4                                      //Reset waiting time
4140   4                                      g_uc_imh_wait_acs_time_s = 0;
4141   4                                      g_uc_imh_wait_ads_time_s = 0;
4142   4              
4143   4                                      //Clear unrelevant (transitional) flags
4144   4                                      str_obdh_hk.us_imh_flag &= ~IMH_FLAG_ADS_WT;
4145   4                                      str_obdh_hk.us_imh_flag &= ~IMH_FLAG_ADS_TO;
4146   4              
4147   4                                      //Set error flag
4148   4                                      str_obdh_hk.us_imh_flag |= IMH_FLAG_ERROR;
4149   4                              }
4150   3                      }
4151   2              }
4152   1      }
4153          #endif
4154          #endif
4155          #endif
4156          
4157          #if (SATELLITE_MODE_HANDLER_ENABLE == 1)
4158          #if (SAFE_MODE_HANDLER_ENABLE == 1)
4159          #if (ADCS_CMD_ENABLE == 1)
4160          #if (PWRS_CMD_ENABLE == 1)
4161          //------------------------------------------------------------------------------------
4162          // To handle state during Safe-Mode (M4 or M8)
4163          //------------------------------------------------------------------------------------
4164          void safeModeHandler (void)
4165          {
4166   1              unsigned short l_us_error_code = EC_SUCCESSFUL;
4167   1      
4168   1              //Check case 1, compare SoC, only done once
4169   1              if (g_ul_smh_time_register >= str_obdh_par.us_rev_time_s && !(str_obdh_hk.uc_smh_flag & 0x01)){
4170   2                      //Record current SoC
4171   2                      g_uc_soc_after_one_orbit_in_safe_mode = str_obdh_data.uc_batt_soc;
4172   2      
4173   2                      //Record comparison as has been conducted
4174   2                      str_obdh_hk.uc_smh_flag |= 0x01;
4175   2      
4176   2                      //Trigger comparison reading (once)
4177   2                      str_obdh_hk.uc_smh_flag |= 0x02;
4178   2              }
4179   1      
4180   1              //If comparison has been conducted, get the comparison result once
4181   1              if (str_obdh_hk.uc_smh_flag & 0x02){
4182   2                      //Clear comparison reading flag
4183   2                      str_obdh_hk.uc_smh_flag &= ~0x02;
4184   2                      
4185   2                      //If the result shows negative result
4186   2                      if (g_uc_soc_after_one_orbit_in_safe_mode < g_uc_soc_reading_when_entering_safe_mode)
4187   2                              //Gives negative comparison result
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 71  

4188   2                              str_obdh_hk.uc_smh_flag |= 0x04;
4189   2                      else 
4190   2                              //Gives positive comparison result
4191   2                              str_obdh_hk.uc_smh_flag |= 0x08;
4192   2              }
4193   1      
4194   1              #if (SATELLITE_SCHEDULE_HANDLER_ENABLE == 1)
4195   1              //If the comparison result is negative
4196   1              if (str_obdh_hk.uc_smh_flag & 0x04){
4197   2                      #if (EVENT_HANDLER_ENABLE == 1)
4198   2                      #if (STORING_ENABLE == 1)
4199   2                      //Save SMH event 20120224
4200   2                      eventHandlerSafeholdMode();
4201   2                      #endif
4202   2                      #endif
4203   2      
4204   2                      //Schedule to turn ON ADCS in the next 10 sec
4205   2                      scheduleTurnOnADCS(str_obdh_data.ul_obc_time_s+10);
4206   2      
4207   2                      #if (BODY_RATE_HANDLER_ENABLE == 1)
4208   2                      #if (ADCS_CMD_ENABLE == 1)
4209   2                      #if (PWRS_CMD_ENABLE == 1)
4210   2                      //Re-enabling BRH
4211   2                      reenableBRH();
4212   2                      #endif
4213   2                      #endif
4214   2                      #endif
4215   2      
4216   2              #if (IDLE_MODE_HANDLER_ENABLE == 1)
4217   2              #if (PWRS_CMD_ENABLE == 1)
4218   2                      //Disable IMH
4219   2                      str_obdh_hk.us_imh_flag &= ~IMH_FLAG_ENABLE;
4220   2                      #endif
4221   2                      #endif
4222   2      
4223   2                      //Update negative comparison as being handled
4224   2                      str_obdh_hk.uc_smh_flag &= ~0x04;
4225   2      
4226   2                      //Waiting for timeout
4227   2                      str_obdh_hk.uc_smh_flag |= 0x10;
4228   2              }
4229   1              //If the comparison result is positive, however, do nothing, just continue waiting
4230   1              #endif
4231   1      
4232   1              //If the negative comparison is being handled, see if ADCS has been enabled for 20 mins
4233   1              if (str_obdh_hk.uc_smh_flag & 0x10){
4234   2                      #if (BODY_RATE_HANDLER_ENABLE == 1)
4235   2                      #if (ADCS_CMD_ENABLE == 1)
4236   2                      #if (PWRS_CMD_ENABLE == 1)
4237   2                      //Do body rate control for this time being
4238   2                      bodyRateHandler();
4239   2                      #endif
4240   2                      #endif
4241   2                      #endif
4242   2      
4243   2                      //If ADCS has been turned ON for 20 mins (+20 sec buffer), 
4244   2                      if (g_ul_smh_time_register >= (str_obdh_par.us_rev_time_s+1200+20)){
4245   3                              #if (EVENT_HANDLER_ENABLE == 1)
4246   3                              #if (STORING_ENABLE == 1)
4247   3                              //Save SMH event 20120224
4248   3                              eventHandlerSafeholdMode();
4249   3                              #endif
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 72  

4250   3                              #endif
4251   3      
4252   3                              #if (BODY_RATE_HANDLER_ENABLE == 1)
4253   3                              #if (ADCS_CMD_ENABLE == 1)
4254   3                              #if (PWRS_CMD_ENABLE == 1)
4255   3                              //Disable bodyRateHandler
4256   3                              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_ENABLE;
4257   3                              #endif
4258   3                              #endif
4259   3                              #endif
4260   3      
4261   3                      #if (IDLE_MODE_HANDLER_ENABLE == 1)
4262   3                      #if (PWRS_CMD_ENABLE == 1)
4263   3                              //Enable IMH again
4264   3                              str_obdh_hk.us_imh_flag |= IMH_FLAG_ENABLE;
4265   3                              #endif
4266   3                              #endif
4267   3      
4268   3                              //Update negative comparison as has been passing first fail case (time limit)
4269   3                              str_obdh_hk.uc_smh_flag &= ~0x10;
4270   3                              str_obdh_hk.uc_smh_flag |= 0x20;
4271   3                      }
4272   2              }
4273   1      
4274   1              //If at any point of time, SoC has dropped far too low, turn OFF COMM
4275   1              if (str_obdh_data.uc_batt_soc < str_obdh_par.uc_soc_threshold[4] && !(str_obdh_hk.uc_smh_flag & 0xC0) && 
             -g_ul_smh_time_register >= TIME_LIMIT_SAT_ON_AFTER_LAST_EFFORT_RESET){
4276   2                      //Attempt to set COMM to OFF in 50ms (no error code is returned, keep retrying)
4277   2                      #if (DEBUGGING_FEATURE == 1)
4278   2                      l_us_error_code = pwrsSetSingleOutput(COMM_CHANNEL,CHANNEL_OFF,TIME_LIMIT_SET_RESET_CHANNEL_MS,0);
4279   2                      #else
                              l_us_error_code = pwrsSetSingleOutput(COMM_CHANNEL,CHANNEL_OFF,TIME_LIMIT_SET_RESET_CHANNEL_MS);
                              #endif
4282   2      
4283   2                      //If there is no error code, proceeds
4284   2                      if (!l_us_error_code){
4285   3                              //Update safe mode flag as has been issuing command to turn OFF COMM
4286   3                              str_obdh_hk.uc_smh_flag |= 0x40;
4287   3              
4288   3                              //Safe current safe-mode time
4289   3                              g_ul_smh_saved_time = str_obdh_data.ul_obc_time_s;
4290   3                      }
4291   2                      #if (EVENT_HANDLER_ENABLE == 1)
4292   2                      #if (STORING_ENABLE == 1)
4293   2                      //Save SMH event 20120224
4294   2                      eventHandlerSafeholdMode();
4295   2                      #endif
4296   2                      #endif
4297   2      
4298   2              }
4299   1              
4300   1      
4301   1              //If command to turn OFF COMM has been issue, 
4302   1              if (str_obdh_hk.uc_smh_flag & 0x40){
4303   2                      //Check if 15 sec has passed 
4304   2                      if (str_obdh_data.ul_obc_time_s >= g_ul_smh_saved_time+15){
4305   3                              //If COMM has been turned OFF within this 15 s, update the status as COMM turned OFF
4306   3                              if (!g_us_latest_ch_stat_update_ec && !(str_pwrs_data.uc_channel_status & COMM_CHANNEL_BIT)){
4307   4                                      str_obdh_hk.uc_smh_flag &= ~0x40;
4308   4                                      str_obdh_hk.uc_smh_flag |= 0x80;
4309   4                              }
4310   3                              //Else, retry to turn OFF COMM again
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 73  

4311   3                              else str_obdh_hk.uc_smh_flag &= ~0x40;
4312   3                      }
4313   2              }
4314   1      
4315   1              #if (EXTRA_ENABLE == 1)
4316   1              //If at any point of time, SoC is dropped to less than 10% and satellite reset has not been initialized
4317   1              //And it has been at least 10 minutes in the safemode
4318   1              //Prepare to reset the satellite...
4319   1              if ((str_obdh_data.uc_batt_soc < str_obdh_par.uc_soc_threshold[6]) && (!(g_uc_evha_flag & EVENT_FLAG_RESE
             -T_SAT_INITIALIZED)) && g_ul_smh_time_register >= TIME_LIMIT_SAT_ON_AFTER_LAST_EFFORT_RESET){
4320   2                      //Need to do something here...
4321   2                      //Mark reset cause as RESET_SOURCE_SAFEHOLD 
4322   2                      str_obdh_data.uc_sat_rstsrc = RESET_SOURCE_SAFEHOLD;
4323   2      
4324   2                      //Trigger satellite's reset
4325   2                      callReset(OBDH_CMD_RESET_SAT);
4326   2              }
4327   1              #endif
4328   1      
4329   1      }
4330          #endif
4331          #endif
4332          #endif
4333          #endif
4334          
4335          #if (SATELLITE_MODE_HANDLER_ENABLE == 1)
4336          //------------------------------------------------------------------------------------
4337          // Normal procedure to enter M3 (unique procedure is excluded)
4338          //------------------------------------------------------------------------------------
4339          void enterM3 (void)
4340          {
4341   1              //Reset idle time register
4342   1              g_ul_idle_time_register = 0;
4343   1      
4344   1              #if (SATELLITE_SCHEDULE_HANDLER_ENABLE == 1)
4345   1              //Schedule to turn ON ADS 2 seconds later
4346   1              scheduleSingleChannel(ADS_CHANNEL,CHANNEL_ON,str_obdh_data.ul_obc_time_s+2);
4347   1              #endif
4348   1      
4349   1              #if (IDLE_MODE_HANDLER_ENABLE == 1)
4350   1              #if (PWRS_CMD_ENABLE == 1)
4351   1              //Disable idleModeHandler
4352   1              str_obdh_hk.us_imh_flag &= ~IMH_FLAG_ENABLE;
4353   1              #endif
4354   1              #endif
4355   1      
4356   1              #if (BODY_RATE_HANDLER_ENABLE == 1)
4357   1              #if (ADCS_CMD_ENABLE == 1)
4358   1              #if (PWRS_CMD_ENABLE == 1)
4359   1              //Re-enabling BRH
4360   1              reenableBRH();
4361   1              #endif
4362   1              #endif
4363   1              #endif
4364   1      
4365   1              //Terminate whatever mission we have
4366   1              g_us_mission_time_register = 0;
4367   1      
4368   1              #if (EVENT_HANDLER_ENABLE == 1)
4369   1              #if (STORING_ENABLE == 1)
4370   1          //yc added 20120224
4371   1              eventHandlerUpdateStateMode (SATELLITE_MODE_M3);
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 74  

4372   1              #endif
4373   1              #endif
4374   1              //Set ADCS desired state as ADCS_MODE_DETUMBLE
4375   1              g_uc_desired_adcs_mode = ADCS_MODE_DETUMBLE;
4376   1      
4377   1              //Change satellite mode into M3
4378   1              str_obdh_hk.uc_sat_mode = SATELLITE_MODE_M3;
4379   1      }
4380          
4381          //------------------------------------------------------------------------------------
4382          // Normal procedure to enter M4 (unique procedure is excluded)
4383          //------------------------------------------------------------------------------------
4384          void enterM4 (void)
4385          {
4386   1              #if (BODY_RATE_HANDLER_ENABLE == 1)
4387   1              #if (ADCS_CMD_ENABLE == 1)
4388   1              #if (PWRS_CMD_ENABLE == 1)
4389   1              //Disable bodyRateHandler
4390   1              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_ENABLE;
4391   1              #endif
4392   1              #endif
4393   1              #endif
4394   1      
4395   1              #if (IDLE_MODE_HANDLER_ENABLE == 1)
4396   1              #if (PWRS_CMD_ENABLE == 1)
4397   1              //Enable idleModeHandler
4398   1              str_obdh_hk.us_imh_flag |= IMH_FLAG_ENABLE;
4399   1              #endif
4400   1              #endif
4401   1      
4402   1              //Record SoC
4403   1              g_uc_soc_reading_when_entering_safe_mode = str_obdh_data.uc_batt_soc;
4404   1      
4405   1              #if (SAFE_MODE_HANDLER_ENABLE == 1)
4406   1              #if (ADCS_CMD_ENABLE == 1)
4407   1              #if (PWRS_CMD_ENABLE == 1)
4408   1              //Reset safe mode flag
4409   1              str_obdh_hk.uc_smh_flag = 0;
4410   1              #endif
4411   1              #endif
4412   1              #endif
4413   1      
4414   1              //Terminate whatever mission we have
4415   1              g_us_mission_time_register = 0;
4416   1      
4417   1              #if (EVENT_HANDLER_ENABLE == 1)
4418   1              #if (STORING_ENABLE == 1)
4419   1          //yc added 20120224
4420   1              eventHandlerUpdateStateMode (SATELLITE_MODE_M4);
4421   1              #endif
4422   1              #endif
4423   1      
4424   1              //Set ADCS desired state as ADCS_MODE_RATE_CTRL
4425   1              g_uc_desired_adcs_mode = ADCS_MODE_RATE_CTRL;
4426   1      
4427   1              //Change satellite mode into M4
4428   1              str_obdh_hk.uc_sat_mode = SATELLITE_MODE_M4;
4429   1      }
4430          
4431          //------------------------------------------------------------------------------------
4432          // Normal procedure to enter M5 (unique procedure is excluded)
4433          //------------------------------------------------------------------------------------
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 75  

4434          void enterM5 (void)
4435          {
4436   1              //Reset idle time register
4437   1              g_ul_idle_time_register = 0;
4438   1      
4439   1              #if (BODY_RATE_HANDLER_ENABLE == 1)
4440   1              #if (ADCS_CMD_ENABLE == 1)
4441   1              #if (PWRS_CMD_ENABLE == 1)
4442   1              //Disable bodyRateHandler again
4443   1              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_ENABLE;
4444   1              #endif
4445   1              #endif
4446   1              #endif
4447   1      
4448   1              #if (IDLE_MODE_HANDLER_ENABLE == 1)
4449   1              #if (PWRS_CMD_ENABLE == 1)
4450   1              //Enable idleModeHandler
4451   1              str_obdh_hk.us_imh_flag |= IMH_FLAG_ENABLE;
4452   1              #endif
4453   1              #endif
4454   1      
4455   1              //Terminate whatever mission we have
4456   1              g_us_mission_time_register = 0;
4457   1      
4458   1              #if (EVENT_HANDLER_ENABLE == 1)
4459   1              #if (STORING_ENABLE == 1)
4460   1          //yc added 20120224
4461   1              eventHandlerUpdateStateMode (SATELLITE_MODE_M5);
4462   1              #endif
4463   1              #endif
4464   1      
4465   1              //Set ADCS desired state as ADCS_MODE_DETUMBLE
4466   1              g_uc_desired_adcs_mode = ADCS_MODE_DETUMBLE;
4467   1      
4468   1              //Change satellite mode into M5
4469   1              str_obdh_hk.uc_sat_mode = SATELLITE_MODE_M5;
4470   1      }
4471          
4472          //------------------------------------------------------------------------------------
4473          // Normal procedure to enter M8 (unique procedure is excluded)
4474          //------------------------------------------------------------------------------------
4475          void enterM8 (void)
4476          {
4477   1              #if (BODY_RATE_HANDLER_ENABLE == 1)
4478   1              #if (ADCS_CMD_ENABLE == 1)
4479   1              #if (PWRS_CMD_ENABLE == 1)
4480   1              //Disable bodyRateHandler
4481   1              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_ENABLE;
4482   1              #endif
4483   1              #endif
4484   1              #endif
4485   1      
4486   1              #if (IDLE_MODE_HANDLER_ENABLE == 1)
4487   1              #if (PWRS_CMD_ENABLE == 1)
4488   1              //Enable idleModeHandler
4489   1              str_obdh_hk.us_imh_flag |= IMH_FLAG_ENABLE;
4490   1              #endif
4491   1              #endif
4492   1      
4493   1              //Record SoC
4494   1              g_uc_soc_reading_when_entering_safe_mode = str_obdh_data.uc_batt_soc;
4495   1      
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 76  

4496   1              #if (SAFE_MODE_HANDLER_ENABLE == 1)
4497   1              #if (ADCS_CMD_ENABLE == 1)
4498   1              #if (PWRS_CMD_ENABLE == 1)
4499   1              //Reset safe mode flag
4500   1              str_obdh_hk.uc_smh_flag = 0;
4501   1              #endif
4502   1              #endif
4503   1              #endif
4504   1      
4505   1              //Terminate whatever mission we have
4506   1              g_us_mission_time_register = 0;
4507   1      
4508   1              #if (EVENT_HANDLER_ENABLE == 1)
4509   1              #if (STORING_ENABLE == 1)
4510   1          //yc added 20120224
4511   1          eventHandlerUpdateStateMode (SATELLITE_MODE_M8);
4512   1              #endif
4513   1              #endif
4514   1      
4515   1              //Set ADCS desired state as ADCS_MODE_RATE_CTRL
4516   1              g_uc_desired_adcs_mode = ADCS_MODE_RATE_CTRL;
4517   1      
4518   1              //Change satellite mode into M8
4519   1              str_obdh_hk.uc_sat_mode = SATELLITE_MODE_M8;
4520   1      }
4521          #endif
4522          
4523          #if (GROUND_STATION_COMMAND_HANDLER_ENABLE == 1)
4524          //------------------------------------------------------------------------------------
4525          // Normal procedure to enter M6 (unique procedure is excluded)
4526          //------------------------------------------------------------------------------------
4527          void enterGroundPass (void)
4528          {
4529   1              //Reset transitional state monitoring period
4530   1              g_us_gsch_monitoring_transitional_period = 0;
4531   1      
4532   1              //Start groundpass state
4533   1              g_uc_gsch_flag |= GSCH_FLAG_GROUNDPASS_STARTED;
4534   1      
4535   1              //If the satellite mode is currently on M5, M7, or M8 change it to M6, record the previous mode
4536   1              if (str_obdh_hk.uc_sat_mode == SATELLITE_MODE_M5 || str_obdh_hk.uc_sat_mode == SATELLITE_MODE_M7 || str_o
             -bdh_hk.uc_sat_mode == SATELLITE_MODE_M8){
4537   2                      str_obdh_data.uc_previous_mode = str_obdh_hk.uc_sat_mode;
4538   2      
4539   2                      #if (EVENT_HANDLER_ENABLE == 1)
4540   2                      #if (STORING_ENABLE == 1)
4541   2                  //yc added 20120224
4542   2                      eventHandlerUpdateStateMode (SATELLITE_MODE_M6);
4543   2                      #endif
4544   2                      #endif
4545   2                       
4546   2                      str_obdh_hk.uc_sat_mode = SATELLITE_MODE_M6;
4547   2              }
4548   1      
4549   1              //Set GSCH state to groundpass
4550   1              str_obdh_hk.uc_gsch_state = GSCH_STATE_GROUND_PASS;
4551   1              
4552   1      }
4553          #endif
4554          
4555          #if (GROUND_STATION_COMMAND_HANDLER_ENABLE == 1)
4556          //------------------------------------------------------------------------------------
C51 COMPILER V9.02   LUXP_MAIN                                                             01/09/2014 12:21:19 PAGE 77  

4557          // Reset GSCH counters
4558          //------------------------------------------------------------------------------------
4559          void resetGSCHCounters (void)
4560          {
4561   1              //Reset some GSCH common counters
4562   1              g_uc_gsch_comm_retry_counter = 0;
4563   1              g_uc_gsch_loading_retry_counter = 0;
4564   1              g_us_gsch_monitoring_period = 0;
4565   1      }
4566          #endif
4567          
4568          #if (SATELLITE_MODE_HANDLER_ENABLE == 1)
4569          #if (BODY_RATE_HANDLER_ENABLE == 1)
4570          #if (ADCS_CMD_ENABLE == 1)
4571          #if (PWRS_CMD_ENABLE == 1)
4572          //------------------------------------------------------------------------------------
4573          // To re-enable BRH
4574          //------------------------------------------------------------------------------------
4575          void reenableBRH (void)
4576          {
4577   1              //Enable bodyRateHandler flag
4578   1              str_obdh_hk.us_brh_flag |= BRH_FLAG_ENABLE;
4579   1      
4580   1              //Reset BRH end flags
4581   1              resetBRHEndFlags();
4582   1      
4583   1              //Reset Body Rate values
4584   1              resetBodyRateValue();
4585   1      }
4586          
4587          //------------------------------------------------------------------------------------
4588          // Reset BRH end flags
4589          //------------------------------------------------------------------------------------
4590          void resetBRHEndFlags (void)
4591          {
4592   1              //Reset its stabilizing, timeout, and complete flag
4593   1              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_STABILIZING;
4594   1              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_BR_ST_TO;
4595   1              str_obdh_hk.us_brh_flag &= ~BRH_FLAG_ST_COMPLETED;
4596   1      }
4597          #endif
4598          #endif
4599          #endif
4600          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   9588    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   6781      77
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
