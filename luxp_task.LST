C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE LUXP_TASK
NO OBJECT MODULE REQUESTED
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE luxp_task.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

*** WARNING C500 IN LINE 1 OF LUXP_TASK.C: LICENSE ERROR (R20D: CONTENT ERROR IN FLF FILE)

   1          //------------------------------------------------------------------------------------
   2          // Luxp_task.c
   3          //------------------------------------------------------------------------------------
   4          // Copyright (C) 2013 Nanyang Technological University.
   5          //
   6          // AUTH: IAN
   7          // DATE: 03 APR 2013
   8          //
   9          // The program Luxp_task.c will be downloaded to the Pumpkin Motherboard with 
  10          // C8051F120 uC as part of the VELOX-P Pico-Satellite Flight Software. 
  11          //
  12          // This file contains all task functions of the Flight Software
  13          //
  14          //------------------------------------------------------------------------------------
  15          // Overall functional test status
  16          //------------------------------------------------------------------------------------
  17          // Completely untested
  18          //
  19          //------------------------------------------------------------------------------------
  20          // Overall documentation status
  21          //------------------------------------------------------------------------------------
  22          // Minimally documented
  23          //------------------------------------------------------------------------------------
  24          
  25          #include <luxp_task.h>
  26          
  27          #if (TASK_ENABLE == 1)
  28          //------------------------------------------------------------------------------------
  29          // Task Module (TM)
  30          //------------------------------------------------------------------------------------
  31          // Task Module (TM) have the following important properties:
  32          //      -> It will always produce response length
  33          //      -> The response length is always started as '1'
  34          //      -> If there is read flag raised, it will fill the output buffer and increas the
  35          //         response length accordingly
  36          //------------------------------------------------------------------------------------
  37          // Each task in TM works in the following sequence:
  38          //      -> Trace its current task
  39          //      -> Trace its reading format
  40          //      -> Check whether the conditions for the current task to be run are satistifed
  41          //              The conditions are:
  42          //              1) The current task's initialization and running task flags are set
  43          //              2) The current task's completed & error task flags are not set
  44          //      -> If the conditions to run are satisfied, runs the task, if not, skips it
  45          //      -> Check the conditions for task's reading
  46          //              The conditions are:
  47          //              1) The current task's status read flags is set, OR
  48          //              2) The current task's summary read flags is set
  49          //      -> If any of the task's read flag is set
  50          //              1) Put the task's reading in the buffer
  51          //              2) Increase the output buffer pointer accordingly
  52          //------------------------------------------------------------------------------------
  53          // Each subtask in TM works in the following sequence:
  54          //      -> Trace its current subtask
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 2   

  55          //      -> Check whether compulsory conditions for the subtask to run are satistifed
  56          //              The compulsory conditions are:
  57          //              1) The current subtask's running flag is raised
  58          //              2) The current subtask's completed & error flags are not raised
  59          //      -> Check whether exceptional conditions for the subtask to run are satisfied
  60          //              Some possible exceptional conditions are as follow:
  61          //              1) Other subtask's flag
  62          //              2) Satellite's status
  63          //              3) Subtask's timer
  64          //              4) Etc
  65          //      -> If the conditions to run are satisfied, runs the subtask, if not, skips it
  66          //      -> Check the task's detail read flag
  67          //      -> If the task's detail read flag is set
  68          //              1) Put the subtask's reading in the buffer
  69          //              2) Increase the output buffer pointer accordingly
  70          //------------------------------------------------------------------------------------
  71          void taskModule (unsigned char l_uc_current_task, unsigned char *l_uc_response_task_buffer_p)
  72          {
  73   1              unsigned char   l_uc_i;
  74   1              unsigned char   l_uc_current_reading_format = 0xF0;
  75   1      
  76   1              //Trace current task's reading format
  77   1              l_uc_current_reading_format = getReadingFormat(l_uc_current_task);
  78   1      
  79   1              //If there is any reading
  80   1              //The underline assumption for this task reading is that it may only occur if there is 
  81   1              //a command captured by commandControlModule to read task. Thus, g_us_res_length will
  82   1              //always be initialized as 1 by commandControlModule before this condition is true.
  83   1              //See g_us_res_length in commandControlModule.
  84   1              if (l_uc_current_reading_format != READ_TASK_NO_READING){
  85   2                      *(l_uc_response_task_buffer_p + g_us_res_length++) = l_uc_current_task;
  86   2                      *(l_uc_response_task_buffer_p + g_us_res_length++) = l_uc_current_reading_format;
  87   2              }
  88   1                      
  89   1              //Check current task's running condition, runs the tasks if the conditions are met, else skips it
  90   1              //The conditions are:
  91   1              //1) The current task's initialization and running task flags are set
  92   1              //2) The current task's completed task flag is not set
  93   1              if ((str_task[l_uc_current_task].uc_status & TASK_STAT_RUNNING_FLTR) == TASK_STAT_RUNNING){
  94   2              
  95   2                      //----------------------------------------------------------------      
  96   2                      // Current task's running block starts
  97   2                      //----------------------------------------------------------------      
  98   2      
  99   2                      //Running only one subtask at a time, if that subtask is meant to be run
 100   2                              //Check compulsory conditions to run
 101   2                              //The compulsory conditions are:
 102   2                              // 1) The current subtask's running flag is raised
 103   2                              // 2) The current subtask's completed & error flags are not raised
 104   2                                      //Check whether exceptional conditions for the subtask to run are satisfied
 105   2                                      //Some possible exceptional conditions are as follow:
 106   2                                      // 1) Other subtask's flag
 107   2                                      // 2) Satellite's status
 108   2                                      // 3) Subtask's timer
 109   2                                      // 4) Etc
 110   2                      for (l_uc_i = 0; l_uc_i < 8; l_uc_i++)
 111   2                              if ((str_task[l_uc_current_task].uc_script_running_flags & (unsigned short)(1 << l_uc_i)) && !(str_task
             -[l_uc_current_task].uc_script_completed_flags & (unsigned short)(1 << l_uc_i)) && !(str_task[l_uc_current_task].uc_scrip
             -t_error_flags & (unsigned short)(1 << l_uc_i)))
 112   2                                      g_us_res_length = readScriptline(l_uc_current_task,(unsigned short)(1 << l_uc_i),g_us_res_length);      
 113   2              
 114   2                      //----------------------------------------------------------------
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 3   

 115   2                      // Current task's running block ends
 116   2                      //----------------------------------------------------------------
 117   2              }
 118   1      
 119   1              //Check current task's reading condition, put the reading into the buffer if the conditions are met
 120   1              //Else, skips it
 121   1              //The conditions are:
 122   1              // 1) The current task's status read flags is set, OR
 123   1              // 2) The current task's summary read flags is set
 124   1              //If any of the task's read flag is set
 125   1              // 1) Put the task's reading in the buffer
 126   1              // 2) Increase the output buffer pointer accordingly
 127   1      
 128   1              //----------------------------------------------------------------      
 129   1              // Current task's reading block starts
 130   1              //----------------------------------------------------------------      
 131   1              if (l_uc_current_reading_format != READ_TASK_NO_READING)
 132   1                      g_us_res_length = fillData(l_uc_response_task_buffer_p,g_us_res_length,DATA_CAT_SINGLE_TASK_UC_STATUS,(u
             -nsigned short)l_uc_current_task);
 133   1      
 134   1              if ((l_uc_current_reading_format == READ_TASK_FORMAT_2))
 135   1                      g_us_res_length = fillData(l_uc_response_task_buffer_p,g_us_res_length,DATA_CAT_SINGLE_TASK_STRUCTURE,(u
             -nsigned short)l_uc_current_task);
 136   1              //----------------------------------------------------------------      
 137   1              // Current task's reading block ends
 138   1              //----------------------------------------------------------------      
 139   1      }
 140          
 141          //------------------------------------------------------------------------------------
 142          // Set task flags functions
 143          //------------------------------------------------------------------------------------
 144          // Function's test result: untested
 145          //------------------------------------------------------------------------------------
 146          void setTaskFlags (unsigned char l_uc_task_chosen, unsigned char l_uc_task_cmd, unsigned char l_uc_task_ar
             -g)
 147          {
 148   1              unsigned char l_uc_i;
 149   1              unsigned char l_uc_latest_scriptline;
 150   1              unsigned char l_uc_retry_counter_no;
 151   1              unsigned short l_us_error_code=EC_SUCCESSFUL;//dec22_yc
 152   1              //---------------------------------------------
 153   1              // Handle task's command block starts here
 154   1              //---------------------------------------------
 155   1              #if (EVENT_HANDLER_ENABLE == 1)
 156   1              #if (STORING_ENABLE == 1)
 157   1              if (l_uc_task_chosen >= TASK_SIZE){//dec_yc invalid l_uc_task_chosen
 158   2              l_us_error_code=EV_SET_TASK_FLAG+EC_INVALID_TASK_NO;            
 159   2                      eventHandler(l_us_error_code,l_uc_task_chosen,l_uc_task_cmd,
 160   2                              0,0,0,0);
 161   2                      return;
 162   2              }
 163   1              #endif
 164   1              #endif
 165   1              //---------------------------------------------
 166   1              //      a) TASK_CMD_TERMINATE
 167   1              //---------------------------------------------
 168   1              //      To change a task to termination (uninitialized state), the following change will
 169   1              //      take place when this command is received:
 170   1              //      -> Release all timer(s) used by the task
 171   1              //      -> Release all retry counter(s) used by the task
 172   1              //      -> Task's status, subtask flags (running, error, & completed), and timer flags 
 173   1              //         (owning and running) will be reset
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 4   

 174   1              //---------------------------------------------
 175   1              if (l_uc_task_cmd == TASK_CMD_TERMINATE)
 176   1              {
 177   2                      scriptspaceReleaseAllTimer(l_uc_task_chosen);
 178   2                      scriptspaceReleaseAllRetryCounter(l_uc_task_chosen);
 179   2                      resetTask(l_uc_task_chosen);
 180   2              }
 181   1      
 182   1              //---------------------------------------------
 183   1              //      b) TASK_CMD_RUN
 184   1              //---------------------------------------------
 185   1              //      To run a terminated/stopped task. The following sequence will take place:
 186   1              //      -> If the task is initially completed or errorneous
 187   1              //              1) Checks the latest subtask that was being run
 188   1              //              2) Runs it again
 189   1              //      -> Reset no of retry used by the latest subtask 
 190   1              //      -> Set task initialization flag
 191   1              //      -> Reset the task completed and errorneous flags
 192   1              //      -> Set task running flag
 193   1              //      -> Starts all timer(s) used by the task
 194   1              //---------------------------------------------
 195   1              else if (l_uc_task_cmd == TASK_CMD_RUN)
 196   1              {
 197   2                      l_uc_latest_scriptline = str_task[l_uc_task_chosen].uc_script_completed_flags || str_task[l_uc_task_chos
             -en].uc_script_error_flags || str_task[l_uc_task_chosen].uc_script_running_flags; 
 198   2      
 199   2                      if ((str_task[l_uc_task_chosen].uc_status & TASK_COMPLETED_FLAG) || (str_task[l_uc_task_chosen].uc_statu
             -s & TASK_ERROR_FLAG)){
 200   3                              for (l_uc_i = 0; l_uc_i < MAX_SCRIPTLINE_SIZE; l_uc_i++) if (!(l_uc_latest_scriptline & (1 << l_uc_i)))
             - {l_uc_i--; break;}
 201   3                              str_task[l_uc_task_chosen].uc_script_completed_flags    &= ~(1 << l_uc_i);              
 202   3                              str_task[l_uc_task_chosen].uc_script_error_flags                &= ~(1 << l_uc_i);              
 203   3                              str_task[l_uc_task_chosen].uc_script_running_flags              |= (1 << l_uc_i);
 204   3                      }
 205   2      
 206   2                      l_uc_retry_counter_no = scriptlineClaimRetryCounter(l_uc_task_chosen,(1 << l_uc_i));
 207   2                      #if (EVENT_HANDLER_ENABLE == 1)
 208   2                      #if (STORING_ENABLE == 1)
 209   2                      if(! g_us_scriptline_retry_counter_error_code) {
 210   3                              str_scriptline_retry_counter[l_uc_retry_counter_no].uc_counter = 0x00;//dec22_yc                        
 211   3                              }
 212   2                      else{
 213   3                              l_us_error_code=EV_SET_TASK_FLAG+l_us_error_code;
 214   3                              eventHandler(l_us_error_code,l_uc_task_chosen,l_uc_task_cmd,
 215   3                              str_task[l_uc_task_chosen].uc_status,str_task[l_uc_task_chosen].uc_script_error_flags,
 216   3                              str_task[l_uc_task_chosen].uc_script_running_flags,str_task[l_uc_task_chosen].uc_script_completed_flags
             -);
 217   3                              return;
 218   3                      }
 219   2                      #endif
 220   2                      #endif
 221   2      
 222   2                      str_task[l_uc_task_chosen].uc_status    |= TASK_INITIALIZED_FLAG;
 223   2                      str_task[l_uc_task_chosen].uc_status    &= ~TASK_COMPLETED_FLAG;                
 224   2                      str_task[l_uc_task_chosen].uc_status    &= ~TASK_ERROR_FLAG;                            
 225   2                      str_task[l_uc_task_chosen].uc_status    |= TASK_RUNNING_FLAG;
 226   2                      scriptspaceStartAllTimer(l_uc_task_chosen);
 227   2              }
 228   1      
 229   1              //---------------------------------------------
 230   1              //      c) TASK_CMD_STOP
 231   1              //---------------------------------------------
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 5   

 232   1              //      To stopped a task. The following sequence will take place:
 233   1              //      -> Stops all timer(s) used by the task
 234   1              //      -> Reset task running flag
 235   1              //---------------------------------------------
 236   1              else if (l_uc_task_cmd == TASK_CMD_STOP)
 237   1              {
 238   2                      scriptspaceStopAllTimer(l_uc_task_chosen);
 239   2                      str_task[l_uc_task_chosen].uc_status    &= ~TASK_RUNNING_FLAG;
 240   2              }
 241   1      
 242   1              //---------------------------------------------
 243   1              //      d) TASK_CMD_RESTART
 244   1              //---------------------------------------------
 245   1              //      To reset a task and re-runs it. The following sequence will take place:
 246   1              //      -> Release all timer(s) used by the task
 247   1              //      -> Release all retry counter(s) used by the task
 248   1              //      -> Task's status, subtask flags (running, error, & completed), and timer flags 
 249   1              //         (owning and running) will be reset
 250   1              //      -> Set task initialization flag
 251   1              //      -> Set task running flag
 252   1              //---------------------------------------------
 253   1              else if (l_uc_task_cmd == TASK_CMD_RESTART)
 254   1              {
 255   2                      scriptspaceReleaseAllTimer(l_uc_task_chosen);
 256   2                      scriptspaceReleaseAllRetryCounter(l_uc_task_chosen);
 257   2                      resetTask(l_uc_task_chosen);
 258   2                      str_task[l_uc_task_chosen].uc_status    |= TASK_INITIALIZED_FLAG;
 259   2                      str_task[l_uc_task_chosen].uc_status    |= TASK_RUNNING_FLAG;
 260   2              }
 261   1      
 262   1              //---------------------------------------------
 263   1              //      e) TASK_CMD_DO_NOTHING
 264   1              //---------------------------------------------
 265   1              //      As the name suggests
 266   1              //---------------------------------------------
 267   1              else if (l_uc_task_cmd == TASK_CMD_DO_NOTHING);
 268   1      
 269   1              //---------------------------------------------
 270   1              // Handle task's command block ends here
 271   1              //---------------------------------------------
 272   1      
 273   1              //---------------------------------------------
 274   1              // Handle task's argument block ends here
 275   1              //---------------------------------------------
 276   1      
 277   1              //---------------------------------------------
 278   1              //      a) READ_TASK_FORMAT_1
 279   1              //---------------------------------------------
 280   1              //      To read status for a task. The following sequence will take place:
 281   1              //      -> The task's status read flag will be set
 282   1              //---------------------------------------------
 283   1              if (l_uc_task_arg == READ_TASK_FORMAT_1)
 284   1                      str_task[l_uc_task_chosen].uc_status    |= TASK_STATUS_READ_FLAG;
 285   1      
 286   1              //---------------------------------------------
 287   1              //      b) READ_TASK_FORMAT_2
 288   1              //---------------------------------------------
 289   1              //      To read summary status for a task. The following sequence will take place:
 290   1              //      -> The task's status read flag will be set
 291   1              //      -> The task's summary read flag will be set
 292   1              //---------------------------------------------
 293   1              else if (l_uc_task_arg == READ_TASK_FORMAT_2)
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 6   

 294   1                      str_task[l_uc_task_chosen].uc_status    |= TASK_SUMMARY_READ_FLAG;
 295   1      
 296   1              #if (EVENT_HANDLER_ENABLE == 1)
 297   1              #if (STORING_ENABLE == 1)
 298   1              eventHandler(EV_SET_TASK_FLAG,l_uc_task_chosen,l_uc_task_cmd,
 299   1                              str_task[l_uc_task_chosen].uc_status,str_task[l_uc_task_chosen].uc_script_error_flags,
 300   1                              str_task[l_uc_task_chosen].uc_script_running_flags,str_task[l_uc_task_chosen].uc_script_completed_flags
             -);
 301   1              #endif
 302   1              #endif
 303   1      }
 304          
 305          //------------------------------------------------------------------------------------
 306          // Get reading format function
 307          //------------------------------------------------------------------------------------
 308          // Function's test result: untested
 309          //------------------------------------------------------------------------------------
 310          unsigned char getReadingFormat(unsigned char l_uc_task_chosen)
 311          {
 312   1              unsigned char l_uc_reading_format = READ_TASK_NO_READING;
 313   1      
 314   1              if (str_task[l_uc_task_chosen].uc_status & TASK_SUMMARY_READ_FLAG)      l_uc_reading_format = READ_TASK_FORMAT
             -_2;
 315   1              else if (str_task[l_uc_task_chosen].uc_status & TASK_STATUS_READ_FLAG)  l_uc_reading_format = READ_TASK_FO
             -RMAT_1;
 316   1      
 317   1              //Clear all reading flags
 318   1              str_task[l_uc_task_chosen].uc_status &= 0x8F;
 319   1      
 320   1              return l_uc_reading_format;
 321   1      }
 322          
 323          //------------------------------------------------------------------------------------
 324          // To enter values of a scriptline
 325          //------------------------------------------------------------------------------------
 326          // Function's test result: untested
 327          //------------------------------------------------------------------------------------
 328          void enterScriptline (unsigned char l_uc_scriptspace, unsigned char l_uc_scriptline, unsigned char l_uc_fu
             -nction_code, unsigned char l_uc_property, unsigned char l_uc_end_doing, unsigned char l_uc_argument)
 329          {
 330   1              str_scriptspace[l_uc_scriptspace].uc_script[l_uc_scriptline][0] = l_uc_function_code;
 331   1              str_scriptspace[l_uc_scriptspace].uc_script[l_uc_scriptline][1] = l_uc_property;
 332   1              str_scriptspace[l_uc_scriptspace].uc_script[l_uc_scriptline][2] = l_uc_end_doing;
 333   1              str_scriptspace[l_uc_scriptspace].uc_script[l_uc_scriptline][3] = l_uc_argument;        
 334   1      }
 335          
 336          //------------------------------------------------------------------------------------
 337          // Scriptline end handler: to handle end of a scriptline
 338          //  Bit7: timed/non-timed flag
 339          //  Bit6: last/non-last flag
 340          //  Bit5: progress/regress flag
 341          //      Bit4: progress/regress 3
 342          //      Bit3: progress/regress 2
 343          //      Bit2: progress/regress 1
 344          //      Bit1-0: end result
 345          //              01: non-critical error
 346          //              10: critical error
 347          //              11: successful
 348          //------------------------------------------------------------------------------------
 349          void scriptlineEndHandler (unsigned char l_uc_task, unsigned char l_uc_scriptline_bit, unsigned char l_uc_
             -end_type, unsigned char l_uc_retry_counter_no)
 350          {
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 7   

 351   1              unsigned char l_uc_timer_no;
 352   1      
 353   1              if ((l_uc_end_type & 0x03) == SCRIPTLINE_END_NON_CRITICAL_ERROR){
 354   2                      str_task[l_uc_task].uc_script_error_flags               |= l_uc_scriptline_bit;  //Marks the current scriptline as e
             -rrorneous
 355   2                      str_task[l_uc_task].uc_script_running_flags     &= ~l_uc_scriptline_bit; //Stops the current scriptline
 356   2                      str_task[l_uc_task].uc_status                                   |= TASK_WARNING_FLAG;    //Marks the current task as having warning
 357   2                      scriptlineReleaseRetryCounter(l_uc_task,l_uc_retry_counter_no);
 358   2              }
 359   1      
 360   1              else if ((l_uc_end_type & 0x03) == SCRIPTLINE_END_CRITICAL_ERROR){
 361   2                      str_task[l_uc_task].uc_script_error_flags               |= l_uc_scriptline_bit;  //Marks the current scriptline as e
             -rrorneous
 362   2                      str_task[l_uc_task].uc_script_running_flags     &= ~l_uc_scriptline_bit; //Stops the current scriptline
 363   2                      str_task[l_uc_task].uc_status                                   |= TASK_ERROR_FLAG;       //Marks the current task as errorneous
 364   2                      str_task[l_uc_task].uc_status                                   &= ~TASK_RUNNING_FLAG;    //Stops the current task
 365   2                      scriptlineReleaseRetryCounter(l_uc_task,l_uc_retry_counter_no);
 366   2              }
 367   1              
 368   1              else if ((l_uc_end_type & 0x03) == SCRIPTLINE_END_SUCCESSFUL){
 369   2                      str_task[l_uc_task].uc_script_completed_flags   |= l_uc_scriptline_bit;
 370   2                      str_task[l_uc_task].uc_script_running_flags     &= ~l_uc_scriptline_bit;
 371   2                      scriptlineReleaseRetryCounter(l_uc_task,l_uc_retry_counter_no);
 372   2              }       
 373   1      
 374   1              //Release the current timer used (if any)
 375   1              if (l_uc_end_type & SCRIPTLINE_END_TIMED_FLAG){ 
 376   2                      l_uc_timer_no = scriptlineClaimTimer(l_uc_task,l_uc_scriptline_bit);
 377   2                      scriptlineReleaseTimer(l_uc_task,l_uc_timer_no);
 378   2              }
 379   1      
 380   1              //If this is a last scriptline
 381   1              if (l_uc_end_type & SCRIPTLINE_END_LAST_FLAG){ 
 382   2                      str_task[l_uc_task].uc_status |= TASK_COMPLETED_FLAG;
 383   2                      str_task[l_uc_task].uc_status &= ~TASK_RUNNING_FLAG;                                                    
 384   2              }
 385   1      
 386   1              //If the end of the task brings certain progress
 387   1              //It is possible for the three flags to have been all raised
 388   1              if (l_uc_end_type & SCRIPTLINE_END_PROGRESS_FLAG){
 389   2                      if (l_uc_end_type & SCRIPTLINE_END_ONE_SHIFT_FLAG){
 390   3                              str_task[l_uc_task].uc_script_running_flags     |= (l_uc_scriptline_bit << 1);
 391   3                              str_task[l_uc_task].uc_script_completed_flags   &= ~(l_uc_scriptline_bit << 1);
 392   3                      }
 393   2                      if (l_uc_end_type & SCRIPTLINE_END_TWO_SHIFT_FLAG){
 394   3                              str_task[l_uc_task].uc_script_running_flags     |= (l_uc_scriptline_bit << 2);          
 395   3                              str_task[l_uc_task].uc_script_completed_flags   &= ~(l_uc_scriptline_bit << 2);
 396   3                      }
 397   2                      if (l_uc_end_type & SCRIPTLINE_END_THREE_SHIFT_FLAG){
 398   3                              str_task[l_uc_task].uc_script_running_flags     |= (l_uc_scriptline_bit << 3);  
 399   3                              str_task[l_uc_task].uc_script_completed_flags   &= ~(l_uc_scriptline_bit << 3);
 400   3                      }
 401   2              }
 402   1              else { //Treats it as brings certain regress
 403   2                      if (l_uc_end_type & SCRIPTLINE_END_ONE_SHIFT_FLAG){
 404   3                              str_task[l_uc_task].uc_script_running_flags     |= (l_uc_scriptline_bit >> 1);
 405   3                              str_task[l_uc_task].uc_script_completed_flags   &= ~(l_uc_scriptline_bit >> 1);
 406   3                      }
 407   2                      if (l_uc_end_type & SCRIPTLINE_END_TWO_SHIFT_FLAG){
 408   3                              str_task[l_uc_task].uc_script_running_flags     |= (l_uc_scriptline_bit >> 2);
 409   3                              str_task[l_uc_task].uc_script_completed_flags   &= ~(l_uc_scriptline_bit >> 2);
 410   3                      }
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 8   

 411   2                      if (l_uc_end_type & SCRIPTLINE_END_THREE_SHIFT_FLAG){
 412   3                              str_task[l_uc_task].uc_script_running_flags     |= (l_uc_scriptline_bit >> 3);
 413   3                              str_task[l_uc_task].uc_script_completed_flags   &= ~(l_uc_scriptline_bit >> 3);
 414   3                      }
 415   2              }
 416   1              #if (EVENT_HANDLER_ENABLE == 1)
 417   1              #if (STORING_ENABLE == 1)
 418   1              //dec28_yc
 419   1              eventHandler(EV_SCRIPTLINE_END_FLAG,l_uc_task,l_uc_end_type,
 420   1                              str_task[l_uc_task].uc_status,str_task[l_uc_task].uc_script_error_flags,
 421   1                              str_task[l_uc_task].uc_script_running_flags,str_task[l_uc_task].uc_script_completed_flags);
 422   1              #endif
 423   1              #endif
 424   1      }
 425          
 426          //------------------------------------------------------------------------------------
 427          // To get a timer for a scriptline, reset and started
 428          //      The procedure is as follow:
 429          //      -> Find an available timer by exhausive method
 430          //      -> When an available timer is found, claims its ownership, resets it, & starts it. 
 431          //      -> Indicate the sub-task as owning timer
 432          //      -> Indicate the sub-task as running the owned timer
 433          //      -> Indicate the task as having which timer
 434          //------------------------------------------------------------------------------------
 435          unsigned char scriptlineGetTimer (unsigned char l_uc_task, unsigned char l_uc_scriptline_bit)
 436          {
 437   1              unsigned char l_uc_i;
 438   1              unsigned char l_uc_timer_no = 0xFF;
 439   1      
 440   1              //Check task no given
 441   1              if (l_uc_task >= TASK_SIZE){
 442   2                      g_us_scriptline_timer_error_code = EC_INVALID_TASK_NO;
 443   2                      return l_uc_timer_no;
 444   2              }
 445   1      
 446   1              //Check scriptspace no given
 447   1              if (str_task[l_uc_task].uc_scriptspace >= SCRIPTSPACE_SIZE){
 448   2                      g_us_scriptline_timer_error_code = EC_INVALID_SCRIPTSPACE_NO;
 449   2                      return l_uc_timer_no;
 450   2              }
 451   1      
 452   1              //Adjust scriptline bit given
 453   1              //Ian (2012-05-15): The function to adjust scriptline bit is made
 454   1              l_uc_scriptline_bit = checkScriptlineBit(l_uc_scriptline_bit);
 455   1      
 456   1              //Search for unused task scriptline timer
 457   1              for (l_uc_i = 0; l_uc_i < SCRIPTLINE_TIMER_SIZE; l_uc_i++){
 458   2                      if ((str_scriptline_timer[l_uc_i].uc_scriptspace_owner == SP_SCRIPTSPACE_EMPTY) && !str_scriptline_timer
             -[l_uc_i].uc_scriptline_owner){
 459   3                              l_uc_timer_no = l_uc_i;
 460   3                              str_scriptline_timer[l_uc_i].uc_scriptspace_owner               = str_task[l_uc_task].uc_scriptspace;
 461   3                              str_scriptline_timer[l_uc_i].uc_scriptline_owner                = l_uc_scriptline_bit;
 462   3                              str_scriptline_timer[l_uc_i].uc_counter                                 = 0x00;
 463   3                              str_scriptline_timer[l_uc_i].ul_timer                                   = 0x00000000;
 464   3                              str_scriptline_timer[l_uc_i].uc_started                                 = 0x01;
 465   3                              str_task[l_uc_task].uc_script_timer_owning_flags                |= l_uc_scriptline_bit;
 466   3                              str_task[l_uc_task].uc_script_timer_running_flags               |= l_uc_scriptline_bit;
 467   3                              break;
 468   3                      }
 469   2              }
 470   1      
 471   1              //If an unused task scriptline timer is not found, update error
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 9   

 472   1              if (l_uc_timer_no != 0xFF)
 473   1                      g_us_scriptline_timer_error_code = EC_SUCCESSFUL;
 474   1              else g_us_scriptline_timer_error_code = EC_ALL_SCRIPTLINE_TIMER_IS_USED;
 475   1      
 476   1              return l_uc_timer_no;
 477   1      }
 478          
 479          //------------------------------------------------------------------------------------
 480          // To get timer no used by a scriptline
 481          //      The procedure is as follow:
 482          //      -> by exhausive search, check the timer no owned by the scriptline
 483          //      -> if it is found, return the number, else, return 0xFF
 484          //------------------------------------------------------------------------------------
 485          unsigned char scriptlineReadTimerNo (unsigned char l_uc_task, unsigned char l_uc_scriptline_bit)
 486          {
 487   1              unsigned char l_uc_i;
 488   1              unsigned char l_uc_timer_no = 0xFF;
 489   1      
 490   1              //Check scriptspace no given
 491   1              if (str_task[l_uc_task].uc_scriptspace >= SCRIPTSPACE_SIZE){
 492   2                      g_us_scriptline_timer_error_code = EC_INVALID_SCRIPTSPACE_NO;
 493   2                      return l_uc_timer_no;
 494   2              }
 495   1      
 496   1              //Adjust scriptline bit given
 497   1              l_uc_scriptline_bit = checkScriptlineBit(l_uc_scriptline_bit);
 498   1      
 499   1              //Read timer no
 500   1              for (l_uc_i = 0; l_uc_i < SCRIPTLINE_TIMER_SIZE; l_uc_i++){
 501   2                      if ((str_scriptline_timer[l_uc_i].uc_scriptspace_owner == str_task[l_uc_task].uc_scriptspace) && (str_sc
             -riptline_timer[l_uc_i].uc_scriptline_owner == l_uc_scriptline_bit)){
 502   3                              l_uc_timer_no = l_uc_i;
 503   3                              break;
 504   3                      }
 505   2              }
 506   1      
 507   1              //If an reading task scriptline timer is not found, update error
 508   1              if (l_uc_timer_no != 0xFF)
 509   1                      g_us_scriptline_timer_error_code = EC_SUCCESSFUL;
 510   1              else g_us_scriptline_timer_error_code = EC_FAIL_TO_READ_SCRIPTLINE_TIMER;
 511   1      
 512   1              return l_uc_timer_no;
 513   1      }
 514          
 515          //------------------------------------------------------------------------------------
 516          // To claim a timer for a scriptline
 517          //------------------------------------------------------------------------------------
 518          unsigned char scriptlineClaimTimer(unsigned char l_uc_task, unsigned char l_uc_scriptline_bit)
 519          {
 520   1              unsigned char l_uc_timer_no = 0xFF;
 521   1      
 522   1              //Check if this scriptline does not have a timer
 523   1              //If it does not have, claims a timer, if it has, continues
 524   1              if (!(str_task[l_uc_task].uc_script_timer_owning_flags & l_uc_scriptline_bit)){
 525   2                      l_uc_timer_no = scriptlineGetTimer (l_uc_task,l_uc_scriptline_bit);
 526   2                      g_uc_evha_flag |= EVENT_FLAG_SCPTLN_FIRST_TIME_GET_TIMER;
 527   2              }
 528   1              else {
 529   2                      l_uc_timer_no = scriptlineReadTimerNo (l_uc_task,l_uc_scriptline_bit);
 530   2                      g_uc_evha_flag &= ~EVENT_FLAG_SCPTLN_FIRST_TIME_GET_TIMER;
 531   2              }
 532   1      
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 10  

 533   1              return l_uc_timer_no;
 534   1      
 535   1      }
 536          
 537          //------------------------------------------------------------------------------------
 538          // To start a task flag's timer (unreset)
 539          //      The procedure is as follow:
 540          //      -> Get the task & scriptline owner of the timer
 541          //      -> Set the timer's scriptline owner's timer running flag
 542          //      -> Starts the timer
 543          //------------------------------------------------------------------------------------
 544          void scriptlineStartTimer (unsigned char l_uc_task, unsigned char l_uc_timer_no)
 545          {
 546   1              unsigned char l_uc_scriptline_bit;
 547   1      
 548   1              //Check for timer no validity
 549   1              if (l_uc_timer_no >= SCRIPTLINE_TIMER_SIZE)
 550   1                      g_us_scriptline_timer_error_code = EC_INVALID_SCRIPTLINE_TIMER_NO;
 551   1              else{
 552   2                      l_uc_scriptline_bit = str_scriptline_timer[l_uc_timer_no].uc_scriptline_owner;
 553   2              
 554   2                      str_task[l_uc_task].uc_script_running_flags     |= l_uc_scriptline_bit;
 555   2                      str_scriptline_timer[l_uc_timer_no].uc_started  = 0x01;
 556   2      
 557   2                      g_us_scriptline_timer_error_code = EC_SUCCESSFUL;
 558   2              }
 559   1      }
 560          
 561          //------------------------------------------------------------------------------------
 562          // To stop a task flag's timer (unreset)
 563          //      The procedure is as follow:
 564          //      -> Get the task & scriptline owner of the timer
 565          //      -> Reset the timer's scriptline owner's timer running flag
 566          //      -> Stops the timer
 567          //------------------------------------------------------------------------------------
 568          void scriptlineStopTimer (unsigned char l_uc_task, unsigned char l_uc_timer_no)
 569          {
 570   1              unsigned char l_uc_scriptline_bit;
 571   1      
 572   1              //Check for timer no validity
 573   1              if (l_uc_timer_no >= SCRIPTLINE_TIMER_SIZE)
 574   1                      g_us_scriptline_timer_error_code = EC_INVALID_SCRIPTLINE_TIMER_NO;
 575   1              else{
 576   2                      l_uc_scriptline_bit = str_scriptline_timer[l_uc_timer_no].uc_scriptline_owner;
 577   2              
 578   2                      str_task[l_uc_task].uc_script_timer_running_flags       &= ~l_uc_scriptline_bit;
 579   2                      str_scriptline_timer[l_uc_timer_no].uc_started          = 0x00;
 580   2      
 581   2                      g_us_scriptline_timer_error_code = EC_SUCCESSFUL;
 582   2              }
 583   1      }
 584          
 585          //------------------------------------------------------------------------------------
 586          // To release a timer from a scriptline's possession (unreset)
 587          //      The procedure is as follow:
 588          //      -> Get the task & sub-task owner of the timer
 589          //      -> Reset the timer's sub-task owner's timer owning & running flags
 590          //      -> Reset the timer's task owner's timer owned flags
 591          //      -> Stops the timer and set its owner to be nobody
 592          //------------------------------------------------------------------------------------
 593          void scriptlineReleaseTimer (unsigned char l_uc_task, unsigned char l_uc_timer_no)
 594          {
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 11  

 595   1              unsigned char l_uc_scriptline_bit;
 596   1      
 597   1              //Check for timer no validity
 598   1              if (l_uc_timer_no >= SCRIPTLINE_TIMER_SIZE)
 599   1                      g_us_scriptline_timer_error_code = EC_INVALID_SCRIPTLINE_TIMER_NO;
 600   1              else{
 601   2                      l_uc_scriptline_bit = str_scriptline_timer[l_uc_timer_no].uc_scriptline_owner;
 602   2              
 603   2                      str_task[l_uc_task].uc_script_timer_owning_flags        &= ~l_uc_scriptline_bit;
 604   2                      str_task[l_uc_task].uc_script_timer_running_flags       &= ~l_uc_scriptline_bit;
 605   2              
 606   2                      str_scriptline_timer[l_uc_timer_no].uc_started                          = 0x00;
 607   2                      str_scriptline_timer[l_uc_timer_no].uc_scriptspace_owner        = SP_SCRIPTSPACE_EMPTY;
 608   2                      str_scriptline_timer[l_uc_timer_no].uc_scriptline_owner         = 0x0000;       
 609   2      
 610   2                      g_us_scriptline_timer_error_code = EC_SUCCESSFUL;
 611   2              }
 612   1      }
 613          
 614          //------------------------------------------------------------------------------------
 615          // To release all timers from a task's possession (unreset)
 616          //      The procedure is as follow:
 617          //      -> For every timer, check whether it is possessed by a task
 618          //      -> If it is, release it
 619          //------------------------------------------------------------------------------------
 620          void scriptspaceReleaseAllTimer (unsigned char l_uc_task)
 621          {
 622   1              unsigned char l_uc_i;
 623   1      
 624   1              //Check task no given
 625   1              if (l_uc_task >= TASK_SIZE)
 626   1                      g_us_scriptline_timer_error_code = EC_INVALID_TASK_NO;
 627   1              else for (l_uc_i = 0; l_uc_i < SCRIPTLINE_TIMER_SIZE; l_uc_i++)
 628   1                      if (str_scriptline_timer[l_uc_i].uc_scriptspace_owner == str_task[l_uc_task].uc_scriptspace)
 629   1                              scriptlineReleaseTimer(l_uc_task,l_uc_i);
 630   1      }
 631          
 632          //------------------------------------------------------------------------------------
 633          // To start all timers from of a task (unreset)
 634          //      The procedure is as follow:
 635          //      -> For every timer, check whether it is possessed by a task
 636          //      -> If it is, starts it
 637          //------------------------------------------------------------------------------------
 638          void scriptspaceStartAllTimer (unsigned char l_uc_task)
 639          {
 640   1              unsigned char l_uc_i;
 641   1      
 642   1              //Check task no given
 643   1              if (l_uc_task >= TASK_SIZE)
 644   1                      g_us_scriptline_timer_error_code = EC_INVALID_TASK_NO;
 645   1              else for (l_uc_i = 0; l_uc_i < SCRIPTLINE_TIMER_SIZE; l_uc_i++)
 646   1                      if (str_scriptline_timer[l_uc_i].uc_scriptspace_owner == str_task[l_uc_task].uc_scriptspace)
 647   1                              scriptlineStartTimer(l_uc_task,l_uc_i);
 648   1      }
 649          
 650          //------------------------------------------------------------------------------------
 651          // To stop all timers from of a task (unreset)
 652          //      The procedure is as follow:
 653          //      -> For every timer, check whether it is possessed by a task
 654          //      -> If it is, stops it
 655          //------------------------------------------------------------------------------------
 656          void scriptspaceStopAllTimer (unsigned char l_uc_task)
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 12  

 657          {
 658   1              unsigned char l_uc_i;
 659   1      
 660   1              //Check task no given
 661   1              if (l_uc_task >= TASK_SIZE)
 662   1                      g_us_scriptline_timer_error_code = EC_INVALID_TASK_NO;
 663   1              else for (l_uc_i = 0; l_uc_i < SCRIPTLINE_TIMER_SIZE; l_uc_i++)
 664   1                      if (str_scriptline_timer[l_uc_i].uc_scriptspace_owner == str_task[l_uc_task].uc_scriptspace)
 665   1                              scriptlineStopTimer(l_uc_task,l_uc_i);
 666   1      }
 667          
 668          //------------------------------------------------------------------------------------
 669          // To reset a scriptline's timer
 670          //------------------------------------------------------------------------------------
 671          void resetScriptlineTimer (unsigned char l_uc_timer_no)
 672          {
 673   1              //Check for timer no validity
 674   1              if (l_uc_timer_no >= SCRIPTLINE_TIMER_SIZE)
 675   1                      g_us_scriptline_timer_error_code = EC_INVALID_SCRIPTLINE_TIMER_NO;
 676   1              else{
 677   2                      str_scriptline_timer[l_uc_timer_no].uc_counter          = 0x00;
 678   2                      str_scriptline_timer[l_uc_timer_no].ul_timer            = 0x00000000;
 679   2                      g_us_scriptline_timer_error_code = EC_SUCCESSFUL;
 680   2              }
 681   1      }
 682          
 683          //------------------------------------------------------------------------------------
 684          // To get a retry counter
 685          //------------------------------------------------------------------------------------
 686          unsigned char scriptlineGetRetryCounter (unsigned char l_uc_task, unsigned char l_uc_scriptline_bit)
 687          {
 688   1              unsigned char l_uc_retry_counter_no = 0xFF;
 689   1              unsigned char l_uc_i;
 690   1      
 691   1              //Check task no given
 692   1              if (l_uc_task >= TASK_SIZE){
 693   2                      g_us_scriptline_retry_counter_error_code = EC_INVALID_TASK_NO;
 694   2                      return l_uc_retry_counter_no;
 695   2              }
 696   1      
 697   1              //Adjust scriptline bit given
 698   1              l_uc_scriptline_bit = checkScriptlineBit(l_uc_scriptline_bit);
 699   1      
 700   1              //Get retry counter
 701   1              for (l_uc_i = 0; l_uc_i < SCRIPTLINE_RETRY_COUNTER_SIZE; l_uc_i++){
 702   2                      if ((str_scriptline_retry_counter[l_uc_i].uc_scriptspace_owner == SP_SCRIPTSPACE_EMPTY) && !str_scriptli
             -ne_retry_counter[l_uc_i].uc_scriptline_owner){
 703   3                              l_uc_retry_counter_no                                                                           = l_uc_i;
 704   3                              str_scriptline_retry_counter[l_uc_i].uc_scriptspace_owner       = str_task[l_uc_task].uc_scriptspace;
 705   3                              str_scriptline_retry_counter[l_uc_i].uc_scriptline_owner        = l_uc_scriptline_bit;
 706   3                              str_scriptline_retry_counter[l_uc_i].uc_counter                         = 0x00;
 707   3                              str_task[l_uc_task].uc_script_retry_counter_owning_flags        |= l_uc_scriptline_bit;
 708   3                              break;
 709   3                      }
 710   2              }
 711   1      
 712   1              //If an task scriptline retry counter cannot be obtained, update error
 713   1              if (l_uc_retry_counter_no != 0xFF)
 714   1                      g_us_scriptline_retry_counter_error_code = EC_SUCCESSFUL;
 715   1              else g_us_scriptline_retry_counter_error_code = EC_ALL_RETRY_COUNTER_IS_USED;
 716   1      
 717   1              return l_uc_retry_counter_no;
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 13  

 718   1      }
 719          
 720          //------------------------------------------------------------------------------------
 721          // To read a retry counter value
 722          //------------------------------------------------------------------------------------
 723          unsigned char scriptlineReadRetryCounter (unsigned char l_uc_task, unsigned char l_uc_scriptline_bit)
 724          {
 725   1              unsigned char l_uc_retry_counter_no = 0xFF;
 726   1              unsigned char l_uc_i;
 727   1      
 728   1              //Check scriptspace no given
 729   1              if (str_task[l_uc_task].uc_scriptspace >= SCRIPTSPACE_SIZE){
 730   2                      g_us_scriptline_timer_error_code = EC_INVALID_SCRIPTSPACE_NO;
 731   2                      return l_uc_retry_counter_no;
 732   2              }
 733   1      
 734   1              //Adjust scriptline bit given
 735   1              l_uc_scriptline_bit = checkScriptlineBit(l_uc_scriptline_bit);
 736   1      
 737   1              //Read retry counter used
 738   1              for (l_uc_i = 0; l_uc_i < SCRIPTLINE_RETRY_COUNTER_SIZE; l_uc_i++){
 739   2                      if ((str_scriptline_retry_counter[l_uc_i].uc_scriptspace_owner == str_task[l_uc_task].uc_scriptspace) &&
             - (str_scriptline_retry_counter[l_uc_i].uc_scriptline_owner == l_uc_scriptline_bit)){
 740   3                              l_uc_retry_counter_no = l_uc_i;
 741   3                              break;
 742   3                      }
 743   2              }
 744   1      
 745   1              //If an task scriptline retry counter cannot be read, update error
 746   1              if (l_uc_retry_counter_no != 0xFF)
 747   1                      g_us_scriptline_retry_counter_error_code = EC_SUCCESSFUL;
 748   1              else g_us_scriptline_retry_counter_error_code = EC_FAIL_TO_READ_SCRIPTLINE_RETRY_COUNTER;
 749   1      
 750   1              return l_uc_retry_counter_no;
 751   1      }
 752          
 753          //------------------------------------------------------------------------------------
 754          // To claim a retry counter
 755          //------------------------------------------------------------------------------------
 756          unsigned char scriptlineClaimRetryCounter (unsigned char l_uc_task, unsigned char l_uc_scriptline_bit)
 757          {
 758   1              unsigned char l_uc_retry_counter_no = 0xFF;
 759   1      
 760   1              //Check if this scriptline does not have a retry counter
 761   1              //If it does not have, gets a retry counter, if it has, reads its value
 762   1              if (!(str_task[l_uc_task].uc_script_retry_counter_owning_flags & l_uc_scriptline_bit))
 763   1                      l_uc_retry_counter_no = scriptlineGetRetryCounter (l_uc_task,l_uc_scriptline_bit);
 764   1              else l_uc_retry_counter_no = scriptlineReadRetryCounter (l_uc_task,l_uc_scriptline_bit);
 765   1      
 766   1              return l_uc_retry_counter_no;
 767   1      }
 768          
 769          //------------------------------------------------------------------------------------
 770          // To release a retry counter
 771          //------------------------------------------------------------------------------------
 772          void scriptlineReleaseRetryCounter (unsigned char l_uc_task, unsigned char l_uc_retry_counter_no)
 773          {
 774   1              unsigned char l_uc_scriptline_bit;
 775   1      
 776   1              //Check for l_uc_retry_counter_no validity
 777   1              if (l_uc_retry_counter_no >= SCRIPTLINE_RETRY_COUNTER_SIZE)
 778   1                      g_us_scriptline_retry_counter_error_code = EC_INVALID_SCRIPTLINE_RETRY_COUNTER_NO;
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 14  

 779   1              else{
 780   2                      l_uc_scriptline_bit = str_scriptline_retry_counter[l_uc_retry_counter_no].uc_scriptline_owner;
 781   2              
 782   2                      str_task[l_uc_task].uc_script_retry_counter_owning_flags                                        &= ~l_uc_scriptline_bit;
 783   2              
 784   2                      str_scriptline_retry_counter[l_uc_retry_counter_no].uc_scriptspace_owner        = SP_SCRIPTSPACE_EMPTY;
 785   2                      str_scriptline_retry_counter[l_uc_retry_counter_no].uc_scriptline_owner         = 0x00;
 786   2      
 787   2                      g_us_scriptline_retry_counter_error_code = EC_SUCCESSFUL;
 788   2              }
 789   1      }
 790          
 791          //------------------------------------------------------------------------------------
 792          // To release all retry counter owned by a task
 793          //------------------------------------------------------------------------------------
 794          void scriptspaceReleaseAllRetryCounter (unsigned char l_uc_task)
 795          {
 796   1              unsigned char l_uc_i;
 797   1      
 798   1              //Check task no given
 799   1              if (l_uc_task >= TASK_SIZE)
 800   1                      g_us_scriptline_retry_counter_error_code = EC_INVALID_TASK_NO;
 801   1              else for (l_uc_i = 0; l_uc_i < SCRIPTLINE_RETRY_COUNTER_SIZE; l_uc_i++)
 802   1                      if(str_scriptline_retry_counter[l_uc_i].uc_scriptspace_owner == str_task[l_uc_task].uc_scriptspace) 
 803   1                              scriptlineReleaseRetryCounter(l_uc_task,l_uc_i);
 804   1      }
 805          
 806          //------------------------------------------------------------------------------------
 807          // To read a scriptline
 808          //------------------------------------------------------------------------------------
 809          unsigned short readScriptline (unsigned char l_uc_task, unsigned char l_uc_scriptline_bit, unsigned short 
             -l_us_res_length)
 810          {
 811   1              unsigned short  l_us_error_code                                 = EC_SUCCESSFUL;        //dec22_yc EC_INIT
 812   1              unsigned char   l_uc_timer_check                                = 0;    //Initialize as failed
 813   1              unsigned char   l_uc_timer_no                                   = 0;
 814   1              unsigned char   l_uc_interval_period_used_no    = 0;
 815   1              unsigned char   l_uc_retry_counter_no                   = 0;
 816   1              unsigned char   l_uc_scriptline_end_handler     = 0;
 817   1              unsigned char   l_uc_complete_flag                              = 0;
 818   1              unsigned char   l_uc_error_flag                                 = 0;
 819   1              unsigned char   l_uc_scriptline_no                              = 0;
 820   1              unsigned char   l_uc_function_code                              = 0;
 821   1              unsigned char   l_uc_property                                   = 0;
 822   1              unsigned char   l_uc_end_doing                                  = 0;
 823   1              unsigned char   l_uc_argument                                   = 0;
 824   1              unsigned char   l_uc_i                                                  = 0;
 825   1      
 826   1              //Gets scriptline no
 827   1              for (l_uc_i = 0; l_uc_i < 8; l_uc_i++)
 828   1                      if ((l_uc_scriptline_bit >> l_uc_i) & 0x01){
 829   2                              l_uc_scriptline_no = l_uc_i;
 830   2                              break;
 831   2                      }
 832   1      
 833   1              #if (EVENT_HANDLER_ENABLE == 1)
 834   1              #if (STORING_ENABLE == 1)
 835   1              if (l_uc_task >= TASK_SIZE){//dec22_yc invalid l_uc_task_chosen tracks error only, not event...         
 836   2                      eventHandler(EV_TASK_MODULE+EC_INVALID_TASK_NO,l_uc_task,l_uc_scriptline_no,0,0,0,0);
 837   2                      return l_us_res_length;
 838   2              }
 839   1              #endif
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 15  

 840   1              #endif
 841   1      
 842   1              //Initialize the readScriptline
 843   1              l_uc_function_code      = str_scriptspace[str_task[l_uc_task].uc_scriptspace].uc_script[l_uc_scriptline_no][0
             -];
 844   1              l_uc_property           = str_scriptspace[str_task[l_uc_task].uc_scriptspace].uc_script[l_uc_scriptline_no][1];
 845   1              l_uc_end_doing          = str_scriptspace[str_task[l_uc_task].uc_scriptspace].uc_script[l_uc_scriptline_no][2];
 846   1              l_uc_argument           = str_scriptspace[str_task[l_uc_task].uc_scriptspace].uc_script[l_uc_scriptline_no][3];
 847   1      
 848   1              //Get the timer & interval period used first, then compare the timer with the wanted interval
 849   1              if (l_uc_property & 0x80){
 850   2                      l_uc_timer_no = scriptlineClaimTimer(l_uc_task,l_uc_scriptline_bit);
 851   2                      l_uc_interval_period_used_no = l_uc_property & 0x1F;
 852   2      
 853   2                      //Special case is if this is the first time the task script get the timer,
 854   2                      //Runs the script within maximum one second (later) after first time got timer
 855   2                      if ((g_uc_evha_flag & EVENT_FLAG_SCPTLN_FIRST_TIME_GET_TIMER) && !g_us_scriptline_timer_error_code){
 856   3                              str_scriptline_timer[l_uc_timer_no].ul_timer = (str_obdh_data.us_interval_period[l_uc_interval_period_u
             -sed_no] >= 10) ? str_obdh_data.us_interval_period[l_uc_interval_period_used_no]-10 : 0;
 857   3                              g_uc_evha_flag &= ~EVENT_FLAG_SCPTLN_FIRST_TIME_GET_TIMER;
 858   3                      }
 859   2              
 860   2                      //Check whether the timer has shown time which exceeds the interval
 861   2                      if ((str_scriptline_timer[l_uc_timer_no].ul_timer >= str_obdh_data.us_interval_period[l_uc_interval_peri
             -od_used_no]) && !g_us_scriptline_timer_error_code){
 862   3                              //Reset the timer for preparation for the next cycle
 863   3                              resetScriptlineTimer(l_uc_timer_no);
 864   3              
 865   3                              //Indicates this as having completed timer check
 866   3                              l_uc_timer_check = 1;
 867   3                      }
 868   2              }
 869   1              else //Indicates this as having completed timer check
 870   1                      l_uc_timer_check = 1;
 871   1      
 872   1              //If it passes timer check, runs the scriptline
 873   1              if (l_uc_timer_check){
 874   2                      switch (l_uc_function_code){
 875   3                              //This scriptline only rise up/put down flags of its own task as given by l_uc_argument
 876   3                              //Since this scriptline will not use timer, the 5 timer-bits (scriptline's property last 5 bits) are fr
             -ee to be used
 877   3                              //The 5-bits will be used to choose mode of the task flags manipulation. After the use of the argument,
             - this scriptline
 878   3                              //will automatically set its own complete flag (there is no error) and provide its necessary end handle
             -r type
 879   3                              // Mode 1: normal running flags (00000)
 880   3                              //      In this mode, the running flags will be changed according to what is referred in l_uc_argument
 881   3                              //      and that's all
 882   3                              // Mode 2: forced running flags (00001)
 883   3                              //      In this mode, the running flags will be changed according to what is referred in l_uc_argument
 884   3                              //      and the error flags and completed flags will be put down (on the running tasks)
 885   3                              case SCRIPT_CMD_CHANGE_TASK_FLAGS:
 886   3                                      if ((l_uc_property & 0x1F) == 0x00){
 887   4                                              str_task[l_uc_task].uc_script_running_flags     = l_uc_argument;
 888   4                                      }
 889   3                                      else if ((l_uc_property & 0x1F) == 0x01){
 890   4                                              str_task[l_uc_task].uc_script_running_flags     = l_uc_argument;
 891   4                                              str_task[l_uc_task].uc_script_completed_flags   &= ~str_task[l_uc_task].uc_script_running_flags;
 892   4                                              str_task[l_uc_task].uc_script_error_flags               &= ~str_task[l_uc_task].uc_script_running_flags;
 893   4                                      }
 894   3                                      l_uc_complete_flag = 1;
 895   3                                      l_uc_property = 0x00;
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 16  

 896   3                                      l_uc_end_doing = 0x00;
 897   3                                      break;
 898   3      
 899   3                              //Script command to get housekeeping data
 900   3                              case SCRIPT_CMD_GET_HK:
 901   3                                      getHK();
 902   3                                      break;
 903   3      
 904   3                              #if (STORING_ENABLE == 1)
 905   3                              //Script command to store housekeeping data
 906   3                              case SCRIPT_CMD_STORE_HK:
 907   3                                      storeHK();
 908   3                                      break;
 909   3                              #endif
 910   3      
 911   3                              //Script command to get SSCP data
 912   3                              case SCRIPT_CMD_GET_SSCP:
 913   3                                      getSSCP();
 914   3                                      break;
 915   3      
 916   3                              //Script command to initialize data logging mission
 917   3                              case SCRIPT_CMD_INIT_LOG_DATA:
 918   3                                      initLogData();
 919   3                                      l_uc_complete_flag = 1;
 920   3                                      break;
 921   3      
 922   3                              //Script command to do data logging mission
 923   3                              //If at any point of time, one of the following two conditions happen:
 924   3                              // 1) BP reset occurs
 925   3                              // 2) g_us_log_data_elapsed_time_s has exceeded str_obdh_data.us_log_data_duration_s
 926   3                              //Then this scriptline is completed
 927   3                              case SCRIPT_CMD_LOG_DATA:
 928   3                                      logData();
 929   3                                      if (g_us_log_data_elapsed_time_s >= str_obdh_data.us_log_data_duration_s)
 930   3                                              l_uc_complete_flag = 1;
 931   3                                      break;
 932   3      
 933   3                              //Script command to terminate data logging mission
 934   3                              case SCRIPT_CMD_TERMINATE_LOG_DATA:
 935   3                                      terminateLogData();
 936   3                                      l_uc_complete_flag = 1;
 937   3                                      break;
 938   3      
 939   3                              #if (PWRS_CMD_ENABLE == 1)
 940   3                              //Script command to set/reset thermal knife channel (ON/OFF)
 941   3                              case SCRIPT_CMD_SET_TK_CHANNEL:
 942   3                                      #if (DEBUGGING_FEATURE == 1)
 943   3                                      l_us_error_code = pwrsSetTKOutput (TK_TEST_CHANNEL, (l_uc_argument & 0x01), TIME_LIMIT_SET_RESET_CHANN
             -EL_MS, 0);                                
 944   3                                      #else
                                              l_us_error_code = pwrsSetTKOutput (TK_TEST_CHANNEL, (l_uc_argument & 0x01), TIME_LIMIT_SET_RESET_CHANN
             -EL_MS);                                
                                              #endif
 947   3                                      if (l_us_error_code) l_uc_error_flag = 1;
 948   3                                      else l_uc_complete_flag = 1;
 949   3                                      break;
 950   3      
 951   3                              //Script command to check thermal knife channel (whether it has been turned as desired or not)
 952   3                              case SCRIPT_CMD_CHECK_TK_CHANNEL:
 953   3                                      //Get PWRS' thermal knife register data
 954   3                                      #if (DEBUGGING_FEATURE == 1)
 955   3                                      l_us_error_code = pwrsGetData (DATA_PWRS_C_THERMAL_KNIFE, 0);
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 17  

 956   3                                      #else
                                              l_us_error_code = pwrsGetData (DATA_PWRS_C_THERMAL_KNIFE);
                                              #endif
 959   3      
 960   3                                      //Only valid when there is no error code
 961   3                                      if (!l_us_error_code){
 962   4                                              //Check if enable flag has been as expected
 963   4                                              if ((g_uc_i2c_data_in[3] & TEST_TK_ENABLE_FLAG) == l_uc_argument)
 964   4                                                      //If it is, considers the scriptline as completed
 965   4                                                      l_uc_complete_flag = 1;
 966   4                                      }
 967   3      
 968   3                                      //If timeout occurs at any point of time
 969   3                                      if (g_uc_tk_waiting_s >= TIME_LIMIT_TK_WAITING_S)
 970   3                                              //Considers the scriptline as errorneous
 971   3                                              l_uc_error_flag = 1;
 972   3                                      break;
 973   3      
 974   3                              //Script command to check thermal knife, whether it has been cut (with timeout checking)
 975   3                              case SCRIPT_CMD_CHECK_TK_CUT:
 976   3                                      //Get PWRS' thermal knife register data
 977   3                                      #if (DEBUGGING_FEATURE == 1)
 978   3                                      l_us_error_code = pwrsGetData (DATA_PWRS_C_THERMAL_KNIFE, 0);
 979   3                                      #else
                                              l_us_error_code = pwrsGetData (DATA_PWRS_C_THERMAL_KNIFE);
                                              #endif
 982   3      
 983   3                                      //Only valid when there is no error code
 984   3                                      if (!l_us_error_code){
 985   4                                              //Check if cutting flag has been as expected
 986   4                                              if ((g_uc_i2c_data_in[3] & TEST_TK_CUT_FLAG) == l_uc_argument)
 987   4                                                      //If it is, considers the scriptline as completed
 988   4                                                      l_uc_complete_flag = 1;
 989   4                                      }
 990   3      
 991   3                                      //If timeout occurs at any point of time
 992   3                                      if (g_uc_tk_uptime_s >= TIME_LIMIT_TK_CUTTING_S)
 993   3                                              //Considers the scriptline as errorneous
 994   3                                              l_uc_error_flag = 1;
 995   3                                      break;
 996   3      
 997   3                              //Script command to set single PWRS channel
 998   3                              case SCRIPT_CMD_SET_SINGLE_PWRS_CHANNEL:
 999   3                                      //PWRS' set single output command is called
1000   3                                      #if (DEBUGGING_FEATURE == 1)
1001   3                                      l_us_error_code = pwrsSetSingleOutput ((l_uc_argument & 0x7F),((l_uc_argument & 0x80) >> 7),TIME_LIMIT
             -_SET_RESET_CHANNEL_MS,DEBUGGING_FEATURE);
1002   3                                      #else
                                              l_us_error_code = pwrsSetSingleOutput ((l_uc_argument & 0x7F),((l_uc_argument & 0x80) >> 7),TIME_LIMIT
             -_SET_RESET_CHANNEL_MS);
                                              #endif
1005   3                                      if (l_us_error_code) l_uc_error_flag = 1;
1006   3                                      else l_uc_complete_flag = 1;
1007   3                                      break;
1008   3      
1009   3                              //Script command to check single PWRS channel, whether it has been as expected
1010   3                              case SCRIPT_CMD_CHECK_SINGLE_PWRS_CHANNEL:
1011   3                                      //If successful occurs at any point of time
1012   3                                      if (!g_us_latest_ch_stat_update_ec)
1013   3                                              if ((((l_uc_argument & 0x80) >> 7) && (str_pwrs_data.uc_channel_status & (l_uc_argument & 0x7F))) || 
             -(((!((l_uc_argument & 0x80) >> 7))) && (~(str_pwrs_data.uc_channel_status | ~(l_uc_argument & 0x7F)))))
1014   3                                                      l_uc_complete_flag = 1;
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 18  

1015   3      
1016   3                                      //If timeout occurs at any point of time
1017   3                                      if (g_uc_deployment_channel_waiting_s >= TIME_LIMIT_DPLY_WAIITING_S)
1018   3                                              //Considers the scriptline as errorneous
1019   3                                              l_uc_error_flag = 1;
1020   3                                      break;
1021   3                              #endif
1022   3      
1023   3                              #if (ANTENNA_CMD_ENABLE == 1)
1024   3                              //Script command to execute antenna auto-deployment mechanism
1025   3                              case SCRIPT_CMD_ANTENNA_AUTO_DPLY:
1026   3                                      //Arms the antenna first, then wait for 50 ms
1027   3                                      l_us_error_code = antennaI2C (g_uc_antenna_addr, ANTENNA_I2C_ARM, 0);
1028   3                                      waitMs(50);
1029   3                                      
1030   3                                      //Only proceeds if there is no error code
1031   3                                      if (!l_us_error_code){
1032   4                                              //Antenna auto-deployment mechanism is called
1033   4                                              #if (DEBUGGING_FEATURE == 1)
1034   4                                              l_us_error_code = antennaI2CPar (g_uc_antenna_addr,ANTENNA_I2C_AUTO_DPLY,TIME_LIMIT_ANTENNA_WAIITING_
             -S,DEBUGGING_FEATURE);
1035   4                                              #else
                                                      l_us_error_code = antennaI2CPar (g_uc_antenna_addr,ANTENNA_I2C_AUTO_DPLY,TIME_LIMIT_ANTENNA_WAIITING_
             -S);
                                                      #endif
1038   4                                      }
1039   3      
1040   3                                      if (l_us_error_code) l_uc_error_flag = 1;
1041   3                                      else l_uc_complete_flag = 1;
1042   3                                      break;
1043   3      
1044   3                              //Script command to check antenna auto-deployment mechanism
1045   3                              case SCRIPT_CMD_CHECK_ANTENNA_DPLY_STAT:
1046   3                                      //Get antenna deployment status
1047   3                                      l_us_error_code = antennaI2C (g_uc_antenna_addr, ANTENNA_I2C_GET_DPLY_STAT, 0);
1048   3      
1049   3                                      //Proceeds if there is no error code
1050   3                                      //Check antenna deployment status byte, only consider the case as successful if all antennas are deplo
             -yed
1051   3                                      if ((!l_us_error_code) && (!(str_antenna_hk.us_deployment_status & INITIAL_ANTENNA_STATUS)))
1052   3                                              //Considers the scriptline as successful
1053   3                                              l_uc_complete_flag = 1;
1054   3      
1055   3                                      //If timeout occurs at any point of time or if there is an error code
1056   3                                      if ((g_uc_antenna_deployment_waiting_s >= TIME_LIMIT_ANTENNA_WAIITING_S*4+20) || l_us_error_code)
1057   3                                              //Considers the scriptline as errorneous
1058   3                                              l_uc_error_flag = 1;
1059   3                                      break;
1060   3                              #endif
1061   3      
1062   3                              default:
1063   3                                      break;
1064   3                      }       
1065   2              }
1066   1      
1067   1              //Handle completed scriptline
1068   1              if (l_uc_complete_flag){
1069   2                      //Adds the scriptline end handler timed & last flags
1070   2                      l_uc_scriptline_end_handler |= (l_uc_property & 0xC0);
1071   2                      
1072   2                      //Adds the scriptline progress/regress flags for completed scriptline
1073   2                      l_uc_scriptline_end_handler |= (l_uc_end_doing & 0xF0) >> 2;
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 19  

1074   2      
1075   2                      //Marks the scriptline as successful
1076   2                      l_uc_scriptline_end_handler |= 0x03;
1077   2      
1078   2                      //Runs scriptline end handler
1079   2                      scriptlineEndHandler(l_uc_task,l_uc_scriptline_bit,l_uc_scriptline_end_handler,l_uc_retry_counter_no);
1080   2              }
1081   1      
1082   1              //Handle erroneous scriptline
1083   1              if (l_uc_error_flag){
1084   2                      //Adds the scriptline end handler timed & last flags
1085   2                      l_uc_scriptline_end_handler |= (l_uc_property & 0xC0);
1086   2                      
1087   2                      //Adds the scriptline progress/regress flags for errorneous scriptline
1088   2                      l_uc_scriptline_end_handler |= (l_uc_end_doing & 0x0F) << 2;
1089   2      
1090   2                      //If the task is a critical task
1091   2                      if (l_uc_property & 0x20)
1092   2                              //Marks the scriptline as critically erroneous
1093   2                              l_uc_scriptline_end_handler |= 0x02;
1094   2                      else
1095   2                              //Marks the scriptline as non-critically erroneous
1096   2                              l_uc_scriptline_end_handler |= 0x01;
1097   2      
1098   2                      //Runs scriptline end handler
1099   2                      scriptlineEndHandler(l_uc_task,l_uc_scriptline_bit,l_uc_scriptline_end_handler,l_uc_retry_counter_no);
1100   2              }
1101   1      
1102   1              return l_us_res_length;
1103   1      }
1104          #endif
1105          
1106          //------------------------------------------------------------------------------------
1107          // To get housekeeping data
1108          //------------------------------------------------------------------------------------
1109          void getHK (void)
1110          {
1111   1              #if (ADCS_CMD_ENABLE == 1)
1112   1              //Only get housekeeping from ADCS if it has been turned ON for at least TIME_DELAY_ACS_TO_ON_AFTER_ADS_ON
             -_S
1113   1              if (g_ul_ads_uptime_s >= TIME_DELAY_ACS_TO_ON_AFTER_ADS_ON_S){
1114   2                      //Get housekeeping from ADCS
1115   2                      g_us_latest_adcs_hk_ec = adcsI2C(ADCS_I2C_GET_HK,0);
1116   2              
1117   2                      #if (BODY_RATE_HANDLER_ENABLE == 1)
1118   2                      #if (ADCS_CMD_ENABLE == 1)
1119   2                      #if (PWRS_CMD_ENABLE == 1)
1120   2                      //If no error code, update body rate control variables
1121   2                      //If ADCS is not turned ON, therefore, this body rate will not be updated
1122   2                      if (!g_us_latest_adcs_hk_ec) {
1123   3                              #if (EXTRA_ENABLE == 1)
1124   3                              updateBodyRateAverage();
1125   3                              #endif
1126   3              
1127   3                              //Update ADCS detumble mode flag for BRH
1128   3                              if (str_adcs_hk.c_mode == ADCS_MODE_DETUMBLE)
1129   3                                      str_obdh_hk.us_brh_flag |= BRH_FLAG_DET_ON;
1130   3                              else str_obdh_hk.us_brh_flag &= ~BRH_FLAG_DET_ON;
1131   3                      }
1132   2                      //If ADCS latest housekeeping reading is not available, then ADS must not be ON
1133   2                      //In that case BRH will be considered not ready by systemUpdateAndMonitor already, no need to
1134   2                      //bother here.
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 20  

1135   2                      #endif
1136   2                      #endif
1137   2                      #endif
1138   2              }
1139   1              //Else
1140   1              else g_us_latest_adcs_hk_ec = EC_ADCS_NOT_READY;
1141   1              #else
                      g_us_latest_adcs_hk_ec = EC_ADCS_CMD_DISABLED;
                      #endif
1144   1      
1145   1              #if (PWRS_CMD_ENABLE == 1)
1146   1              //Get housekeeping from PWRS
1147   1              g_us_latest_pwrs_hk_ec = pwrsI2C(PWRS_I2C_GET_HK,0);
1148   1              #else
                      g_us_latest_pwrs_hk_ec = EC_PWRS_CMD_DISABLED;
                      #endif
1151   1      
1152   1              #if (ISIS_CMD_ENABLE == 1)
1153   1              //Get housekeeping from COMM
1154   1              #if (DEBUGGING_FEATURE == 1)
1155   1              if (str_pwrs_data.uc_channel_status & COMM_CHANNEL_BIT)
1156   1                      isisGetHousekeeping(0); //Returning error code here is removed, as it is redundant with what is in luxp[
             -version]_isis.c (20120328)
1157   1              else g_us_latest_comm_hk_ec = EC_COMM_IS_OFF;
1158   1              #else
                      if (str_pwrs_data.uc_channel_status & COMM_CHANNEL_BIT)
                              g_us_latest_comm_hk_ec = isisGetHousekeeping();
                      else g_us_latest_comm_hk_ec = EC_COMM_IS_OFF;
                      #endif
1163   1              #else
                      g_us_latest_comm_hk_ec = EC_ISIS_CMD_DISABLED;
                      #endif
1166   1      
1167   1              #if (TIME_ENABLE == 1)
1168   1              //Get housekeeping time and orbit stamp
1169   1              getHKTimeAndOrbit();
1170   1              #endif
1171   1      
1172   1      }
1173          
1174          #if (STORING_ENABLE == 1)
1175          //------------------------------------------------------------------------------------
1176          // To store housekeeping
1177          //------------------------------------------------------------------------------------
1178          void storeHK (void)
1179          {
1180   1              #if (TASK_ENABLE == 1)
1181   1      
1182   1              //To store all housekeeping data
1183   1              g_us_latest_saving_hk_ec = saveDataProtected (ALL_SUBSYSTEMS, SD_HK, g_uc_sd_data_buffer);
1184   1      
1185   1              //Increase no of HK data stored taken
1186   1              if (!g_us_latest_saving_hk_ec) str_obdh_hk.ul_wod_sample_count++;
1187   1      
1188   1              #if (EVENT_HANDLER_ENABLE == 1)
1189   1              else{
1190   2                      //dec22_yc event log tested i/p dec21_yc        
1191   2                      eventHandler(EV_TASK_MODULE+SCRIPT_CMD_STORE_HK,g_us_latest_saving_hk_ec>>8,g_us_latest_saving_hk_ec,0,0
             -,0,0);
1192   2                      //dec22_yc event log catches other errors
1193   2              }
1194   1              #endif
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 21  

1195   1      
1196   1              #endif
1197   1      }
1198          #endif
1199          
1200          #if (TASK_ENABLE == 1)
1201          //------------------------------------------------------------------------------------
1202          // To get SSCP
1203          //------------------------------------------------------------------------------------
1204          void getSSCP (void)
1205          {
1206   1              #if (ADCS_CMD_ENABLE == 1)
1207   1              //To get latest SSCP of the subsystem
1208   1              //Only get SSCP from ADCS if it has been turned ON for at least TIME_DELAY_ACS_TO_ON_AFTER_ADS_ON_S
1209   1              if (g_ul_ads_uptime_s >= TIME_DELAY_ACS_TO_ON_AFTER_ADS_ON_S)
1210   1                      //Get SSCP from ADCS
1211   1                      g_us_latest_adcs_sscp_ec = adcsI2C(ADCS_I2C_GET_SSCP,0);
1212   1              //Else
1213   1              else g_us_latest_adcs_sscp_ec = EC_ADCS_NOT_READY;
1214   1              #else
                      g_us_latest_adcs_sscp_ec = EC_ADCS_CMD_DISABLED;
                      #endif
1217   1      
1218   1              #if (PWRS_CMD_ENABLE == 1)
1219   1              //Get SSCP from PWRS
1220   1              g_us_latest_pwrs_sscp_ec = pwrsI2C(PWRS_I2C_GET_SSCP,0);
1221   1              #else
                      g_us_latest_pwrs_sscp_ec = EC_PWRS_CMD_DISABLED;
                      #endif
1224   1      }
1225          
1226          //------------------------------------------------------------------------------------
1227          // To initialize logging of the declared data type
1228          //------------------------------------------------------------------------------------
1229          void initLogData (void)
1230          {
1231   1              //Initialize memory space
1232   1              str_bp.ul_datalog_write_p = SD_BP_DATALOG_START;
1233   1      
1234   1              //Initialize elapsed time
1235   1              g_us_log_data_elapsed_time_s = 0;
1236   1      
1237   1              //Initialize log data buffer index
1238   1              g_us_log_data_buffer_index = 0;
1239   1      
1240   1              //Initialize log data block size
1241   1              g_us_log_data_block_size = 0;
1242   1      
1243   1              //To put initial data set in the log data buffer
1244   1              g_us_log_data_buffer_index = fillData (&g_uc_log_data_buffer, g_us_log_data_buffer_index, DATA_CAT_LOG_DA
             -TA_INIT_SET, 0);
1245   1      
1246   1              #if (EVENT_HANDLER_ENABLE == 1)
1247   1              #if (STORING_ENABLE == 1)
1248   1              //dec22_yc event log    
1249   1              eventHandler(EV_TASK_MODULE+SCRIPT_CMD_INIT_LOG_DATA,0,0,0,0,0,0);
1250   1              //dec22_yc event log catches other errors
1251   1              #endif
1252   1              #endif
1253   1      
1254   1      }
1255          
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 22  

1256          //------------------------------------------------------------------------------------
1257          // To log the declared data type
1258          //------------------------------------------------------------------------------------
1259          //      To log every data declared and put them into the log data set
1260          //
1261          //      If the log data buffer still has space. What is put in the log data set will be
1262          //      put in the log data buffer. 
1263          //
1264          //      If it does not, the log data buffer will first be saved (and therefore, cleared)
1265          //      Then the log data set will be put in the log data buffer
1266          //
1267          //      The elapsed time is taken before data is obtained
1268          //
1269          //      The error code is accumulated into one single (char) error code
1270          //------------------------------------------------------------------------------------
1271          void logData (void)
1272          {
1273   1              unsigned char l_uc_i = 0;
1274   1              unsigned char l_uc_j = 0;
1275   1              unsigned char l_uc_data_set_counter = 1;
1276   1              unsigned char l_uc_subsystem;
1277   1              unsigned char l_uc_data_type;
1278   1              unsigned short l_us_indv_error_code;
1279   1              unsigned char l_uc_error_code = 0;      //Assuming all correct at first
1280   1              unsigned short l_us_log_data_elapsed_time_s;
1281   1      
1282   1              //This local variable is created to eliminate elapsing time recording error
1283   1              //Due to interrupt update while recording the elapsed time
1284   1              l_us_log_data_elapsed_time_s = g_us_log_data_elapsed_time_s;
1285   1      
1286   1              //Insert elapsed time to the log data set buffer
1287   1              g_uc_log_data_set[l_uc_data_set_counter++] = l_us_log_data_elapsed_time_s >> 8;
1288   1              g_uc_log_data_set[l_uc_data_set_counter++] = l_us_log_data_elapsed_time_s;
1289   1      
1290   1              //Loop to collect data, based on the data type request
1291   1              for (l_uc_i     = 0; l_uc_i < MAX_NO_OF_DATA_TYPE_LOGGED; l_uc_i++){
1292   2                      //Get the data type requested
1293   2                      l_uc_subsystem = str_obdh_par.us_log_data_id[l_uc_i] >> 8;
1294   2                      l_uc_data_type = str_obdh_par.us_log_data_id[l_uc_i];
1295   2      
1296   2                      //Check the data type requested, get the data
1297   2                      if (l_uc_subsystem == ADCS_ADDR){
1298   3                              #if (ADCS_CMD_ENABLE == 1)
1299   3                              #if (DEBUGGING_FEATURE == 1)
1300   3                              l_us_indv_error_code = adcsGetData(l_uc_data_type,0);
1301   3                              #else
                                      l_us_indv_error_code = adcsGetData(l_uc_data_type);
                                      #endif
1304   3                              #else
                                      l_us_indv_error_code = EC_ADCS_CMD_DISABLED;
                                      #endif
1307   3                      }
1308   2                      else if (l_uc_subsystem == PWRS_ADDR){
1309   3                              #if (PWRS_CMD_ENABLE == 1)
1310   3                              #if (DEBUGGING_FEATURE == 1)
1311   3                              l_us_indv_error_code = pwrsGetData(l_uc_data_type,0);
1312   3                              #else
                                      l_us_indv_error_code = pwrsGetData(l_uc_data_type);
                                      #endif
1315   3                              #else
                                      l_us_indv_error_code = EC_PWRS_CMD_DISABLED;
                                      #endif
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 23  

1318   3                      }
1319   2                      else l_us_indv_error_code = EC_SUBSYSTEM_TO_LOG_DATA_UNDEFINED;
1320   2      
1321   2                      //Update the l_uc_error_code
1322   2                      if (l_us_indv_error_code) 
1323   2                              l_uc_error_code |= (0x80 >> l_uc_i);
1324   2                      //Obsolete line is removed (20120328)
1325   2      
1326   2                      //Insert the data in g_uc_i2c_data_in buffer
1327   2                      //Constant is replaced by unique PWRS_I2C_GET_DATA_RD (20120328)
1328   2                      for (l_uc_j     = 0; l_uc_j < PWRS_I2C_GET_DATA_RD; l_uc_j++)
1329   2                              g_uc_log_data_set[l_uc_data_set_counter++] = g_uc_i2c_data_in[l_uc_j];
1330   2              }
1331   1      
1332   1              //Insert the error code to the log data set buffer
1333   1              g_uc_log_data_set[0] = l_uc_error_code;
1334   1      
1335   1              //Check if the log data buffer still has space
1336   1              if (g_us_log_data_buffer_index+LOG_DATA_SET_SIZE <= LOG_DATA_BUFFER_SIZE)
1337   1                      //Put the data set in the log data buffer
1338   1                      g_us_log_data_buffer_index = fillData (&g_uc_log_data_buffer, g_us_log_data_buffer_index, DATA_CAT_LOG_D
             -ATA_SET, 0);
1339   1              //If the log data buffer does not have space anymore
1340   1              else{
1341   2                      #if (STORING_ENABLE == 1)
1342   2                      //Save the logged data to the SD card
1343   2                      l_us_indv_error_code = saveDataProtected (ALL_SUBSYSTEMS, SD_LOG_DATA, g_uc_sd_data_buffer);
1344   2                      #endif
1345   2      
1346   2                      //Increase the log data block size upon successful logging
1347   2                      if (!l_us_indv_error_code) g_us_log_data_block_size++;
1348   2      
1349   2                      //Reset the data buffer index to zero
1350   2                      g_us_log_data_buffer_index = 0;
1351   2      
1352   2                      //Put the data set in the log data buffer
1353   2                      g_us_log_data_buffer_index = fillData (&g_uc_log_data_buffer, g_us_log_data_buffer_index, DATA_CAT_LOG_D
             -ATA_SET, 0);
1354   2              }
1355   1      
1356   1              #if (EVENT_HANDLER_ENABLE == 1)
1357   1              #if (STORING_ENABLE == 1)
1358   1              //dec22_yc event log    
1359   1              eventHandler(EV_TASK_MODULE+SCRIPT_CMD_LOG_DATA,l_uc_error_code,0,0,0,0,0);
1360   1              //dec22_yc event log catches other errors
1361   1              #endif
1362   1              #endif
1363   1      }
1364          
1365          //------------------------------------------------------------------------------------
1366          // To terminates logging mission
1367          //------------------------------------------------------------------------------------
1368          void terminateLogData (void)
1369          {
1370   1              #if (STORING_ENABLE == 1)
1371   1              unsigned short l_us_error_code;
1372   1      
1373   1              //Save the latest logged data to the SD card
1374   1              l_us_error_code = saveDataProtected (ALL_SUBSYSTEMS, SD_LOG_DATA, g_uc_sd_data_buffer);
1375   1      
1376   1              #if (EVENT_HANDLER_ENABLE == 1)
1377   1              //dec22_yc event log    
C51 COMPILER V9.02   LUXP_TASK                                                             01/09/2014 12:21:21 PAGE 24  

1378   1              eventHandler(EV_TASK_MODULE+SCRIPT_CMD_TERMINATE_LOG_DATA,l_us_error_code>>8,l_us_error_code,0,0,0,0);
1379   1              //dec22_yc event log catches other errors
1380   1              #endif
1381   1              #endif
1382   1      }
1383          
1384          //------------------------------------------------------------------------------------
1385          // Adjust scriptline bit given
1386          //------------------------------------------------------------------------------------
1387          unsigned char checkScriptlineBit (unsigned char l_uc_scriptline_bit)
1388          {
1389   1              unsigned char l_uc_scriptline_bit_ret;
1390   1      
1391   1              //Adjust scriptline bit given
1392   1              if (l_uc_scriptline_bit & 0x01)                 l_uc_scriptline_bit_ret = 0x01;
1393   1              else if (l_uc_scriptline_bit & 0x02)    l_uc_scriptline_bit_ret = 0x02;
1394   1              else if (l_uc_scriptline_bit & 0x04)    l_uc_scriptline_bit_ret = 0x04;
1395   1              else if (l_uc_scriptline_bit & 0x08)    l_uc_scriptline_bit_ret = 0x08;
1396   1              else if (l_uc_scriptline_bit & 0x10)    l_uc_scriptline_bit_ret = 0x10;
1397   1              else if (l_uc_scriptline_bit & 0x20)    l_uc_scriptline_bit_ret = 0x20;
1398   1              else if (l_uc_scriptline_bit & 0x40)    l_uc_scriptline_bit_ret = 0x40;
1399   1              else l_uc_scriptline_bit_ret = 0x80;
1400   1      
1401   1              return l_uc_scriptline_bit_ret;
1402   1      }
1403          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4687    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      63
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
